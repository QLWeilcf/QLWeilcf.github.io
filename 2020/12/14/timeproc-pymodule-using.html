<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/lynsdata_favicon_64.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/lynsdata_favicon_64.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/lynsdata_favicon_48.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lynsdata.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#1eafae","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":15},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="时间数据时间格式是数据类型中基础也不容忽视的一类。不像整数那样大道至简也不像字符串那样包罗万象，却独有魅力，时间数据本身除了加减、比较运算外，也有下周、去年、时区等更专项的时间切换。在各类编程语言里都提供时间对象的支持，在MySQL里也有DATETIME类型。商业里的DAU、GMV、LTV也少不了时间限定和时间属性，因此数据分析时少不了对时间数据类型的处理与转换。Python通过套件time、da">
<meta property="og:type" content="article">
<meta property="og:title" content="Python时间处理模块的常用选择：八大模块，万字长文">
<meta property="og:url" content="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using.html">
<meta property="og:site_name" content="Lynsdata">
<meta property="og:description" content="时间数据时间格式是数据类型中基础也不容忽视的一类。不像整数那样大道至简也不像字符串那样包罗万象，却独有魅力，时间数据本身除了加减、比较运算外，也有下周、去年、时区等更专项的时间切换。在各类编程语言里都提供时间对象的支持，在MySQL里也有DATETIME类型。商业里的DAU、GMV、LTV也少不了时间限定和时间属性，因此数据分析时少不了对时间数据类型的处理与转换。Python通过套件time、da">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using/time-1209-1-overview-fishbonemap.PNG">
<meta property="og:image" content="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using/time-1209-2-strftime-fmt.PNG">
<meta property="og:image" content="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using/time-1209-4-1-calendar.PNG">
<meta property="og:image" content="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using/3-timestramp-03.PNG">
<meta property="og:image" content="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using/time-1209-14-pv.PNG">
<meta property="og:image" content="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using/time-1209-15-pv.PNG">
<meta property="article:published_time" content="2020-12-13T16:00:21.000Z">
<meta property="article:modified_time" content="2020-12-17T17:10:52.031Z">
<meta property="article:author" content="Lyndon">
<meta property="article:tag" content="python">
<meta property="article:tag" content="time">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using/time-1209-1-overview-fishbonemap.PNG">

<link rel="canonical" href="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python时间处理模块的常用选择：八大模块，万字长文 | Lynsdata</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lynsdata</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">lyndon's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-viz">

    <a href="/viz/" rel="section"><i class="fa fa-th fa-fw"></i>viz</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lynsdata.cn/2020/12/14/timeproc-pymodule-using.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lynsdata_avatar_49.png">
      <meta itemprop="name" content="Lyndon">
      <meta itemprop="description" content="再勇敢一些">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lynsdata">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python时间处理模块的常用选择：八大模块，万字长文
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-14 00:00:21" itemprop="dateCreated datePublished" datetime="2020-12-14T00:00:21+08:00">2020-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-18 01:10:52" itemprop="dateModified" datetime="2020-12-18T01:10:52+08:00">2020-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
			<span class="post-meta-divider">|</span>
				<span title="post.wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> 5.2k 字 | ≈</span>
           <span title="post.min2read">
				20 分钟
			</span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="时间数据"><a href="#时间数据" class="headerlink" title="时间数据"></a>时间数据</h2><p>时间格式是数据类型中基础也不容忽视的一类。不像整数那样大道至简也不像字符串那样包罗万象，却独有魅力，时间数据本身除了加减、比较运算外，也有下周、去年、时区等更专项的时间切换。在各类编程语言里都提供时间对象的支持，在MySQL里也有DATETIME类型。商业里的DAU、GMV、LTV也少不了时间限定和时间属性，因此数据分析时少不了对时间数据类型的处理与转换。<br>Python通过套件time、datetime、timeit处理时间类型数据，但面对一些情况时会不够灵活和易用，在时间序列生成和截断方面捉襟见肘，于是诞生了Arrow、Pendulum、Maya等库增强了Python的时间处理能力。本篇对4个标准库和6大第三方模块进行介绍，在面对需求时能拿到最趁手的工具。</p>
<p><img src="/2020/12/14/timeproc-pymodule-using/time-1209-1-overview-fishbonemap.PNG" alt="本文概览鱼骨图"></p>
<a id="more"></a>

<h2 id="模块概览"><a href="#模块概览" class="headerlink" title="模块概览"></a>模块概览</h2><p>在Python中进行时间类型数据处理能用到的模块有：</p>
<ul>
<li>time：Python内置时间库，通过时间戳或元组表示时间；</li>
<li>datetime：内置日期库，处理日期时间对象和属性；</li>
<li>dateutil：基于datetime库的实用拓展，增强了对时间间隔和时间序列的处理；</li>
<li>pd.Timestamp：pandas库用于时间处理的类；</li>
<li>Arrow：优秀的Python时间库，简化了时间类型数据的解析和输出；</li>
<li>Pendulum：可以和Arrow对标的时间处理库，pendulum意为钟摆；</li>
<li>Delorean：在dateutil基础上进一步拓展的时间库，以《回到未来》中的时间旅行车命名；</li>
<li>moment：灵感来源于Moment.js，目前相对原始；</li>
<li>Maya：和Arrow等库对标，增强了对时区的处理，有调用pendulum的部分功能；</li>
</ul>
<p>在深入这些库的使用之前，先补充一些先验知识：<br>epoch：时间基准点至特定时间的总秒数，一般用一个浮点数值记录，这个基准点在Unix及类Unix系统中是格林威治时间1970年01月01日00时0分0秒，因此也称为Unix时间戳(Timestamp)。因为地球是一个椭球体，当英国是中午时中国北京已经在吃晚饭了，不同经度地区的0点相对于格林威治的0点有一个时差，也就有时区(timezone)的区分，以UTC(世界协调时)作为基准，中国采用的东八区就可表示为UTC+8，对应北京时间减8个小时就是UTC时间。<br>基于以上需要考虑的问题，在时间类中，表示一个时间有两种基本选择：<br>一是用浮点数记录一个时间戳epoch，时间小于1970年则是负数，二是用元组或字典记录年月日时分秒时区等，在Python的time模块就是记录了epoch和一个元组叫struct_time，这两者之间可以互相转换。</p>
<h2 id="模块特性与实践"><a href="#模块特性与实践" class="headerlink" title="模块特性与实践"></a>模块特性与实践</h2><h3 id="time-amp-datetime"><a href="#time-amp-datetime" class="headerlink" title="time&amp;datetime"></a>time&amp;datetime</h3><p>time是Python内置的时间库，功能简约但实用，通常和同为内置库的datetime、pytz及calendar互相配合解决各类时间表示、计算、输出等需求。<br>time的常用方法有：</p>
<ul>
<li>time.time()：得到当前时间戳Timestamp，是一个浮点数；</li>
<li>time.localtime([secs])：将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准，相当于获取当前时间now()；</li>
<li>time.gmtime(ts)：时间戳转struct_time；struct_time是一个包含了9个元素的元组，对应着改时间对象的年月日、本年第几天等属性；</li>
<li>time.mktime(t)：struct_time转时间戳；</li>
<li>time.strftime(“%Y-%m-%d”,t)：struct_time转格式化字符串；</li>
<li>time.strptime(‘2020-12-7’,”%Y-%m-%d”)：字符串转struct_time；</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.time() <span class="comment">#type(time.time())==float</span></span><br><span class="line"><span class="comment">#Out[]:1607319973.764</span></span><br><span class="line">time.localtime()</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=12, tm_mday=7, tm_hour=13, tm_min=46, tm_sec=13, tm_wday=0, tm_yday=342, tm_isdst=0)</span></span><br><span class="line">st=time.gmtime(time.time())</span><br><span class="line">st.tm_year <span class="comment">#获取属性，st是元组，不能修改</span></span><br><span class="line"><span class="comment"># 2020</span></span><br></pre></td></tr></table></figure>

<p>基于time模块生成的时间对象t，如果是时间戳形式表示的，是不能直接得到t是在哪一年等属性的，需要先转struct_time形式，然后就可以写st.tm_year获取所在年。st是元组，不能修改，即不能用st.tm_year=2019来修改的st的实际值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t=time.strptime(<span class="string">&#x27;2020-12-7 13:52:15&#x27;</span>,<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=12,...)</span></span><br><span class="line">time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,t)</span><br><span class="line"><span class="comment"># 2020-12-7 13:52:15</span></span><br></pre></td></tr></table></figure>

<p>从文件中读取数据时常需要从字符串形式变成时间对象，就会用到str<strong>p</strong>time，是string parse time的简写，即从字符串数据类型中解析成时间类型。str<strong>f</strong>time是把时间类型格式化为字符串，是str<strong>p</strong>time的逆操作，f是format的缩写。<br>时间类型格式化有一套特定的占位符，下面介绍的符号在其他时间模块里也通用，因此常用的占位符还是需要心里有数才能灵活“组装”出自己需要的字符串效果的。下面表格列出了常用的时间格式化占位符，更全面的表可查阅<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/time.html">time模块文档</a>。</p>
<p><img src="/2020/12/14/timeproc-pymodule-using/time-1209-2-strftime-fmt.PNG" alt="常用时间格式化符号"></p>
<p>time模块常和datetime模块组合使用，time侧重在时间，datetime在日期方面方法更丰富，且datetime会和pytz及calendar配合处理时间对象。<br>在datetime里也有strftime和strptime，不过需要注意的是，两个库输入参数顺序的区别，datetime的strftime，格式化字符串在后，代码实例如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">dt=datetime.strptime(<span class="string">&#x27;2020-12-7 13:52:15&#x27;</span>,<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">datetime.strftime(dt,<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) <span class="comment">#</span></span><br><span class="line"><span class="comment"># 2020-12-7 13:52:15</span></span><br><span class="line">time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,t)</span><br><span class="line"><span class="comment"># datetime库内部也是调用time的striptime</span></span><br><span class="line"><span class="comment"># datetime.strftime -&gt; _wrap_strftime -&gt;_time.strftime</span></span><br></pre></td></tr></table></figure>

<p>在datetime中新建时间对象可以直接使用<code>datetime(y, m,d,tzinfo)</code>输入参数，用<code>datetime.now()</code>获得当前时间，通过<code>datetime.fromtimestamp(ts)</code>可以将时间戳ts转为时间对象，生成的datetime时间对象在获取属性时用到的语句类似<code>dt.year</code>，有year/month/day/hour/second/tzinfo等可以用。tzinfo是时区属性，datetime在时区相关处理时通常用到pytz。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line">sh=pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>) <span class="comment">#新建一个时区</span></span><br><span class="line">dt=datetime(<span class="number">2020</span>,<span class="number">12</span>,<span class="number">7</span>,hour=<span class="number">8</span>,tzinfo=sh)</span><br><span class="line">datetime.fromtimestamp(time.time())</span><br><span class="line"><span class="comment">#datetime.datetime(2020,12,8,16,59,42,797401)</span></span><br><span class="line">dt.year <span class="comment">#返回给定datetime对象的年份</span></span><br><span class="line"><span class="comment">#Out[]: 2020</span></span><br><span class="line"><span class="comment">#属性有.hour .minute .second .microsecond 等</span></span><br><span class="line">datetime.weekday() <span class="comment">#返回星期几，星期一为 0，星期天为 6</span></span><br><span class="line"><span class="comment">#方法还有 .isoweekday() .toordinal() 等</span></span><br><span class="line">datetime.combine(dt.date(),dt.time()) </span><br><span class="line"><span class="comment">#combine：将一个date对象和一个time对象组合成一个datetime对象</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timezone <span class="comment">#如果不使用pytz库</span></span><br><span class="line">d1=datetime(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">21</span>,tzinfo=timezone(timedelta(hours=<span class="number">8</span>)))</span><br><span class="line">tdt=dt-d1</span><br><span class="line"><span class="comment"># datetime.timedelta(days=16)</span></span><br><span class="line">dt+timedelta(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>两个datetime日期相减得到的是一个时间间隔对象(imedelta)，timedelta可以和数值进行乘法和整除运算，两个timedelta对象之间可以进行加减运算，但不能比较大小，datetime对象可以和timedelta对象进行加减得到新的datetime实现时间偏移。<br>datetime也会和内置的calendar库进行配合，顾名思义，calendar库主要用来处理和输出整年、整月的日历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(calendar.calendar(<span class="number">2020</span>)) <span class="comment">#打印2020年日历</span></span><br><span class="line"><span class="comment">#calendar.prcal(2020) #两个语句效果相同</span></span><br><span class="line">calendar.prmonth(<span class="number">2019</span>,<span class="number">2</span>) <span class="comment">#打印2019年2月的日历</span></span><br><span class="line">calendar.isleap(<span class="number">2020</span>) <span class="comment">#是否闰年</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">calendar.weekday(<span class="number">2020</span>,<span class="number">11</span>,<span class="number">20</span>) <span class="comment">#指定日期为星期几，</span></span><br><span class="line"><span class="comment">#4 代表星期五</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/14/timeproc-pymodule-using/time-1209-4-1-calendar.PNG" alt="日历库calendar使用"></p>
<p>这几个库其他的实用方法有：</p>
<ul>
<li>time.sleep(secs)：线程推迟指定的时间运行，单位为秒；</li>
<li>time.asctime([t]) ：把一个表示时间的元组或者struct_time表示为这种形式：’Sun Jun 20 23:21:05 1993’，如没有参数，将会将time.localtime()作为参数传入；</li>
<li>time.ctime([secs])：把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()为参数。它的作用相当于time.asctime(time.localtime(secs))；</li>
<li>calendar.leapdays(n,m)：年份n到m之间的闰年数量；</li>
</ul>
<h3 id="dateutil"><a href="#dateutil" class="headerlink" title="dateutil"></a>dateutil</h3><p>dateutil模块是基于datetime库的实用拓展，增强了对时间间隔和时间序列的处理，因此dateutil类型直接继承了datetime类型，<a target="_blank" rel="noopener" href="https://dateutil.readthedocs.io/en/stable/">dateutil库</a>生成的时间对象就是datetime。Anaconda下该库已经安装，模块里有parser、easter、relativedelta、rrule等实用类进行时间处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dateutil <span class="comment">#anaconda下已经安装，直接import</span></span><br><span class="line">dt=dateutil.parser.parse(<span class="string">&#x27;April 29 2020 14:20&#x27;</span>)</span><br><span class="line"><span class="comment">#可以从字符串解析，不需要手动写匹配的占位符。</span></span><br><span class="line">dt=dateutil.parser.parse(<span class="string">&#x27;April 29&#x27;</span>) <span class="comment">#会取当前年</span></span><br><span class="line"><span class="comment"># datetime.datetime(2020, 4, 29, 0, 0)</span></span><br><span class="line">dt=dateutil.parser.parse(<span class="string">&quot;Today is January 1, 2047 at 8:21:00AM&quot;</span>, fuzzy_with_tokens=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dateutil的parser类用于更方便地从字符串解析为datetime对象，<code>parser.parse(string)</code>可以从各种类型的字符串例如一句自然语言中解析出日期，但输入的参数string必须是字符串，输入时间戳不行（这个和下面提到的Arrow等库不同）。<br>因为解析为datetime类型的对象，所以可以使用datetime的各种方法和属性，例如需要知道是哪一年仍然使用<code>dt.year</code>获取。<br>一些datetime类的方法可以基于dt实例使用，要实现从时间戳转时间对象，就可以使用<code>dt.fromtimestamp(ts)</code>，获取当前时间，就可以使用<code>dt.now()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dt.fromtimestamp(dt.timestamp()) <span class="comment">#时间戳与时间对象互转</span></span><br><span class="line">dt.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="comment">#只能输入一个参数</span></span><br><span class="line"><span class="comment">#时间对象转字符串</span></span><br><span class="line">dateutil.easter.easter(<span class="number">2020</span>,method=<span class="number">3</span>) </span><br><span class="line"><span class="comment">#计算输入年份复活节的日期</span></span><br></pre></td></tr></table></figure>
<p>dateutil计算时间间隔的方法封装在relativedelta里，通过输入参数months等明确间隔的时间距离，tz用于处理时区。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dt+dateutil.relativedelta.relativedelta(months=<span class="number">1</span>, weeks=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#时间偏移</span></span><br><span class="line"><span class="comment"># datetime.datetime(2021, 1, 14, 14, 15, 39, 173204)</span></span><br><span class="line">relativedelta(datetime(<span class="number">2003</span>, <span class="number">10</span>, <span class="number">24</span>, <span class="number">10</span>, <span class="number">0</span>),dt) <span class="comment">#得到一个时间间隔</span></span><br><span class="line">relativedelta(NOW, johnbirthday) <span class="comment">#得到一个人的年龄</span></span><br><span class="line"><span class="comment">#下周五对应的时间</span></span><br><span class="line">dt+relativedelta(weekday=FR)</span><br></pre></td></tr></table></figure>

<p>rrule类用于生成和处理一个时间序列。rrule的主要参数有：</p>
<ul>
<li>freq：声明序列重复的周期；</li>
<li>count：生成多少个时间对象；</li>
<li>dtstart：开始的时间点；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(dateutil.rrule.rrule(freq=dateutil.rrule.MONTHLY, count=<span class="number">4</span>, dtstart=datetime(<span class="number">2020</span>, <span class="number">12</span>,<span class="number">7</span>)))</span><br><span class="line"><span class="comment"># [datetime.datetime(2020, 12, 7, 0, 0),datetime.datetime(2021, 1, 7, 0, 0),...]</span></span><br><span class="line"><span class="built_in">list</span>(dateutil.rrule.rrulestr(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    DTSTART:20201207T090000</span></span><br><span class="line"><span class="string">    RRULE:FREQ=DAILY;INTERVAL=10;COUNT=4</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>))</span><br><span class="line"><span class="comment">#效果同上，rrulestr是根据字符串规则生成时间序列</span></span><br></pre></td></tr></table></figure>
以上例子生成的是一个由4个时间对象组成的序列，开始时间是2020年12月7号，每月重复一条记录。rrule.rrulestr()是把字符串输入当参数。</li>
</ul>
<h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>实际在进行数据分析时，通常都会用到pandas库却不一定会导入datetime等库，而pandas模块也提供了Timestamp、Timedelta等类用于时间类型数据的处理转换。直接使用pd.Timestamp也更容易进行广播运算。</p>
<p>pandas的Timestamp对象用法和datetime库基本一致，各种<code>dt.year</code>属性都有，也有<code>dt.isleapyear</code>用于判断是否是闰年。pd.Timedelta对应datetime的timedelta，表示时间间隔。</p>
<p><img src="/2020/12/14/timeproc-pymodule-using/3-timestramp-03.PNG" alt="Timestamp常用方法"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;时间&#x27;</span>]=pd.to_datetime(df[<span class="string">&#x27;dt&#x27;</span>]) </span><br><span class="line">df[<span class="string">&#x27;years&#x27;</span>]=df[<span class="string">&#x27;时间&#x27;</span>].apply(<span class="keyword">lambda</span> x:x.year)</span><br><span class="line">sdf=df.loc[df[<span class="string">&#x27;years&#x27;</span>]==<span class="number">2018</span>]</span><br><span class="line">ddr=dd/(pd.Timestamp(<span class="string">&#x27;2018-12-31&#x27;</span>)-pd.Timestamp(<span class="string">&#x27;2018-1-1&#x27;</span>)).days </span><br><span class="line">df[<span class="string">&#x27;tfs&#x27;</span>]=df[<span class="string">&#x27;时间&#x27;</span>].apply(<span class="keyword">lambda</span> x:x.hour+x.minute/<span class="number">60</span>+x.second/<span class="number">3600</span>)</span><br></pre></td></tr></table></figure>

<p>前文《<a href="https://lynsdata.cn/2019/09/26/time-format-in-pandas.html">用pandas处理时间格式数据</a>》讲述了一个处理Excel文件中时间数据的案例。</p>
<h3 id="Arrow"><a href="#Arrow" class="headerlink" title="Arrow"></a>Arrow</h3><p>Arrow是一个优秀的Python时间处理库，现在其他有追求的第三方时间处理库都喜欢在文档里对标Arrow，足矣见Arrow的影响力。<a target="_blank" rel="noopener" href="https://arrow.readthedocs.io/en/stable/">Arrow</a>通过收束接口增强了其易用性，可以快速上手使用，get统筹各种输入的解析，replace负责各种时间要素的修改，format解决各类格式化输出的需求，range处理时间序列生成问题。<br>Arrow解析字符串或datetime对象得到的是一个自定义时间对象，通过dt.time、dt.datetime、dt.timestamp等将时间数据从Arrow内置对象转为time等库的时间对象，一些例子如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> arrow <span class="comment">#在Anaconda下已经安装</span></span><br><span class="line">arrow.get(<span class="string">&#x27;2020-12-08 17:31:20&#x27;</span>) </span><br><span class="line"><span class="comment">#Out[]: &lt;Arrow [2020-12-08T17:31:20+00:00]&gt;</span></span><br><span class="line">dt=arrow.get(<span class="number">1607334506</span>) <span class="comment">#get可输入Unix时间戳，也可输入datetime对象</span></span><br><span class="line">dt.datetime <span class="comment">#转为dateime类型</span></span><br><span class="line">dt.naive <span class="comment">#转为当地时区的datetime类型</span></span><br><span class="line">dt.floor(<span class="string">&#x27;hour&#x27;</span>) <span class="comment">#从小时处截断，小时之后的数清零</span></span><br><span class="line">d1.replace(hour=<span class="number">3</span>)</span><br><span class="line">d1.shift(weeks=+<span class="number">4</span>) <span class="comment">#当前时间4周后</span></span><br><span class="line">d1.to(<span class="string">&#x27;Asia/Shanghai&#x27;</span>) <span class="comment">#换时区</span></span><br><span class="line">dt.<span class="built_in">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">#输出格式化字符串</span></span><br><span class="line">arrow.Arrow.<span class="built_in">range</span>(<span class="string">&#x27;hour&#x27;</span>,arrow.now(),arrow.now().shift(hours=<span class="number">5</span>))</span><br><span class="line"><span class="comment">#arrow生成时间序列</span></span><br><span class="line">dt.humanize() <span class="comment">#dt的自然语言表示</span></span><br></pre></td></tr></table></figure>

<p>Arrow的具体用法可参考前文《<a href="https://lynsdata.cn/2020/12/09/timeproc-arrow-lynsns.html">Python处理时间数据的另一种选择，在标准库之外|Arrow使用笔记</a>》。</p>
<h3 id="Pendulum"><a href="#Pendulum" class="headerlink" title="Pendulum"></a>Pendulum</h3><p>Pendulum也是一款很优秀的Python时间处理模块，其内置数据类型拓展自datetime，与datetime有着很好的兼容性。Pendulum比dateutil功能更丰富，足矣和Arrow对标。Arrow的易用性体现在接口简洁，Pendulum的易用性表现在很多datetime的方法都兼容，而且<a target="_blank" rel="noopener" href="https://pendulum.eustace.io/">Pendulum</a>的文档页面也更美观漂亮。Pendulum[ˈpendʒələm]意为钟摆，是很好的时间意向。Pendulum通过其内置的DateTime对象实现和拓展datetime.datetime的功能，同时封装出Duration、Period及Timezones处理时间偏移、时区、时间序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pendulum</span><br><span class="line">dt=pendulum.now() <span class="comment">#获取本地时区的当前时间</span></span><br><span class="line"><span class="comment">#DateTime(2020,12,8,18,0,8,697484,tzinfo=Timezone(&#x27;Asia/Shanghai&#x27;))</span></span><br><span class="line">pendulum.tomorrow() <span class="comment">#明天的这个时候</span></span><br><span class="line">dt.year <span class="comment"># 2020</span></span><br><span class="line">dt.week_of_year <span class="comment">#dt所在周是本年第几周</span></span><br><span class="line">dt.age <span class="comment">#dt对应日期目前的年龄</span></span><br><span class="line">dt.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">d2=dt.<span class="built_in">set</span>(year=<span class="number">2019</span>) <span class="comment">#把年份变成2019</span></span><br><span class="line">dt.add(years=-<span class="number">1</span>) <span class="comment">#把时间变成1年前，注意是years不是year</span></span><br><span class="line">period = pendulum.period(dt, dt.add(days=<span class="number">8</span>))</span><br><span class="line"><span class="built_in">list</span>(period.<span class="built_in">range</span>(<span class="string">&#x27;days&#x27;</span>,<span class="number">2</span>)) <span class="comment">#时间序列</span></span><br></pre></td></tr></table></figure>

<p>其他的一些实用方法如下：</p>
<ul>
<li>pendulum.datetime(2020,5,7)：输入年月日等生成DateTime，对应着datetime.datetime()的写法;</li>
<li>pendulum.today()：获取当天时间， .tomorrow() .yesterday() 等可以用；</li>
<li>pendulum.local(args)：获取当地时间的对象，可以输入年月日等；</li>
<li>pendulum.parse(text)：从文本中解析出时间对象，有个类似的方法是pendulum.from_format(text,s)；</li>
<li>pendulum.from_timestamp(ts)：把时间戳ts转为时间对象；</li>
<li>dt.int_timestamp：把dt表示为整数的timestamp，对应的还有.float_timestamp；</li>
<li>pendulum.timezone(“Europe/Paris”)：生成一个时区对象；</li>
<li>d2.diff_for_humans(dt)：将时间间隔按自然语言输出；</li>
</ul>
<p>Pendulum的一些函数需要输入DateTime作为参数时，输入datetime对象也兼容，例如Period时期对象的start、end对象输入DateTime对象或datetime对象都可以，更详细的Pendulum特性可阅读《<a href="https://lynsdata.cn/2020/12/10/timeproc-pendulum-lynsns.html">挑战Arrow，需要怎样的实力？Pendulum使用笔记</a>》。</p>
<h3 id="Delorean"><a href="#Delorean" class="headerlink" title="Delorean"></a>Delorean</h3><p>dateutil库在datetime库基础上进行拓展，<a target="_blank" rel="noopener" href="https://delorean.readthedocs.io/en/latest/">Delorean</a>站在dateutil的肩膀上进一步增强了时间处理能力，其接口更偏向面向对象的写法，时间戳使用epoch定义，其时间对象和datetime对象兼容性也很高，并且内置时间对象可以直接和datetime.timedelta进行运算。<br>Delorean是《回到未来》中的主角的时间旅行车，作为一个以epoch表示时间的程序库挺契合的。<br>Delorean抽象了多个接口用于解析和转换其他格式数据为时间对象，解析字符串用parse、处理时间戳用epoch、输入的是datetime对象直接用Delorean()。获取对象的年月日等属性，需转datetime再使用datetime的接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> delorean <span class="keyword">import</span> Delorean</span><br><span class="line">dt=Delorean() <span class="comment">#获取当前时间，相当于now</span></span><br><span class="line">dt=delorean.parse(<span class="string">&#x27;2020/12/07&#x27;</span>)</span><br><span class="line">dt.datetime.year <span class="comment">#获取年份</span></span><br><span class="line">dt.replace(hour=<span class="number">8</span>) <span class="comment">#改时间</span></span><br><span class="line">dt.shift(<span class="string">&#x27;US/Eastern&#x27;</span>) <span class="comment">#改时区</span></span><br><span class="line">dt - timedelta(hours=<span class="number">2</span>) <span class="comment">#两小时之前</span></span><br><span class="line"><span class="built_in">list</span>(delorean.stops(freq=delorean.DAILY,count=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>Delorean修改时间要素是用replace，而改时区是使用的shift。除了用stops生成时间序列外，还有range_daily()、range_hourly()等快速方法生成每天或每小时的时间序列。Delorean和datetime的协作很方便，但接口不够简洁和成体系，获取属性还需要转为datetime，显得常用的功能却没有优先封装，与Arrow、Pendulum等库还有些差距，是一个值得了解的Python时间库，详细了解其用法可看前文《<a href="https://lynsdata.cn/2020/12/11/timeproc-delorean-lynsns.html">设定基准点去时间旅行|Delorean使用笔记</a>》。</p>
<h3 id="moment"><a href="#moment" class="headerlink" title="moment"></a>moment</h3><p>和Arrow类似，moment也是灵感来自Moment.js库。moment是一个在发展中的库，基本功能不缺，但也不是很完善，其文档<a target="_blank" rel="noopener" href="https://github.com/zachwill/moment"></a> 建议优先考虑Arrow及Pendulum库。<br>moment将数据的输入封装在moment.date里，在解析能力上，比Arrow的get更进一步，例如get传入tomorrow或者2 weeks ago是会报错的，这是arrow的get还不支持的写法，但moment.date可以解析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moment</span><br><span class="line">moment.date(<span class="string">&#x27;2020-12-07 14:20:10&#x27;</span>)</span><br><span class="line"><span class="comment">#&lt;Moment(2020-12-07T14:20:10)&gt;</span></span><br><span class="line">moment.date(<span class="string">&quot;2 weeks ago&quot;</span>)</span><br><span class="line">dt=moment.date(<span class="string">&quot;December 18, 2020&quot;</span>)</span><br><span class="line">moment.unix(<span class="number">1355875153626</span>)</span><br><span class="line">dt.year <span class="comment">#获取dt所在年份</span></span><br></pre></td></tr></table></figure>

<p>moment的时间对象也是自定义的对象，获取其属性使用<code>dt.year</code>的写法，和其他库一致，进行时间偏移用的add和subtract方法，同时也有replace的接口，而且写<code>dt.replace(day=2)</code>或者<code>dt.replace(days=2)</code>都没出问题。输出格式化的字符串使用format。通过<code>dt.datetime</code>转为dateime类型，而输出时间戳是用<code>dt.epoch()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dt=moment.now() <span class="comment">#还有utcnow()可以用</span></span><br><span class="line">dt.add(days=<span class="number">2</span>) <span class="comment">#.subtract()</span></span><br><span class="line">dt.replace(day=<span class="number">5</span>)</span><br><span class="line">dt.replace(days=<span class="number">5</span>)</span><br><span class="line">dt.<span class="built_in">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>)</span><br><span class="line">dt.datetime <span class="comment">#转datetime对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>moment目前的接口还是偏少，生成一个时间序列目前还不能实现。<br>使用moment时，一个小问题是用<code>pip install moment</code>可能会安装不上，需要通过<code>pip install moment --user</code> 去安装。</p>
<h3 id="Maya"><a href="#Maya" class="headerlink" title="Maya"></a>Maya</h3><p>Maya站在datetime、pendulum、snaptime等模块的肩膀上发展有一定特色的时间处理能力，<a target="_blank" rel="noopener" href="https://github.com/timofurrer/maya">Maya</a>自定义对象MayaDT也是通过epoch定义时间，能很好地避免一些时区问题。<br>Maya的时间创建能力上排名前列，有丰富的接口用于从各种数据中解析出时间对象，when和parse可以从一些自然语言字符串中解析出时间要素，这方面和moment不遑多让，例如写<code>maya.when(&#39;tomorrow&#39;)</code>和<code>.when(&#39;2 weeks ago&#39;)</code>等；当然从time/datetime对象、时间戳转Maya对象也是没有压力。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> maya</span><br><span class="line">maya.when(<span class="string">&#x27;tomorrow&#x27;</span>) <span class="comment">#明天的这个时候,直接从自然语言转MayaDT</span></span><br><span class="line">maya.parse(<span class="string">&#x27;2020-12-08T03:15&#x27;</span>) <span class="comment">#字符串转maya时间对象</span></span><br><span class="line">dt=maya.now() <span class="comment">#获取当前时间</span></span><br><span class="line">maya.MayaDT.from_datetime(datetime.now()) <span class="comment">#datetime对象转MayaDT</span></span><br><span class="line">maya.MayaDT.from_struct(time.gmtime()) </span><br><span class="line">maya.MayaDT(<span class="number">1606533154</span>) <span class="comment">#时间戳转Maya时间对象</span></span><br><span class="line">dt.from_iso8601(text) <span class="comment">#从符合ISO-8601标准的字符串中解析时间</span></span><br></pre></td></tr></table></figure>

<p>在输出和转换方面，有<code>dt.datetime()</code>方法将MayaDT对象转为datetime对象，也能直接通过<code>dt.year</code>获取MayaDT对象的属性，有<code>dt.iso8601()</code>输出满足ISO-8601标准的时间字符串，和from_iso8601相对应。几个优秀库都有的输出为自然语言功能在Maya里封装为<code>dt.slang_time()</code>，并且还有slang_date也能使用，slang是俚语的意思。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dt=maya.when(<span class="string">&#x27;2020, 12, 7&#x27;</span>)</span><br><span class="line">dt.slang_time()</span><br><span class="line"><span class="comment"># &#x27;8 hours ago&#x27;</span></span><br><span class="line">dt.add(days=<span class="number">10</span>).slang_time()</span><br><span class="line"><span class="comment"># &#x27;in 1 week&#x27;</span></span><br><span class="line"><span class="built_in">list</span>(maya.intervals(start=maya.now(),</span><br><span class="line">                    end=maya.now().add(days=<span class="number">1</span>),</span><br><span class="line">					interval=<span class="number">60</span>*<span class="number">60</span>))</span><br><span class="line"><span class="comment">#生成start到end的每小时间隔的时间值序列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Maya的很多方法调用了其他时间库，例如dt.year等属性用了datetime库、snap方法是调用了snaptime库、parse和add用到了Pendulum库，很多需求Maya没有自己去造轮子，同时也显得依赖项有些多，要深入了解Maya的用法可以翻看前文《<a href="https://lynsdata.cn/2020/12/13/timeproc-maya-lynsns.html">博采众长穿梭时空|Maya库使用笔记</a>》。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在数据处理和数据分析过程中，主要需要解决的数据需求有以下几点：</p>
<ul>
<li>生成时间对象，从字符串或者写赋值语句得到一个时间对象；从内置的time/datetime对象转更容易处理的时间对象，如数据列是从Excel读入的，去解析该列为时间对象；</li>
<li>对特定时间对象t，获取年月日、分钟等时间要素；</li>
<li>时间运算；<ul>
<li>时间间隔Timedelta，两个时间对象相减；</li>
<li>一个时间对象+一个差值后得到新的时间对象，例如获取t一周后的时间t2,</li>
</ul>
</li>
<li>时间对象转为特定格式的字符串；</li>
<li>时间序列的整体移动与抽样；</li>
<li>非结构日期处理，从自然语言中解析时间；</li>
</ul>
<p>各个库解决该需求的方式总结如下表。</p>
<p><img src="/2020/12/14/timeproc-pymodule-using/time-1209-14-pv.PNG" alt="各时间库接口对照表"><br><img src="/2020/12/14/timeproc-pymodule-using/time-1209-15-pv.PNG" alt="各时间库接口对照表补充"></p>
<p>这几个库的使用笔记ipynb文件及xmind文件可在公众号后台回复 <strong>time</strong> 获取。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a>
              <a href="/tags/time/" rel="tag"><i class="fa fa-tag"></i> time</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/13/timeproc-maya-lynsns.html" rel="prev" title="博采众长穿梭时空|Maya库使用笔记">
      <i class="fa fa-chevron-left"></i> 博采众长穿梭时空|Maya库使用笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/18/viz-d3-08-geojson-to-path.html" rel="next" title="D3的地理可视化模块">
      D3的地理可视化模块 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE"><span class="nav-number">1.</span> <span class="nav-text">时间数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%A6%82%E8%A7%88"><span class="nav-number">2.</span> <span class="nav-text">模块概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%89%B9%E6%80%A7%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.</span> <span class="nav-text">模块特性与实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time-amp-datetime"><span class="nav-number">3.1.</span> <span class="nav-text">time&amp;datetime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dateutil"><span class="nav-number">3.2.</span> <span class="nav-text">dateutil</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pandas"><span class="nav-number">3.3.</span> <span class="nav-text">pandas</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrow"><span class="nav-number">3.4.</span> <span class="nav-text">Arrow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pendulum"><span class="nav-number">3.5.</span> <span class="nav-text">Pendulum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delorean"><span class="nav-number">3.6.</span> <span class="nav-text">Delorean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#moment"><span class="nav-number">3.7.</span> <span class="nav-text">moment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maya"><span class="nav-number">3.8.</span> <span class="nav-text">Maya</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <a href="/">
    <img class="site-author-image" itemprop="image" alt="Lyndon"
      src="/images/lynsdata_avatar_49.png">
	</a>
  <p class="site-author-name" itemprop="name">Lyndon</p>
  <div class="site-description" itemprop="description">再勇敢一些</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/QLWeilcf" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;QLWeilcf" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/ea4b6b1d2c22" title="简书 → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;ea4b6b1d2c22" rel="noopener" target="_blank">简书</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lynsdata.cn/about/" title="公众号 → https:&#x2F;&#x2F;lynsdata.cn&#x2F;about&#x2F;">公众号</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lyndon</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
