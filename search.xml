<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编程实现一个有GUI的24点游戏</title>
    <url>/2020/03/20/24-points-game-coding-with-gui.html</url>
    <content><![CDATA[<p>24点是指从去除大小王后的52张扑克牌中任取 4 张，通过「加、减、乘、除」四则运算得到 24。是一个历史悠久的趣味小游戏。</p>
<p>《数据化管理》书中在测试数据敏感度章节提到一个细节“每天上下班的路上，盯着公交车外看到的汽车尾部牌照玩24点”，去练运算能力。根据排列组合知识可以算出：在1-10的数字中任选4个，有C(13,4)=715种情况（因为数字可以重复，如[5,5,5,5]，故不是直接从10个数中取4个的组合），从1-13中任选4个是C(16,4)=1820种情况，经过大佬门的枚举和推导，只考虑加减乘除，715种情况中，有566种有解，也就是79.16%的概率，而从1~13中选的1820种情况中是1362种情况下能算出24点，<a href="https://www.zhihu.com/question/22381727/answer/28821827">概率为74.83%
 </a>。</p>
<a id="more"></a>

<h3 id="给定序列算出24点"><a href="#给定序列算出24点" class="headerlink" title="给定序列算出24点"></a>给定序列算出24点</h3><p> 最近自己也在练24点的计算，需要随机生成4个数的组合，并且在需要有答案，看这题有哪些做法能算出24点，于是就打算用Python来实现生成4个随机数以及求给定序列的24点计算方法。可以选择在4个数之间的3个空格中枚举各种符号的情况，并且考虑括号，还有一种思路是“降数法”：4个数经过一步运算“降维”成3个数，再变成2个数，最后得到1个数，如果得到24说明这种组合成立。后一种需要的判断更少些，于是选择实现这一思路。</p>
<p>代码的大致流程如下：</p>
<ul>
<li><p>1)，对给定的4个数进行排列，得到A(4,4)=4!=24种排列，对这24种情况执行：</p>
</li>
<li><p>2)，前2个数实现第一步计算，合并成1个数，生成一个3个数的新序列；</p>
</li>
<li><p>3)，对这3个数做排列，同样前2个做四则运算，3个数合并成2个；</p>
</li>
<li><p>4)，最后两个数的排列为[a,b]和[b,a]，分别做加减乘除运算，变成一个数；</p>
</li>
<li><p>5)，如果最后生成的数是24，则记录这种计算方式；否则继续对下一个排列重复上面2~4。</p>
</li>
</ul>
<p><img src="/2020/03/20/24-points-game-coding-with-gui/%E9%99%8D%E6%95%B0%E6%B3%95%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B-1.PNG" alt="降数法计算过程"></p>
<p>得到一个序列的全排列的递归方法在之前的一个<a href="https://lynsdata.cn/anns-recursion.html">Ann全排列文章</a>有具体讲解，这里不赘述。</p>
<p>最后求24点计算方法的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#枚举列表lst的全排列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perm</span>(<span class="params">lst</span>):</span> <span class="comment">#input:list,[1,2,3,4]</span></span><br><span class="line">    n=<span class="built_in">len</span>(lst) </span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>: <span class="comment">#终止条件1</span></span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> [[lst[<span class="number">0</span>],lst[<span class="number">1</span>]],[lst[<span class="number">1</span>],lst[<span class="number">0</span>]]] <span class="comment">#终止条件2</span></span><br><span class="line">    kk=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nlst=lst[<span class="number">0</span>:i]+lst[i+<span class="number">1</span>:] <span class="comment">#除lst[i]外的元素</span></span><br><span class="line">        c=perm(nlst) <span class="comment">#对子序列进行递归</span></span><br><span class="line">        ss=[]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> c:</span><br><span class="line">            sw=[lst[i]]</span><br><span class="line">            sw.extend(j)</span><br><span class="line">            ss.append(sw)</span><br><span class="line">        kk.extend(ss) <span class="comment">#注意是extend不是append</span></span><br><span class="line">    <span class="keyword">return</span> kk</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal24</span>(<span class="params">a</span>):</span> <span class="comment">#24点计算</span></span><br><span class="line">    lst=[[i,<span class="string">&#x27;&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> a]</span><br><span class="line">    d1=perm(lst)  <span class="comment">#len==24</span></span><br><span class="line">    ev=[<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">    res=[]</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> d1: <span class="comment">#len(d)==4</span></span><br><span class="line">        <span class="keyword">for</span> e1 <span class="keyword">in</span> ev: <span class="comment">#24*4</span></span><br><span class="line">            <span class="keyword">if</span> e1==<span class="string">&#x27;/&#x27;</span> <span class="keyword">and</span> d[<span class="number">1</span>][<span class="number">0</span>]==<span class="number">0</span>: <span class="comment">#被除数为0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            r=<span class="string">&#x27;(&#123;0&#125;&#123;1&#125;&#123;2&#125;)&#x27;</span>.<span class="built_in">format</span>(d[<span class="number">0</span>][<span class="number">0</span>],e1,d[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            k1=[[<span class="built_in">eval</span>(r),r],d[<span class="number">2</span>],d[<span class="number">3</span>]]  <span class="comment">#k1=[eval(),d[2],d[3]]  k1.extend(d[2:])</span></span><br><span class="line">            d2=perm(k1) <span class="comment">#len(k1)==3  len(d2)==A(3,2)=6</span></span><br><span class="line">            <span class="keyword">for</span> d3 <span class="keyword">in</span> d2: <span class="comment">#len(d3)==3</span></span><br><span class="line">                <span class="keyword">for</span> e2 <span class="keyword">in</span> ev:</span><br><span class="line">                    <span class="keyword">if</span> e2==<span class="string">&#x27;/&#x27;</span> <span class="keyword">and</span> d3[<span class="number">1</span>][<span class="number">0</span>]==<span class="number">0</span>: <span class="comment">#被除数为0</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    r1=<span class="string">&#x27;&#123;0&#125;&#123;1&#125;&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(d3[<span class="number">0</span>][<span class="number">0</span>],e2,d3[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">                    y0=d3[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">if</span> d3[<span class="number">0</span>][<span class="number">1</span>]==<span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> d3[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">                    y1=d3[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> d3[<span class="number">1</span>][<span class="number">1</span>]==<span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> d3[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                    r2=<span class="string">&#x27;(&#123;0&#125;&#123;1&#125;&#123;2&#125;)&#x27;</span>.<span class="built_in">format</span>(y0,e2,y1)</span><br><span class="line">                    k2=[[<span class="built_in">eval</span>(r1),r2],d3[<span class="number">2</span>]] <span class="comment"># k2.extend(d3[2:]) </span></span><br><span class="line">                    d4=[[k2[<span class="number">0</span>],k2[<span class="number">1</span>]],[k2[<span class="number">1</span>],k2[<span class="number">0</span>]]]</span><br><span class="line">                    <span class="keyword">for</span> d5 <span class="keyword">in</span> d4:</span><br><span class="line">                        <span class="keyword">for</span> e3 <span class="keyword">in</span> ev:</span><br><span class="line">                            <span class="keyword">if</span> e3==<span class="string">&#x27;/&#x27;</span> <span class="keyword">and</span> d5[<span class="number">1</span>][<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">                                <span class="keyword">continue</span></span><br><span class="line">                            k3=<span class="built_in">eval</span>(<span class="string">&#x27;&#123;0&#125;&#123;1&#125;&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(d5[<span class="number">0</span>][<span class="number">0</span>],e3,d5[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">                            <span class="keyword">if</span> <span class="built_in">abs</span>(k3-<span class="number">24</span>)&lt;<span class="number">1e-6</span>:</span><br><span class="line">                                y0=d5[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">if</span> d5[<span class="number">0</span>][<span class="number">1</span>]==<span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> d5[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">                                y1=d5[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> d5[<span class="number">1</span>][<span class="number">1</span>]==<span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> d5[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                                rss=<span class="string">&#x27;(&#123;0&#125;&#123;1&#125;&#123;2&#125;)&#x27;</span>.<span class="built_in">format</span>(y0,e3,y1)</span><br><span class="line">                                k4=<span class="built_in">eval</span>(rss)</span><br><span class="line">                                <span class="keyword">if</span> <span class="built_in">abs</span>(k4-<span class="number">24</span>)&lt;<span class="number">1e-6</span>:</span><br><span class="line">                                    res.append(rss)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>(res)) <span class="comment">#初步去重</span></span><br></pre></td></tr></table></figure>

<p>我们拿几个实例来进行测试，输入结果如下：</p>
<p><img src="/2020/03/20/24-points-game-coding-with-gui/24-points-game-coding-with-gui%5Cdocal24-001.png" alt="几个实例的结果"></p>
<p>这种实现还是有些粗暴，没有很好地进行各种情况的去重，例如2×7+6+4和2×7+4+6是一种情况，对交换律和括号的去重实现可以参考<a href="https://zhuanlan.zhihu.com/p/33998387"> 如何不重复地枚举 24 点算式？（上） - 王赟 Maigo</a>。</p>
<h3 id="给24点小程序加上GUI"><a href="#给24点小程序加上GUI" class="headerlink" title="给24点小程序加上GUI"></a>给24点小程序加上GUI</h3><p>基于上面写的代码我们可以求任意4个数算24的所有情况，加上随机数生成平时就不缺24点的练习了，为了更好用，我们再加上GUI。为了兼容性，这里选择用内置的tkinter去实现GUI。</p>
<p>整体流程如下：</p>
<blockquote>
<p>导入tk库，创建主窗体-&gt;添加控件-&gt;处理交互-&gt;进入主事件循环</p>
</blockquote>
<p>交互的逻辑还是“降数法”的思路。</p>
<p>整体的界面如下图：</p>
<p><img src="/2020/03/20/24-points-game-coding-with-gui/24-points-game-coding-with-gui%5C%E7%9B%98%E9%9D%A2%E5%8F%8A%E4%BA%A4%E4%BA%92.PNG" alt="盘面及交互效果"></p>
<p>代码比较长，主要分为了生成各种按钮并设置坐标放在合适的位置，编写按钮按下的回调函数两个部分。部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root=tk.Tk()</span><br><span class="line">root.geometry(<span class="string">&#x27;280x320+400+100&#x27;</span>) <span class="comment">#大小和位置  widthxheight+x+y</span></span><br><span class="line">root.title(<span class="string">&#x27;cal 24&#x27;</span>)</span><br><span class="line">ctv=tk.StringVar(root,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">btnUs=tk.IntVar(root,<span class="number">0</span>)</span><br><span class="line">cur=[]</span><br><span class="line">result=[]</span><br><span class="line"><span class="keyword">if</span> result==[]:</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        cur.append(random.randint(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line">cur.append(<span class="string">&#x27;&#x27;</span>) <span class="comment">#对应各个按钮当前值</span></span><br><span class="line">scur=cur.copy() <span class="comment">#重来 用</span></span><br><span class="line">stk=[[<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>],<span class="string">&#x27;&#x27;</span>,[<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>],<span class="string">&#x27;&#x27;</span>]  <span class="comment">#操作符点击</span></span><br><span class="line">itv=tk.StringVar(root,<span class="string">&#x27;---&#x27;</span>)</span><br><span class="line">infov=tk.Label(root,textvariable=itv) <span class="comment">#显示信息用 </span></span><br><span class="line">infov.place(x=<span class="number">170</span>,y=<span class="number">5</span>,width=<span class="number">120</span>,height=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">stk[<span class="number">3</span>]=tk.Button(root,text=<span class="string">&#x27;&#x27;</span>).cget(<span class="string">&quot;background&quot;</span>)  <span class="comment">#默认按钮背景色 linux: #d9d9d9 win:SystemButtonFace</span></span><br><span class="line"><span class="comment">#回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">btnClick</span>(<span class="params">btn,bt=<span class="string">&#x27;&#x27;</span></span>):</span> <span class="comment">#btn:按下的按钮   bt:所按下按钮的标识，主要是数值键用</span></span><br><span class="line">    <span class="keyword">global</span> cur,stk,scur,result</span><br><span class="line">    ith=itv.get()</span><br><span class="line">    btnus=btnUs.get()</span><br><span class="line">    uop=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>)] <span class="comment">#[0,14]</span></span><br><span class="line">    opw=[<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> btn==<span class="string">&#x27;--&#x27;</span>:<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> btn <span class="keyword">in</span> uop: <span class="comment">#按的是数值类型的键</span></span><br><span class="line">        btnn=cur[bt-<span class="number">1</span>]</span><br><span class="line">        itv.<span class="built_in">set</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(btnn))</span><br><span class="line">        <span class="keyword">if</span> stk[<span class="number">0</span>][<span class="number">0</span>]==<span class="string">&#x27;&#x27;</span>: <span class="comment">#第一次按到数值键</span></span><br><span class="line">            stk[<span class="number">0</span>]=[btnn,bt]  <span class="comment">#or stk[0][0]=btnn;stk[0][1]=bt</span></span><br><span class="line">        <span class="keyword">elif</span> stk[<span class="number">1</span>]==<span class="string">&#x27;&#x27;</span>:<span class="comment">#没有按过符号键</span></span><br><span class="line">            <span class="keyword">if</span> stk[<span class="number">0</span>][<span class="number">0</span>] !=<span class="string">&#x27;&#x27;</span>:<span class="comment">#如两次点到数值键</span></span><br><span class="line">                stk[<span class="number">0</span>]=[btnn,bt]</span><br><span class="line">        <span class="keyword">elif</span> stk[<span class="number">1</span>]!=<span class="string">&#x27;&#x27;</span>: <span class="comment">#关键 完成了 a+b的输入</span></span><br><span class="line">            stk[<span class="number">2</span>]=[btnn,bt]</span><br><span class="line">            btnus+=<span class="number">1</span> <span class="comment">#在这个if条件下会合并两个按钮为一个，用掉一个按钮</span></span><br><span class="line">            vss=<span class="string">&#x27;&#123;0&#125;&#123;1&#125;&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(stk[<span class="number">0</span>][<span class="number">0</span>],stk[<span class="number">1</span>],stk[<span class="number">2</span>][<span class="number">0</span>]) <span class="comment">#a+b</span></span><br><span class="line"></span><br><span class="line">            cur[<span class="number">4</span>]=<span class="string">&#x27;(&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(vss)</span><br><span class="line">            <span class="comment">#暂时不好区分是cur[4],stk[1],stk[2][0] 还是 stk[0][0],stk[1],cur[4]</span></span><br><span class="line">            v=<span class="built_in">eval</span>(vss)</span><br><span class="line">            itv.<span class="built_in">set</span>(vss)</span><br><span class="line">            ccv=<span class="built_in">float</span>(<span class="string">&quot;%.3f&quot;</span> %v)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(v-ccv)&lt;<span class="number">1e-6</span>: setVBtnval(v,bt)</span><br><span class="line">            <span class="keyword">else</span>: setVBtnval(ccv,bt)</span><br><span class="line">            setVBtnCol(<span class="string">&#x27;#808080&#x27;</span>,stk[<span class="number">0</span>][<span class="number">1</span>]) <span class="comment">#“失效”一个按钮</span></span><br><span class="line">            setVBtnval(<span class="string">&#x27;--&#x27;</span>,stk[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            stk[<span class="number">0</span>]=[v,bt]</span><br><span class="line">            stk[<span class="number">1</span>]=<span class="string">&#x27;&#x27;</span> <span class="comment">#置空后两步操作，第一步更新为v的值，以方便实现a*b+c (a+b)*c</span></span><br><span class="line">            stk[<span class="number">2</span>]=[<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(v-<span class="number">24</span>)&lt;<span class="number">1e-6</span>:</span><br><span class="line">                <span class="keyword">if</span> btnus==<span class="number">3</span>: <span class="comment">#用掉三个，结果正确，到达endgame</span></span><br><span class="line">                    messagebox.showinfo(<span class="built_in">str</span>(scur[:<span class="number">4</span>]),<span class="string">&#x27;恭喜你计算正确！&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> btn <span class="keyword">in</span> opw: <span class="comment">#操作符，更新stk[1]</span></span><br><span class="line">        <span class="keyword">if</span> stk[<span class="number">0</span>][<span class="number">0</span>]==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            itv.<span class="built_in">set</span>(<span class="string">&#x27;操作符前没有数值&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">#无效  操作符前没有数值</span></span><br><span class="line">        <span class="keyword">elif</span> stk[<span class="number">1</span>] <span class="keyword">in</span> opw: <span class="comment">#覆盖上一步点的操作符</span></span><br><span class="line">            stk[<span class="number">1</span>]=btn</span><br><span class="line">        <span class="keyword">elif</span> stk[<span class="number">1</span>]==<span class="string">&#x27;&#x27;</span>: <span class="comment">#当前循环还没有输入过运算符</span></span><br><span class="line">            stk[<span class="number">1</span>]=btn</span><br><span class="line">    <span class="keyword">elif</span> btn==<span class="string">&#x27;C&#x27;</span>: <span class="comment">#清空操作重来</span></span><br><span class="line">        itv.<span class="built_in">set</span>(<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">        cur=scur.copy()</span><br><span class="line">        updateVBtn(cur) <span class="comment">#更新数值按钮上的值</span></span><br><span class="line">        resetVBtnColor(stk[<span class="number">3</span>]) <span class="comment">#重设按钮的背景色</span></span><br><span class="line">        stk=resetStk(stk) <span class="comment">#重设stk的值</span></span><br><span class="line">        btnus=<span class="number">0</span> <span class="comment">#按钮使用数重设为0</span></span><br><span class="line">    <span class="keyword">elif</span> btn==<span class="string">&#x27;Next&#x27;</span>: <span class="comment">#下一题</span></span><br><span class="line">        ch=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">150</span>):</span><br><span class="line">            ch=[]</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                ch.append(random.randint(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line">            result=cal24(ch)</span><br><span class="line">            <span class="keyword">if</span> result!=[]:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(result)&gt;<span class="number">9</span>: <span class="comment">#只取前10个答案</span></span><br><span class="line">                    result=result[:<span class="number">9</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> ch==[]:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                cur[i]=random.randint(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                cur[i]=ch[i]</span><br><span class="line">        cur[<span class="number">4</span>]=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        updateVBtn(cur)</span><br><span class="line">        resetVBtnColor(stk[<span class="number">3</span>])</span><br><span class="line">        stk=resetStk(stk)</span><br><span class="line">        scur=cur.copy()</span><br><span class="line">        itv.<span class="built_in">set</span>(<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">        btnus=<span class="number">0</span></span><br><span class="line">    btnUs.<span class="built_in">set</span>(btnus)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showAnswer</span>():</span> <span class="comment">#用消息框展示当前题目的答案</span></span><br><span class="line">    <span class="keyword">global</span> result,cur</span><br><span class="line">    rss=<span class="string">&#x27;\n&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> result])</span><br><span class="line">    messagebox.showinfo(<span class="built_in">str</span>(cur),rss)</span><br><span class="line"></span><br><span class="line">btn1=tk.Button(root,text=<span class="built_in">str</span>(cur[<span class="number">0</span>]),command=<span class="keyword">lambda</span> x=cur[<span class="number">0</span>]:btnClick(x,<span class="number">1</span>))</span><br><span class="line">btn1.place(x=<span class="number">0</span>,y=<span class="number">10</span>,width=<span class="number">90</span>,height=<span class="number">90</span>)</span><br><span class="line">btn2=tk.Button(root,text=<span class="built_in">str</span>(cur[<span class="number">1</span>]),command=<span class="keyword">lambda</span> x=cur[<span class="number">1</span>]:btnClick(x,<span class="number">2</span>))</span><br><span class="line">btn2.place(x=<span class="number">90</span>,y=<span class="number">10</span>,width=<span class="number">90</span>,height=<span class="number">90</span>)</span><br><span class="line">btn3=tk.Button(root,text=<span class="built_in">str</span>(cur[<span class="number">2</span>]),command=<span class="keyword">lambda</span> x=cur[<span class="number">2</span>]:btnClick(x,<span class="number">3</span>))</span><br><span class="line">btn3.place(x=<span class="number">0</span>,y=<span class="number">100</span>,width=<span class="number">90</span>,height=<span class="number">90</span>)</span><br><span class="line">btn4=tk.Button(root,text=<span class="built_in">str</span>(cur[<span class="number">3</span>]),command=<span class="keyword">lambda</span> x=cur[<span class="number">3</span>]:btnClick(x,<span class="number">4</span>))</span><br><span class="line">btn4.place(x=<span class="number">90</span>,y=<span class="number">100</span>,width=<span class="number">90</span>,height=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">btn5=tk.Button(root,text=<span class="string">&#x27;+&#x27;</span>,command=<span class="keyword">lambda</span> :btnClick(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">btn5.place(x=<span class="number">0</span>,y=<span class="number">200</span>,width=<span class="number">40</span>,height=<span class="number">20</span>)</span><br><span class="line"><span class="comment">#……</span></span><br><span class="line">btnClear=tk.Button(root,text=<span class="string">&#x27;重来&#x27;</span>,command=<span class="keyword">lambda</span> :btnClick(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">btnClear.place(x=<span class="number">0</span>,y=<span class="number">250</span>,width=<span class="number">60</span>,height=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># ……</span></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="/2020/03/20/24-points-game-coding-with-gui/24-points-game-coding-with-gui%5Cgifzip_7169.gif" alt="运行效果示例"></p>
<p>代码改一下可以变成命令行下的交互版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmdcal24</span>():</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    print(<span class="string">&#x27;欢迎使用命令行版24点训练器！\n## 说明&#x27;</span>)</span><br><span class="line">    q=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    cur,res=[],[]</span><br><span class="line">    <span class="keyword">while</span> q!=<span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> res==[]:</span><br><span class="line">            res,cur=getOne()</span><br><span class="line">            q=<span class="built_in">input</span>(<span class="string">&#x27;当前题目：&#123;0&#125;\n输入您的答案：&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(cur)))</span><br><span class="line">        <span class="keyword">elif</span> q==<span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            print(res)</span><br><span class="line">            res,cur=getOne()</span><br><span class="line">            q=<span class="built_in">input</span>(<span class="string">&#x27;当前题目：&#123;0&#125;\n输入您的答案：&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(cur)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                c=re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>).findall(q)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(c)!=<span class="number">4</span>:</span><br><span class="line">                    q=<span class="built_in">input</span>(<span class="string">&#x27;式子有问题，请检查后重新输入\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cr=[<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> cur]</span><br><span class="line">                    <span class="keyword">if</span> cmptlst(c,cr):</span><br><span class="line">                        c=<span class="built_in">eval</span>(q)</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">abs</span>(c-<span class="number">24</span>)&lt;<span class="number">1e-6</span>:</span><br><span class="line">                            print(<span class="string">&#x27;计算正确！&#x27;</span>)</span><br><span class="line">                            res,cur=getOne()</span><br><span class="line">                            q=<span class="built_in">input</span>(<span class="string">&#x27;当前题目：&#123;0&#125;\n输入您的答案：&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(cur)))</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                q=<span class="built_in">input</span>(<span class="string">&#x27;输入您的答案：&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(cur)))</span><br></pre></td></tr></table></figure>



<p><img src="/2020/03/20/24-points-game-coding-with-gui/24-points-game-coding-with-gui%5Crunincmd24cal.png" alt="命令行下运行"></p>
<p>换个环境，Ubuntu下的效果：</p>
<p><img src="/2020/03/20/24-points-game-coding-with-gui/24-points-game-coding-with-gui%5Cubuntu%E4%B8%8B%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C.png" alt="Ubuntu下运行效果"></p>
<p>最后GUI版的脚本可以导出为exe文件，其他人也可以方便的使用，通过<code>pyindatller</code>可以快速打包py脚本为exe文件。</p>
<p><img src="/2020/03/20/24-points-game-coding-with-gui/24-points-game-coding-with-gui%5Ccal24withgui-run1.PNG" alt="GUI运行效果"></p>
<p>Python打包为exe普遍文件会比较大（还是C#在这方面更有优势），我这边导出的结果是8.3MB，可以接受，用内置库的好处。写小型程序用tkinter是够用的。</p>
<p>公众号蛰虫始航后台回复 24点可下载文中代码。</p>
]]></content>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Ann全排列的枚举_递归实现(基于Python)</title>
    <url>/2020/09/26/anns-recursion.html</url>
    <content><![CDATA[<p>在写一些概率统计题的模拟时，经常需要把A(n,n)、C(n,m)的排列组合全部列出来，这里记录一下A(n,n)全排列全部遍历的实现。根据概率论中的排列组合知识知道<strong>A(n,n)=n!=n*(n-1)…*1</strong>；最终结果数是n的阶乘个，例如对于集合{1,2,3},有6种全排列。</p>
<a id="more"></a>

<p>要枚举出所有的排列结果，我们从n=1开始来看，集合{1}的全排列就是{1}，n=2时，有 {1,2} 和 {2,1} ，可以看成是2和1交换位置，然后对{1}进行全排列；对{1,2,3}，先2和1交换，得到{2}和{1,3}，对{1,3}采用和n=2的情况相同的处理，所以是可以递归的，于是采用递归来写，递归终止条件可以用n=1，也可以在n=2的时候就交换然后返回，归纳一下是<strong>将每个元素放到余下n-1个元素组成的队列最前方，对剩余元素进行递归全排列</strong>。用Python翻译这一思路：<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perm</span>(<span class="params">lst</span>):</span> <span class="comment">#input:list, 一个字符串格式的元素列表</span></span><br><span class="line">    n=<span class="built_in">len</span>(lst)</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> [lst[<span class="number">0</span>]+lst[<span class="number">1</span>],lst[<span class="number">1</span>]+lst[<span class="number">0</span>]] <span class="comment">#终止条件</span></span><br><span class="line">    kk=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nlst=lst[<span class="number">0</span>:i]+lst[i+<span class="number">1</span>:] <span class="comment">#除lst[i]外的元素</span></span><br><span class="line">        c=perm(nlst)</span><br><span class="line">        ss=[lst[i]+j <span class="keyword">for</span> j <span class="keyword">in</span> c]</span><br><span class="line">        kk.extend(ss) <span class="comment">#注意是extend不是append</span></span><br><span class="line">    <span class="keyword">return</span> kk</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>上面perm函数被递归调用了。输出格式是一个一维的数组。测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=perm([<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>])  <span class="comment">#perm(list(&#x27;123&#x27;))</span></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#[&#x27;123&#x27;, &#x27;132&#x27;, &#x27;213&#x27;, &#x27;231&#x27;, &#x27;312&#x27;, &#x27;321&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>看一篇文章发现leetcode上正好有一个全排列的题：<a href="https://leetcode.com/problems/permutations/">46. Permutations</a>，不过其输入是一个整数数值列表，输出二维数组：</p>
<blockquote>
<p>Given a collection of distinct integers, return all possible permutations.</p>
</blockquote>
<blockquote>
<p>Example:<br>Input: [1,2,3]<br>Output:[ [1,2,3], [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1] ]</p>
</blockquote>
<p>简单改一下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type lst: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> [[nums[<span class="number">0</span>],nums[<span class="number">1</span>]],[nums[<span class="number">1</span>],nums[<span class="number">0</span>]]]</span><br><span class="line">        kk=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nlst=nums[<span class="number">0</span>:i]+nums[i+<span class="number">1</span>:] </span><br><span class="line">            c=self.permute(nlst)</span><br><span class="line">            ss=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> c:</span><br><span class="line">                w=[nums[i]]</span><br><span class="line">                w.extend(j)</span><br><span class="line">                ss.append(w)</span><br><span class="line">            kk.extend(ss)</span><br><span class="line">        <span class="keyword">return</span> kk</span><br></pre></td></tr></table></figure>
<p>通过了测试：<br><img src="/2020/09/26/anns-recursion/anns-recursion%5Cleetcode_permutations_submission7.png" alt="leetcode_permutations"></p>
<p>另外发现Python的库itertools有很好用的轮子：permutations和product，列出全排列很方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations </span><br><span class="line">print(<span class="built_in">list</span>(permutations(<span class="string">&#x27;1234&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<p>而且permutations支持两个参数，例如<code>permutations(&#39;ABCD&#39;, 2)</code>得到<code>AB AC AD BA BC BD CA CB CD DA DB DC</code>，就是从ABCD中任选两个排列，A(4,2)。官方文档给出了<code>permutations(iterable[, r])</code>实现的等价代码，是很好的参考资料。<br>具体关于permutations和product，可以看官方文档：<a href="https://docs.python.org/2/library/itertools.html#itertools.permutations">https://docs.python.org/2/library/itertools.html#itertools.permutations</a>。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>配置定时任务自动运行脚本</title>
    <url>/2018/03/13/auto-run-crontab.html</url>
    <content><![CDATA[<p>目前我们写出的Python代码，无论是jupyter notebook里还是变成.py格式的脚本，都是需要手动点按钮运行，但是在有些需要自动化定期运行脚本的情况怎么办呢？《Python数据分析基础》用一个简短的章节介绍了实现方法。思路就是利用 Windows 系统或 macOS 系统中可定期运行脚本和其他可执行文件的程序。微软称这个程序为 Task Scheduler（任务计划程序） ；在 Unix 系统和 macOS 系统中，这样的程序称为 cron（定时任务） 。本笔记只实现Windows 10系统的自动化，macOS系统可以仔细去看原书，或者网上找其他教程。</p>
<a id="more"></a>


<p>和原书一样，这篇笔记也是用第5章 应用程序写的处理MySQL报错日志的代码。由于我之前是写在jupyter notebook里的，先导出代码到文本文件里，命名为autoParseMySQLlog.py。后面基本都是通过截图说明，文字会相对较少。<br>我觉得Win10还有更简便的方法去找，那就是用Cortana输入Task Scheduler去找。</p>
]]></content>
      <categories>
        <category>crontab</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>在Windows下配置点击就能运行Python程序的bat批处理脚本</title>
    <url>/2020/09/26/auto-run-with-shell.html</url>
    <content><![CDATA[<h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><p>在编写和调试程序时，一般我们会在集成编辑环境里写代码和运行，但如果程序比较完善需要快速运行，或者让同事在其他电脑上快速运行时，再打开IDE（Integrated Development Environment ,集成开发环境）运行就有些麻烦了，对方也不一定很熟练使用命令行进行运行，因此在Windows下要解决这个问题一般有两种思路：</p>
<ul>
<li>1，把程序编译为exe文件，就是一个小软件，和QQ等软件的运行方式基本无差别，通过鼠标点击运行；</li>
<li>2，另外的做法是编写批处理文件，点击批处理文件就会按顺序执行命令行(在其他电脑运行是需要保证对方正确安装了编程/编译环境，例如是运行Python程序需要安装好Python、Java程序需要安装好JDK并配置好环境变量)。</li>
</ul>
<p>Windows下的批处理文件后缀是.bat；点击该文件就可以执行。</p>
<a id="more"></a>

<blockquote>
<p><a href="https://baike.baidu.com/item/.bat">.bat</a>文件是可执行文件，由一系列命令构成，其中可以包含对其他程序的调用。</p>
</blockquote>
<p>下面具体说明通过bat批处理文件实现点击执行Python代码。</p>
<h3 id="编写Python程序"><a href="#编写Python程序" class="headerlink" title="编写Python程序"></a>编写Python程序</h3><p>如果本身程序比较完备了，这步跳过，下面新建一个超经典的hello world作为例子，选定一个文件夹然后新建一个文本文件，写入<code>print(&quot;hello world&quot;)</code>。保存文件名为hellopy，把文件后缀从.txt改为.py</p>
<h3 id="编写批处理脚本"><a href="#编写批处理脚本" class="headerlink" title="编写批处理脚本"></a>编写批处理脚本</h3><p>同样新建文本文件，输入<code>python hellopy.py</code>。保存为helloshell，后缀是.bat。<br>然后点击helloshell.bat就可以看到黑色的命令行窗口一闪而过，这是因为运行后cmd会自动关闭，因此为了看效果可以考虑用time.sleep(10)或选择运行程序后新建一个文件以显示程序正确运行了，以采用sleep的方案为例，把hellopy.py中的代码改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>) </span><br></pre></td></tr></table></figure>
<p>time.sleep(5) 表示程序运行到这一行会休眠5秒。</p>
<p>完成上述步骤后有两个文件如图：<br><img src="/2020/09/26/auto-run-with-shell/run-bat-helloshell-1.png" alt="需要运行的Python程序和批处理文件"><br>点击运行：<br><img src="/2020/09/26/auto-run-with-shell/run-bat-helloshell-2.png" alt="bat文件运行后的效果"></p>
<h3 id="点击运行导出的程序"><a href="#点击运行导出的程序" class="headerlink" title="点击运行导出的程序"></a>点击运行导出的程序</h3><p>以上步骤已经实现了基础需求，继续让例子更有针对性，在数据科学实践中，大家喜欢用Jupyter notebook进行运行和调试，但是有些常规需求我们不想再打开notebook一个个cell点击运行，想之间点击一下就自动化处理excel，这个需求就改一下bat文件就好，首先把jupyter notebook中能够正常运行的程序导出为py文件，在工具栏的<em>File-&gt;Download As-&gt;Python(.py)</em> 下，例如以下代码，读取一个Excel，对Excel进行处理后把数据框(DataFrame)的数据保存到一个Excel里。</p>
<p><img src="/2020/09/26/auto-run-with-shell/run-bat-helloshell-3.png" alt="jupyter notebook 程序例子"></p>
<p>在*File-&gt;Download As-&gt;Python(.py)*中导出Python文件using2019fords.py，然后把bat文件中的内容更新为<code>python using2019fords.py</code>。点击运行就可以。</p>
<h3 id="把bat文件放桌面"><a href="#把bat文件放桌面" class="headerlink" title="把bat文件放桌面"></a>把bat文件放桌面</h3><p>把bat移到桌面，运行更方便，程序和数据仍然在特定文件夹下，这时候可以直接写<code>python d:/文件夹路径/python文件名.py</code>，保存后运行就可以。<br><img src="/2020/09/26/auto-run-with-shell/run-bat-helloshell-4.png" alt="在桌面运行bat文件写法1"><br>另外就是按照cmd的步骤写，先定位到目标文件夹下，然后是<code>python 文件名.py</code>。<br><img src="/2020/09/26/auto-run-with-shell/run-bat-helloshell-5.png" alt="在桌面运行bat文件写法2"></p>
<h3 id="运行bat中传参数"><a href="#运行bat中传参数" class="headerlink" title="运行bat中传参数"></a>运行bat中传参数</h3><p>一般比较推荐把参数写入Python程序里，但也可以在批处理文件中传参数。bat中的语法是<code>python 文件名.py 参数1 参数2 </code>。</p>
<p>对应的Python文件中接受参数的代码为（using2019fords.py仍为jupyter notebook中导出的文件）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># In[1]:</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># In[2]:</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(<span class="string">&quot;当前运行脚本：&quot;</span>, sys.argv[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&quot;运行时间：&quot;</span>,time.localtime(time.time())) <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(sys.argv)): <span class="comment">#有哪些参数</span></span><br><span class="line">    print(<span class="string">&quot;参数&#123;0&#125;为：&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(i, sys.argv[i])) <span class="comment">#对参数进行处理</span></span><br><span class="line"></span><br><span class="line">wp=<span class="string">r&quot;J:\LinuxLearn\cixinliu\clickToRunBat&quot;</span></span><br><span class="line">adf=pd.read_excel(wp+<span class="string">&quot;/hellodata.xlsx&quot;</span>)</span><br><span class="line"><span class="comment"># In[7]:</span></span><br><span class="line">adf.head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># In[ ]:</span></span><br><span class="line"><span class="comment">#对读入的表进行逻辑处理</span></span><br><span class="line"><span class="comment"># In[4]:</span></span><br><span class="line">adf[<span class="string">&#x27;D&#x27;</span>]=adf[<span class="string">&quot;C&quot;</span>].apply(<span class="keyword">lambda</span> x:x*<span class="number">2</span>)</span><br><span class="line"><span class="comment"># In[6]:</span></span><br><span class="line">adf.to_excel(wp+<span class="string">&quot;/out_hellodata.xlsx&quot;</span>)<span class="comment">#输出</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>) </span><br></pre></td></tr></table></figure>
<p>运行效果如下：<br><img src="/2020/09/26/auto-run-with-shell/run-bat-helloshell-6.png" alt="bat中传参例子"></p>
<p>另外可能会遇到的需求是代码比较固定了，需要每天定时运行程序读取文件更新数据、发邮件等，定时运行的做法可以参考<a href="https://www.jianshu.com/p/ea5cd671b662">定时运行Python程序</a>。</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>用Linux的同学大部分都习惯于直接写命令行了，语法和Windows下的一致，首先定位到Python程序所在的目录下，然后用<code>python maincode.py</code>运行。<br>在Linux和Mac下的批处理文件文件后缀是.sh 。下面是一个运行的具体例子，Python程序仍然用前面说的<em>hellopy.py</em>。<br><img src="/2020/09/26/auto-run-with-shell/run-bat-helloshell-7.png" alt="Ubuntu下运行sh文件例子"></p>
]]></content>
      <categories>
        <category>crontab</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>GDI下用双缓冲实现橡皮筋技术C-sharp</title>
    <url>/2017/11/18/csharp-rubberin-gdi-plus.html</url>
    <content><![CDATA[<p><strong>橡皮筋</strong>效果在图形系统中是很常见也很实用的功能。<br>在唐荣锡的《计算机图形学教程》中介绍为：“所谓橡皮筋技术就是在起点确定后，光标移出去定终点时，在屏幕上始终显示一条连结起点和光标中心的的直线，这条直线随着光标中心位置的变动而变动。</p>
<a id="more"></a>

<p>可以知道，一个实现过程如下：</p>
<ol>
<li>按下鼠标左键：记录该点坐标。</li>
<li>移动鼠标：画出上一个端点到鼠标所在点的直线，并删除或者覆盖掉上一条直线。</li>
<li>再次点击左键时，又选择一个点，相当于回到第一步</li>
</ol>
<p>用双缓冲技术实现的效果是比较好的，而用自动撤销线即：<br>ControlPaint.DrawReversibleLine(Point start,Point end, Color BackColor)<br>闪烁比较严重。<br><img src="/2017/11/18/csharp-rubberin-gdi-plus/rubberin-gdi-1.jpg" alt="橡皮筋技术画多边形.jpg"></p>
<p>下面给出C#中用双缓冲实现橡皮筋的代码，代码中注释还是相对详细的。该代码在VS2017下运行良好。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Drawing.Drawing2D;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="comment">/*用双缓冲技术实现GDI+下的橡皮筋效果</span></span><br><span class="line"><span class="comment"> *控件：rubberInGDIplus--主窗体；intimePoiLbl--实时坐标展示</span></span><br><span class="line"><span class="comment"> * 左键选点，中键删除最后一个选择的点；右键完成多边形选择；Del键可删除所有点；</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">rubberInGDIplus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">rubberEffectForm</span> : <span class="title">Form</span> &#123;</span><br><span class="line">        Pen rubPen = <span class="keyword">new</span> Pen(Color.SpringGreen, <span class="number">2</span>);<span class="comment">//橡皮筋效果用笔；rubber pen</span></span><br><span class="line">        Point readPoi; <span class="comment">//intime point</span></span><br><span class="line">        <span class="built_in">bool</span> useRubber = <span class="literal">true</span>;</span><br><span class="line">        Graphics gp,gh;</span><br><span class="line">        <span class="keyword">private</span> Bitmap bitmap = <span class="literal">null</span>;<span class="comment">//虽然可以不用怎么多的Bitmap和 Graphics</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Point</span>&gt; poilst</span> = <span class="keyword">new</span> List&lt;Point&gt;(); <span class="comment">//多边形端点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">rubberEffectForm</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            <span class="keyword">this</span>.Paint += <span class="keyword">new</span> PaintEventHandler(<span class="keyword">this</span>.rubberEffectForm_Paint); <span class="comment">//初始化载入的像素方格</span></span><br><span class="line">            <span class="keyword">this</span>.MouseClick += <span class="keyword">new</span> MouseEventHandler(<span class="keyword">this</span>.rubberEffectForm_Click); <span class="comment">//监听点击事件</span></span><br><span class="line">            <span class="keyword">this</span>.MouseMove += <span class="keyword">new</span> MouseEventHandler(<span class="keyword">this</span>.rubberEffectForm_MouseMove); <span class="comment">//监听鼠标移动事件 </span></span><br><span class="line">            <span class="keyword">this</span>.KeyUp += <span class="keyword">new</span> KeyEventHandler(<span class="keyword">this</span>.rubberEffectForm_KeyUp);<span class="comment">//键盘按键事件</span></span><br><span class="line">            <span class="comment">//激活双缓冲技术</span></span><br><span class="line">            SetStyle(ControlStyles.UserPaint, <span class="literal">true</span>);</span><br><span class="line">            SetStyle(ControlStyles.AllPaintingInWmPaint, <span class="literal">true</span>);</span><br><span class="line">            SetStyle(ControlStyles.DoubleBuffer, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rubberEffectForm_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rubberEffectForm_Paint</span>(<span class="params"><span class="built_in">object</span> sender, PaintEventArgs e</span>)</span> &#123;</span><br><span class="line">            gh = e.Graphics;</span><br><span class="line">            bitmap = <span class="keyword">new</span> Bitmap(ClientSize.Width, ClientSize.Height);</span><br><span class="line"></span><br><span class="line">            gp = Graphics.FromImage(bitmap);</span><br><span class="line">            gp.Clear(<span class="keyword">this</span>.BackColor);</span><br><span class="line">            gp.SmoothingMode = SmoothingMode.AntiAlias;<span class="comment">//设置抗锯齿平滑模式</span></span><br><span class="line">            <span class="keyword">if</span> (useRubber &amp;&amp; readPoi != <span class="literal">null</span>) &#123;<span class="comment">//橡皮筋在使用中</span></span><br><span class="line">                <span class="built_in">int</span> plct = poilst.Count;</span><br><span class="line">                <span class="keyword">if</span> (plct == <span class="number">0</span>) &#123;<span class="comment">//还没有点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plct == <span class="number">1</span>) &#123;<span class="comment">//只存了一个点</span></span><br><span class="line">                    gp.DrawLine(rubPen, poilst[<span class="number">0</span>], readPoi);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//两点及以上</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; plct; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == plct - <span class="number">1</span>) &#123;</span><br><span class="line">                            gp.DrawLine(rubPen, poilst[<span class="number">0</span>], readPoi);</span><br><span class="line">                            gp.DrawLine(rubPen, poilst[i], readPoi);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            gp.DrawLine(rubPen, poilst[i], poilst[i + <span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (useRubber == <span class="literal">false</span> &amp;&amp; readPoi != <span class="literal">null</span>) &#123;<span class="comment">//按下中键后</span></span><br><span class="line">                <span class="built_in">int</span> plct = poilst.Count;</span><br><span class="line">                <span class="keyword">if</span> (plct == <span class="number">0</span> | plct == <span class="number">1</span>) &#123;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//两点及以上</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; plct; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == plct - <span class="number">1</span>) &#123;</span><br><span class="line">                            gp.DrawLine(rubPen, poilst[<span class="number">0</span>], poilst[i]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            gp.DrawLine(rubPen, poilst[i], poilst[i + <span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            gh.DrawImage(bitmap, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//display</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rubberEffectForm_Click</span>(<span class="params"><span class="built_in">object</span> sender, MouseEventArgs e</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e.Button == MouseButtons.Left) &#123;<span class="comment">//鼠标左击</span></span><br><span class="line">                useRubber = <span class="literal">true</span>;</span><br><span class="line">                Point readPoint = <span class="keyword">this</span>.PointToClient(Control.MousePosition);<span class="comment">//基于工作区的坐标</span></span><br><span class="line">                readPoi = readPoint;</span><br><span class="line">                intimePoiLbl.Text = readPoint.ToString();</span><br><span class="line">                <span class="comment">//drawVertex(gp, readPoint); //画端点（顶点） 由于橡皮筋的覆盖，端点看不出来</span></span><br><span class="line">                poilst.Add(readPoint);<span class="comment">//加点到list&lt;point&gt;里</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.Button == MouseButtons.Right) &#123;  <span class="comment">//右键</span></span><br><span class="line">                useRubber = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.Refresh();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//drawRim();//画边框</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.Button == MouseButtons.Middle) &#123;  <span class="comment">//中键</span></span><br><span class="line">                <span class="built_in">int</span> plast = poilst.Count - <span class="number">1</span>;</span><br><span class="line">                poilst.RemoveAt(plast);</span><br><span class="line">                useRubber = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.Refresh();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rubberEffectForm_MouseMove</span>(<span class="params"><span class="built_in">object</span> sender, MouseEventArgs e</span>)</span> &#123;</span><br><span class="line">            readPoi = <span class="keyword">this</span>.PointToClient(Control.MousePosition);<span class="comment">//基于工作区的坐标</span></span><br><span class="line">            Graphics gw = <span class="keyword">this</span>.CreateGraphics();</span><br><span class="line">            <span class="keyword">if</span> (useRubber) &#123; <span class="comment">//在橡皮筋模式内</span></span><br><span class="line">                gw.Clear(BackColor);</span><br><span class="line">                <span class="built_in">int</span> plct = poilst.Count;</span><br><span class="line">                <span class="keyword">if</span> (plct == <span class="number">0</span>) &#123;<span class="comment">// ==0： pass</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plct == <span class="number">1</span>) &#123;</span><br><span class="line">                    gw.DrawLine(rubPen, poilst[<span class="number">0</span>], readPoi);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//两点及以上</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; plct; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == plct - <span class="number">1</span>) &#123;<span class="comment">//画到最后一点了</span></span><br><span class="line">                            gw.DrawLine(rubPen, poilst[i], readPoi);</span><br><span class="line">                            gw.DrawLine(rubPen, poilst[<span class="number">0</span>], readPoi);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            gw.DrawLine(rubPen, poilst[i], poilst[i + <span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            intimePoiLbl.Text = readPoi.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rubberEffectForm_KeyUp</span>(<span class="params"><span class="built_in">object</span> sender, KeyEventArgs e</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.KeyCode == Keys.Delete) &#123;</span><br><span class="line">                poilst.Clear(); <span class="comment">//画的点也要清除</span></span><br><span class="line">                <span class="keyword">this</span>.Refresh();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.KeyCode == Keys.Back | e.KeyCode == Keys.Escape) &#123;</span><br><span class="line">                <span class="built_in">int</span> plast = poilst.Count - <span class="number">1</span>;</span><br><span class="line">                poilst.RemoveAt(plast);</span><br><span class="line">                useRubber = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.Refresh();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> 可用可不用的函数</span></span><br><span class="line">        <span class="comment">//画端点（顶点）</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawVertex</span>(<span class="params">Graphics g, Point poi</span>)</span> &#123;</span><br><span class="line">            Size sz = <span class="keyword">new</span> Size(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">            g.FillEllipse(Brushes.Red, <span class="keyword">new</span> Rectangle(poi, sz));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawRim</span>(<span class="params"></span>)</span> &#123;<span class="comment">//画边框</span></span><br><span class="line">            <span class="keyword">if</span> (poilst.Count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            Point[] poi = <span class="keyword">new</span> Point[poilst.Count];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; poilst.Count; i++) &#123;</span><br><span class="line">                poi[i] = poilst[i];</span><br><span class="line">            &#125;</span><br><span class="line">            gp.DrawPolygon(<span class="keyword">new</span> Pen(Color.Blue, <span class="number">2</span>), poi);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以设置鼠标指针的形状，在窗体属性的Cursor中，由Default变为Cross，这样就像<strong>ArcGIS</strong>或者CorelDRAW的效果了。<br><img src="/2017/11/18/csharp-rubberin-gdi-plus/rubberin-gdi-2.jpg" alt="设置Cursor.jpg"></p>
<p>完整工程以及更新文件可以参见我的<a href="https://github.com/QLWeilcf/pixelCGframewk/tree/master/rubberInGDIplus">GitHub-rubberInGDIplus</a></p>
<p>我觉得它具有的功能是：能够很好地作为图形学以及矢量多边形小软件的框架</p>
<p>具体的应用项目可以看我的扫描线填充多边形的代码。</p>
<ul>
<li><strong>scanLineToFillPolygon</strong>:<a href="https://github.com/QLWeilcf/pixelCGframewk/blob/master/scanLineToFillPolygon/scanLineToFillPolygonsReadme.md">GitHub</a></li>
</ul>
<p><img src="/2017/11/18/csharp-rubberin-gdi-plus/rubberin-gdi-3.jpg" alt="完成效果-五角星.jpg"></p>
]]></content>
      <tags>
        <tag>c-sharp</tag>
      </tags>
  </entry>
  <entry>
    <title>根据书名列表爬取豆瓣读书页面</title>
    <url>/2019/02/25/douban_booklist_spider.html</url>
    <content><![CDATA[<p>平时看到的豆瓣爬虫基本都是爬豆瓣top100电影、某电影热评、top100图书、热门图书等，最近遇到的一个需求是<strong>根据一堆书名的列表（或者书名Excel文件）爬取对应的书目信息</strong>，也就是豆瓣图书页面上的出版社、出版时间、ISBN、定价、评分、评分人数等信息，再整合到pandas里进行处理，最后可以进行数据分析。</p>
<h2 id="豆瓣读书爬虫需求"><a href="#豆瓣读书爬虫需求" class="headerlink" title="豆瓣读书爬虫需求"></a>豆瓣读书爬虫需求</h2><a id="more"></a>

<p>最近整理书目的时候需要根据几百本书的书名整理出对应的出版社、出版时间、ISBN、评分等属性，书单Excel如下图1中的表。批量处理肯定是用爬虫啦，查了一下没有发现相似的文章，并且自己操作时也遇到了比较有趣的问题，于是把自己的操作思路和过程整理成本文。</p>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE1_%E4%B9%A6%E5%8D%95%E6%95%B0%E6%8D%AE%E9%83%A8%E5%88%86%E6%88%AA%E5%9B%BE.png" alt="书单数据部分截图"></p>
<h2 id="爬取过程"><a href="#爬取过程" class="headerlink" title="爬取过程"></a>爬取过程</h2><p>首先分析豆瓣图书首页：book.douban.com，直接搜索书名时可以看到搜索参数是写在url上的，于是想着直接用<code>https://book.douban.com/subject_search?search_text=&#123;0&#125;&amp;cat=1001&#39;.format(&#39;书名&#39;) </code>，直接改search_text参数，在这个页面按F12调出控制台，失望的是这个url返回的html是不含数据的，如图2。关键是找了一段时间还是没找到异步返回的数据json（如果有人找到了豆瓣subject_search?search_text={0}&amp;cat=1001这类页面的书籍数据的位置欢迎告诉我呀），这时候考虑用Selenium或者查其他接口。</p>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE2_%E5%9F%BA%E4%BA%8E%E6%90%9C%E7%B4%A2url%E7%9A%84html%E6%88%AA%E5%9B%BE.png" alt="基于搜索url的html截图"><br>注意到豆瓣图书的搜索页面有一个搜索提示，于是在控制台查Network发现搜索提示返回的直接是一个json，例如查“未来简史”，结果如下：</p>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE3_%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2%E6%90%9C%E7%B4%A2%E6%8F%90%E7%A4%BA.png" alt="未来简史搜索提示"><br>返回json可以用的属性有：title：书名、url：对应书的豆瓣页面、pic：书封面图资源位置等。如果上面的输入咱们只有书名，就根据书名和返回的json对应，如果有作者、出版年份等属性，就可以更好的核对是否是我们要找的书，为了简化，下面只用了返回json数据的第1条。<br>根据返回的url就可以从这个url去定位我们需要爬的信息。走通了就可以正式写代码了，以下代码采用jupyter notebook的组织方式，也就是切分得比较细。先引入所需库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br></pre></td></tr></table></figure>
<p>读取书名Excel数据，只用了”书名”列，先不考虑其他列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bsdf=pd.read_excel(<span class="string">&#x27;booklistfortest.xlsx&#x27;</span>) </span><br><span class="line">blst=<span class="built_in">list</span>(bsdf[<span class="string">&#x27;书名&#x27;</span>])  <span class="comment">#书名列表</span></span><br><span class="line"><span class="comment">#bsdf.head(3)</span></span><br></pre></td></tr></table></figure>
<p><strong>对书名列表进行循环，得到的属性用字典装着，每本书的属性是一个字典，用列表装各个字典</strong>。通过<code>requests.get(&#39;https://book.douban.com/j/subject_suggest?q=&#123;0&#125;&#39;.format(bn))</code>获取搜索建议返回的json数据，其中bn是书名字符串。<br>爬虫的一般解析是用BeautifulSoup或xpath，我更喜欢用xpath，因此下面的代码主要基于xpath解析文本。<br>以评分为例，鼠标点击评分部分，然后按Ctrl+Shift+I，或者右键点击检查元素，反正就是定位到评分对应的HTML上，定位到评分的代码部分后，右键，选择<em>Copy-&gt;Copy XPath</em> ，例如对于评分来说有：<code>//*[@id=&quot;interest_sectl&quot;]/div/div[2]/strong</code> 。<br><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE4_%E5%A4%8D%E5%88%B6%E8%AF%84%E5%88%86%E7%9A%84xpath.PNG" alt="复制评分的xpath"></p>
<p>通过<code>con.xpath(&#39;//*[@id=&quot;interest_sectl&quot;]/div/div[2]/strong/text()&#39;)</code>就可以得到评分数据，返回的是列表，一般就是第0个值。同样，其他地方也是这样，而作者、出版社那几个属性是结构比较散的，需要特殊处理。</p>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE5_%E7%BD%91%E9%A1%B5%E4%B8%8A%E8%87%AA%E7%94%B1%E5%BA%A6%E8%BE%83%E5%A4%A7%E7%9A%84%E4%B9%A6%E7%9B%AE%E4%BF%A1%E6%81%AF%E9%83%A8%E5%88%86.png" alt="自由度较大的书目信息部分"></p>
<p>通过<code>//*[@id=&quot;info&quot;]/span[2] </code>可以确定 出版社 这个属性，但是属性的值，具体是哪个出版社不能确定，这些文字是在info这个节点上的。对于这种长度不定的一个html区域，不能写死xpath解析式，需要理清其HTML树结构，建立info的树结构。通过分析几个具体的页面的info部分，建立树结构如下：<br><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE6_info%E9%83%A8%E5%88%86%E7%9A%84HTML%E6%A0%91.png" alt="info部分的HTML树"><br>需要得到的是<code>&#123;&#39;出版社’:&#39;中信出版集团&#39;&#125;</code>这样的数据，通过HTML树结构可以看到的特征是键（如出版社）在span里，值可能在text里，也可能封装在span里的子元素里，反正每个键值对之后都有一个br去切分。考虑这些情况写出的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getBookInfo</span>(<span class="params">binfo,cc</span>):</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    rss=&#123;&#125;</span><br><span class="line">    k=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    v=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    f=<span class="number">0</span></span><br><span class="line">    clw=[]</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cc:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\n&#x27;</span> <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;\xa0&#x27;</span> <span class="keyword">in</span> c:</span><br><span class="line">                clw.append(c)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            clw.append(c)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> binfo[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">if</span> m.tag==<span class="string">&#x27;span&#x27;</span>:</span><br><span class="line">            mlst=m.getchildren()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(mlst)==<span class="number">0</span>: </span><br><span class="line">                k=m.text.replace(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;\xa0&#x27;</span> <span class="keyword">in</span> clw[i]:</span><br><span class="line">                    f=<span class="number">1</span><span class="comment">#需要m.tag==&#x27;a&#x27;下的值</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    v=clw[i].replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(mlst)&gt;<span class="number">0</span>:<span class="comment">#下面有子span 一种判断是m.attrib==&#123;&#125; 不够精确</span></span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> mlst:</span><br><span class="line">                    <span class="keyword">if</span> n.tag==<span class="string">&#x27;span&#x27;</span>:</span><br><span class="line">                        k=n.text.replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>) <span class="comment">#不至于下面还有span，懒得用递归了</span></span><br><span class="line">                    <span class="keyword">elif</span> n.tag==<span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                        v=n.text.replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> m.tag==<span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> f==<span class="number">1</span>: <span class="comment">#是否可以不用这个if</span></span><br><span class="line">                v=m.text.replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                f=<span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> m.tag==<span class="string">&#x27;br&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> k==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                print(i,<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rss[k]=v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(m.tag,i)</span><br><span class="line">    <span class="keyword">return</span> rss</span><br></pre></td></tr></table></figure>

<p>为了在大循环里好调用，上面的部分封装成函数，调用getBookInfo()返回的是一个字典，要整合到已有的字典里。涉及字典的组合，查了一下可以用<code>d=dict(d,**dw)</code>，其中d是旧字典，dw是要加到d里的新字典，更简便的方式是用d.update(dw)函数，下面的代码就是用的update的。<br>主循环代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rlst=[]</span><br><span class="line"><span class="keyword">for</span> bn <span class="keyword">in</span> blst:</span><br><span class="line">    res=&#123;&#125;</span><br><span class="line">    r=requests.get(<span class="string">&#x27;https://book.douban.com/j/subject_suggest?q=&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(bn))</span><br><span class="line">    rj=json.loads(r.text)</span><br><span class="line">    <span class="comment">#对rj进行一下验证和筛选</span></span><br><span class="line">    html=requests.get(rj[<span class="number">0</span>][<span class="string">&#x27;url&#x27;</span>]) <span class="comment">#之后再考虑多个返回值的验证</span></span><br><span class="line">    con = etree.HTML(html.text)</span><br><span class="line">    bname=con.xpath(<span class="string">&#x27;//*[@id=&quot;wrapper&quot;]/h1/span/text()&#x27;</span>)[<span class="number">0</span>] <span class="comment">#和bn比较</span></span><br><span class="line">    res[<span class="string">&#x27;bname_sq&#x27;</span>]=bn</span><br><span class="line">    res[<span class="string">&#x27;bname&#x27;</span>]=bname</span><br><span class="line">    res[<span class="string">&#x27;dbid&#x27;</span>]=rj[<span class="number">0</span>][<span class="string">&#x27;id&#x27;</span>] <span class="comment">#不需要存url，存id就够了</span></span><br><span class="line">    <span class="comment">#这部分取到info就够了，之后再用高级方法去匹配需要的元素，目前对应不对</span></span><br><span class="line">    binfo=con.xpath(<span class="string">&#x27;//*[@id=&quot;info&quot;]&#x27;</span>)</span><br><span class="line">    cc=con.xpath(<span class="string">&#x27;//*[@id=&quot;info&quot;]/text()&#x27;</span>)</span><br><span class="line">    res.update(getBookInfo(binfo,cc))  <span class="comment">#调用上面的函数处理binfo</span></span><br><span class="line">    bmark=con.xpath(<span class="string">&#x27;//*[@id=&quot;interest_sectl&quot;]/div/div[2]/strong/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> bmark==<span class="string">&#x27;  &#x27;</span>:</span><br><span class="line">        bits=con.xpath(<span class="string">&#x27;//*[@id=&quot;interest_sectl&quot;]/div/div[2]/div/div[2]/span/a/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> bits==<span class="string">&#x27;评价人数不足&#x27;</span>:</span><br><span class="line">            res[<span class="string">&#x27;评分&#x27;</span>]=<span class="string">&#x27;&#x27;</span></span><br><span class="line">            res[<span class="string">&#x27;评价人数&#x27;</span>]=<span class="string">&#x27;评价人数不足&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[<span class="string">&#x27;评分&#x27;</span>]=<span class="string">&#x27;&#x27;</span></span><br><span class="line">            res[<span class="string">&#x27;评价人数&#x27;</span>]=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res[<span class="string">&#x27;评分&#x27;</span>]=bmark.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        bmnum=con.xpath(<span class="string">&#x27;//*[@id=&quot;interest_sectl&quot;]/div/div[2]/div/div[2]/span/a/span/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        res[<span class="string">&#x27;评价人数&#x27;</span>]=bmnum</span><br><span class="line">    rlst.append(res)</span><br></pre></td></tr></table></figure>

<p>得到的数据可以进行一定的标准化然后进行分析再输出。上面得到的列表<code>rlst=[&#123;&#39;书名&#39;:&#39;a&#39;,&#39;出版社&#39;:&#39;b&#39;&#125;,&#123;&#39;&#39;,&#39;&#39;,&#39;&#39;:&#39;&#39;&#125;]</code>，可以直接变成dataframe，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outdf=pd.DataFrame(rlst) <span class="comment">#转dataframe</span></span><br><span class="line"></span><br><span class="line">outdf.to_excel(<span class="string">&#x27;out_douban_binfo.xlsx&#x27;</span>,index=<span class="literal">False</span>) <span class="comment">#输出数据</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE7_%E7%88%AC%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A6%82%E8%A7%88.png" alt="爬到的数据概览"></p>
<h2 id="基础统计数据分析"><a href="#基础统计数据分析" class="headerlink" title="基础统计数据分析"></a>基础统计数据分析</h2><p>我们开始时读入的<em>bsdf</em>有书名、作者、阅读时间等属性，因为爬下来的数据可能会有缺失值，将两个表合并起来进行分析。分析的维度有书名、作者、阅读时间、出版社、页数等。首先是用merge整合两表然后看一些基本的统计量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bdf=bsdf.merge(outdf,on=<span class="string">&#x27;书名&#x27;</span>,how=<span class="string">&#x27;left&#x27;</span>) <span class="comment"># 数据合并</span></span><br><span class="line"><span class="comment"># 基本统计值</span></span><br><span class="line">print(<span class="string">&#x27;一共有&#123;0&#125;本书，&#123;1&#125;个作者，&#123;2&#125;个出版社；&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(bdf),<span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">list</span>(bdf[<span class="string">&#x27;作者&#x27;</span>]))),<span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">list</span>(bdf[<span class="string">&#x27;出版社&#x27;</span>])))))</span><br></pre></td></tr></table></figure>
<p>输出是一共有421本书，309个作者，97个出版社；<br>我们就来看看前几位的作者和出版社，通过<code>bdf[&#39;作者&#39;].value_counts().head(7)</code>可以输出前7位书单里出现最多的作者，出版社同理，结果如下：<br><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE8_%E5%87%BA%E7%89%88%E7%A4%BE%E5%92%8C%E4%BD%9C%E8%80%85%E7%BB%9F%E8%AE%A1.png" alt="出版社和作者统计"></p>
<p>从作者出现次数来看，前6位都是小说类型的书，可以看一下吴军的是哪些书：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bdf.loc[bdf[<span class="string">&#x27;作者&#x27;</span>]==<span class="string">&#x27;吴军&#x27;</span>,[<span class="string">&#x27;书名&#x27;</span>,<span class="string">&#x27;阅读时间&#x27;</span>,<span class="string">&#x27;阅读情况&#x27;</span>,<span class="string">&#x27;出版社&#x27;</span>]]</span><br><span class="line"><span class="comment">#output：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                  书名       阅读时间 阅读情况      出版社</span></span><br><span class="line"><span class="string">103             数学之美 2016-10-20   P5  人民邮电出版社</span></span><br><span class="line"><span class="string">233             智能时代 2017-06-22   P4    中信出版社</span></span><br><span class="line"><span class="string">237             硅谷之谜 2017-07-01   P4  人民邮电出版社</span></span><br><span class="line"><span class="string">383  见识--商业的本质和人生的智慧 2018-10-21   P4    中信出版社</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>对每月阅读数量进行统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#绘图用到matplotlib库</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">bdf[<span class="string">&#x27;阅读年月&#x27;</span>]=bdf[<span class="string">&#x27;阅读时间&#x27;</span>].apply(<span class="keyword">lambda</span> x : x.strftime(<span class="string">&#x27;%Y-%m&#x27;</span>))</span><br><span class="line">read_date=bdf[<span class="string">&#x27;阅读年月&#x27;</span>].value_counts() <span class="comment">#每月阅读量，按月计数</span></span><br><span class="line">read_date=pd.DataFrame(read_date,columns=[<span class="string">&#x27;阅读年月&#x27;</span>]) <span class="comment">#从Series变为DataFrame</span></span><br><span class="line">read_date=read_date.sort_index()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">5</span>))</span><br><span class="line">plt.xticks(rotation=<span class="number">90</span>)<span class="comment">#设置时间标签显示格式</span></span><br><span class="line">plt.plot(read_date) <span class="comment">#因为jupyter里写了 %matplotlib inline 不用写 plt.show()</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE9_%E6%AF%8F%E6%9C%88%E9%98%85%E8%AF%BB%E6%95%B0%E9%87%8F_%E6%97%B6%E9%97%B4%E8%BD%B4%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt="每月阅读数量_时间轴折线图"><br>好奇不同年份每个月是否有一定规律呢。要统计这个比较方便的就是用数据透视表了，pandas里的<code>pivot_table</code>出场。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">bdf[<span class="string">&#x27;阅读年&#x27;</span>]=bdf[<span class="string">&#x27;阅读时间&#x27;</span>].apply(<span class="keyword">lambda</span> x : x.strftime(<span class="string">&#x27;%Y&#x27;</span>))</span><br><span class="line">bdf[<span class="string">&#x27;阅读月&#x27;</span>]=bdf[<span class="string">&#x27;阅读时间&#x27;</span>].apply(<span class="keyword">lambda</span> x : x.strftime(<span class="string">&#x27;%m&#x27;</span>)) <span class="comment">#这里也可以用.month .year</span></span><br><span class="line">r_dd=bdf.loc[:,[<span class="string">&#x27;阅读年&#x27;</span>,<span class="string">&#x27;阅读月&#x27;</span>]]</span><br><span class="line">r_dd[<span class="string">&#x27;val&#x27;</span>]=<span class="number">1</span> <span class="comment">#用以初始化</span></span><br><span class="line">r_dd=pd.pivot_table(r_dd,values=<span class="string">&#x27;val&#x27;</span>,index=[<span class="string">&#x27;阅读月&#x27;</span>],columns=[<span class="string">&#x27;阅读年&#x27;</span>],aggfunc=np.<span class="built_in">sum</span>).fillna(value=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#这部分代码的细节可以看本人github里jupyter notebook文件的输出</span></span><br><span class="line">r_dd=r_dd.loc[:,[<span class="string">&#x27;2016&#x27;</span>,<span class="string">&#x27;2017&#x27;</span>,<span class="string">&#x27;2018&#x27;</span>]] <span class="comment">#因为其他年份月份不全，只取这3年来看</span></span><br><span class="line">plt.figure()</span><br><span class="line">r_dd.plot(xticks=<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">13</span>),figsize=(<span class="number">12</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE10_%E6%AF%8F%E6%9C%88%E9%98%85%E8%AF%BB%E6%95%B0%E9%87%8F_%E6%8C%89%E5%B9%B4%E7%BB%9F%E8%AE%A1.png" alt="每月阅读数量_按年统计"><br>可以看到这3年在2月和7月阅读普遍数量更多，在7月份之前每月阅读量是逐年上涨的，而从8月到12月则是递减的规律，2016年11月阅读的书籍最多，达到40本以上。<br>评分是一个数值型变量，用<strong>箱线图</strong>[图片上传中…(图12_书单内数据相关的书籍.png-5352ab-1551272966564-0)]<br>展现其特征：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b_rank=pd.DataFrame(bdf[<span class="string">&#x27;评分&#x27;</span>]) <span class="comment">#评分分布（箱线图）</span></span><br><span class="line">b_rank.boxplot()</span><br><span class="line"></span><br><span class="line"><span class="comment">#另，评分 top 10：</span></span><br><span class="line"><span class="comment">#bdf.sort_values(by=&#x27;评分&#x27;,ascending=False).head(10).loc[:,[&#x27;书名&#x27;,&#x27;作者&#x27;,&#x27;阅读时间&#x27;,&#x27;阅读情况&#x27;,&#x27;出版社&#x27;,&#x27;评分&#x27;]]</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE11_%E4%B9%A6%E7%B1%8D%E8%AF%84%E5%88%86%E7%AE%B1%E7%BA%BF%E5%9B%BE.png" alt="书籍评分箱线图"><br>从箱线图来看，书单有评分的书籍的豆瓣平均分在7.8左右，75%的书评分在7.2以上，也有一些书是在4分一下的。</p>
<p><img src="/2019/02/25/douban_booklist_spider/%E5%9B%BE12_%E4%B9%A6%E5%8D%95%E5%86%85%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B9%A6%E7%B1%8D.png" alt="书单内数据相关的书籍"><br>书单里书名直接包含数据的书有37本，数据科学相关的书籍数量应该大于这个值。</p>
<p>可以进一步分析的有：</p>
<ul>
<li>看的书的书名词云、作者的词云;</li>
<li>出版社省份;</li>
<li>把字数统计和爬下来的页数进行拟合，把字数和页数一起处理;</li>
<li>把含有多国货币的价格属性按汇率换算后看价格的分布;</li>
</ul>
<h2 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h2><p>上面通过一个具体的需求实践了能解决问题的爬虫，豆瓣还是比较容易爬的，上面解析书目信息的做法还是很有意义的，当然我是用xpath做的，如果用BeautifulSoup又会是另一种实现方式，但分析问题-&gt;建立HTML树的过程是通用的。上面的代码还是比较简略的，没有考虑过多的验证和异常处理，有任何意见或建议欢迎交流。<br>另以上代码更新于<a href="https://github.com/QLWeilcf/lcfSpyderWithPy3/blob/master/doubanBlstSpider.ipynb">本人Github:doubanBlstSpider</a>。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title>各种著名的数据科学公开数据集与数据源</title>
    <url>/2020/09/22/famous-ds-datasets-and-source.html</url>
    <content><![CDATA[<p>本文整合整合数据科学领域一些著名的数据集。包括数据集简介和数据集获取。</p>
<p>方便做数据分析练习和可视化练手时使用。</p>
<h3 id="藏在Python库里的数据集"><a href="#藏在Python库里的数据集" class="headerlink" title="藏在Python库里的数据集"></a>藏在Python库里的数据集</h3><a id="more"></a>

<p>一些可视化库和机器学习库有着内置数据集的传统。因为库的文档和案例通常会使用一些数据集来举例、内置数据集后方便用户学习该库的可视化语法，方便复现效果。</p>
<p>Python里内置数据集的库有： plotnine、ggplot、Altair、seaborn、bokeh、plotly、sklearn等等。</p>
<p><strong>plotnine</strong>里：通过<code>import plotnine.data as pnd; pnd.__all__</code>语句列出可以直接调用的数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;diamonds&#x27;</span>, <span class="string">&#x27;economics&#x27;</span>, <span class="string">&#x27;economics_long&#x27;</span>, <span class="string">&#x27;midwest&#x27;</span>, <span class="string">&#x27;mpg&#x27;</span>, <span class="string">&#x27;msleep&#x27;</span>, <span class="string">&#x27;presidential&#x27;</span>, <span class="string">&#x27;seals&#x27;</span>, <span class="string">&#x27;txhousing&#x27;</span>, <span class="string">&#x27;luv_colours&#x27;</span>, <span class="string">&#x27;faithful&#x27;</span>, <span class="string">&#x27;faithfuld&#x27;</span>, <span class="string">&#x27;huron&#x27;</span>, <span class="string">&#x27;meat&#x27;</span>, <span class="string">&#x27;mtcars&#x27;</span>, <span class="string">&#x27;pageviews&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>通过 <code>df=pnd.diamonds</code> 语句载入数据。<br>数据表实际保存在 <em>site-packages\plotnine\data</em> 文件夹下，都是csv格式存在本地。</p>
<p><strong>ggplot</strong>提供的数据集如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chopsticks, diamonds, mtcars, meat, pageviews, pigeons, movies, mpg, salmon, load_world</span><br></pre></td></tr></table></figure>
<p>通过 <code>import ggplot.datasets as gds;df=gds.diamonds</code> 可以导入对应数据集。<br>除了world世界地图数据是需要从github下载之外，其他数据集都存在本地，<code>site-packages\ggplot\datasets</code>目录下，也都是csv文件。</p>
<p><strong>Altair</strong>：数据集在vega_data里，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> vega_datasets <span class="keyword">import</span> data</span><br><span class="line">data.list_datasets()</span><br><span class="line"><span class="comment">#[&#x27;7zip&#x27;, &#x27;airports&#x27;, &#x27;annual-precip&#x27;, &#x27;anscombe&#x27;, &#x27;barley&#x27;, &#x27;birdstrikes&#x27;, &#x27;budget&#x27;, &#x27;budgets&#x27;, &#x27;burtin&#x27;, &#x27;cars&#x27;, &#x27;climate&#x27;, &#x27;co2-concentration&#x27;, &#x27;countries&#x27;, ...]</span></span><br></pre></td></tr></table></figure>

<p>vega_data里的数据集内容挺多，有统计数据也有地理数据，还有不同数据量的版本，例如flights数据集包含了2k、5k、200k、3m等多个版本。<br>调用是写：<code>df = data(&#39;iris&#39;)</code>或者<code>df = data.iris()</code>，数据存在在<em>Anaconda3/Lib/site-packages/vega_datasets</em>目录下，存本地的在<code>local_datasets.json</code>里有描述。本地存的有csv格式的也有json格式的。</p>
<p><strong>seaborn</strong>库：<code>seaborn.get_dataset_names()</code>列出可以调用的数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.get_dataset_names()</span><br><span class="line">[<span class="string">&#x27;anagrams&#x27;</span>, <span class="string">&#x27;anscombe&#x27;</span>, <span class="string">&#x27;attention&#x27;</span>, <span class="string">&#x27;brain_networks&#x27;</span>, <span class="string">&#x27;car_crashes&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>, <span class="string">&#x27;dots&#x27;</span>, <span class="string">&#x27;exercise&#x27;</span>, <span class="string">&#x27;flights&#x27;</span>, <span class="string">&#x27;fmri&#x27;</span>, <span class="string">&#x27;gammas&#x27;</span>, <span class="string">&#x27;geyser&#x27;</span>, <span class="string">&#x27;iris&#x27;</span>, <span class="string">&#x27;mpg&#x27;</span>, <span class="string">&#x27;penguins&#x27;</span>, <span class="string">&#x27;planets&#x27;</span>, <span class="string">&#x27;tips&#x27;</span>, <span class="string">&#x27;titanic&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>通过<code>iris=seaborn.load_dataset(&#39;iris&#39;)</code>载入数据，不过值得说明的是seaborn库本地初始时是不存着这些数据集的，这个和其他库不同，seaborn调用 load_dataset() 的时候是从GitHub下载到本地，所以有时候会下载失败，使用时可以从<a href="https://github.com/mwaskom/seaborn-data">seaborn-data</a> 自行下载文件再导入（或者考虑用其他库内置的数据集）。</p>
<p><strong>plotly</strong>：默认的数据集不多，有7个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line">px.data.__all__</span><br><span class="line"><span class="comment">#[&#x27;carshare&#x27;, &#x27;election&#x27;, &#x27;election_geojson&#x27;, &#x27;gapminder&#x27;, &#x27;iris&#x27;, &#x27;tips&#x27;, &#x27;wind&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>通过<code>df=px.data.gapminder()</code>调用。</p>
<p><strong>bokeh</strong>：数据集相关文件在<code>site-packages/bokeh/sampledata</code>路径下，它把一些通用的数据集都封装为py文件进行调用，例如iris数据集经过了一层封装叫flowers，载入数据是用<code>from bokeh.sampledata.iris import flowers</code>。<br>没有语句可以列出有哪些数据集，从代码中拆出来它内置的数据集有：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#files=</span><br><span class="line">[&#x27;CGM.csv&#x27;, &#x27;US_Counties.zip&#x27;, &#x27;us_cities.json&#x27;, &#x27;unemployment09.csv&#x27;, &#x27;AAPL.csv&#x27;, &#x27;FB.csv&#x27;, &#x27;GOOG.csv&#x27;, &#x27;IBM.csv&#x27;, &#x27;MSFT.csv&#x27;, &#x27;WPP2012_SA_DB03_POPULATION_QUINQUENNIAL.zip&#x27;, &#x27;gapminder_fertility.csv&#x27;, &#x27;gapminder_population.csv&#x27;, &#x27;gapminder_life_expectancy.csv&#x27;, &#x27;gapminder_regions.csv&#x27;, &#x27;world_cities.zip&#x27;, &#x27;airports.json&#x27;, &#x27;movies.db.zip&#x27;, &#x27;airports.csv&#x27;, &#x27;routes.csv&#x27;]</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/22/famous-ds-datasets-and-source/bokeh-sampledata-iris-call-flowers.png" alt="bokeh里iris数据集的调用关系"></p>
<p><strong>sklearn</strong>，内置了一些经典的机器学习练手数据集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.datasets <span class="keyword">as</span> dts</span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> dts.__all__ <span class="keyword">if</span> <span class="string">&#x27;load&#x27;</span> <span class="keyword">in</span> i]</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">[<span class="string">&#x27;load_boston&#x27;</span>,<span class="string">&#x27;load_diabetes&#x27;</span>,<span class="string">&#x27;load_digits&#x27;</span>,<span class="string">&#x27;load_files&#x27;</span>,<span class="string">&#x27;load_iris&#x27;</span>,<span class="string">&#x27;load_breast_cancer&#x27;</span>,<span class="string">&#x27;load_linnerud&#x27;</span>, <span class="string">&#x27;load_mlcomp&#x27;</span>,<span class="string">&#x27;load_sample_image&#x27;</span>, <span class="string">&#x27;load_sample_images&#x27;</span>,<span class="string">&#x27;load_svmlight_file&#x27;</span>,<span class="string">&#x27;load_svmlight_files&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>因此其调用方式：<code>df=dts.load_iris()</code>。</p>
<p>另外，sklearn的数据集有很多种：</p>
<ul>
<li>自带的小数据集，也就是我们上面列出的可以通过dts.load_name()直接导入的；</li>
<li>需在线下载的数据集，通过dts.fetch_name()导入；</li>
<li>模拟生成的数据集，dts.make_name()；</li>
<li>svmlight/libsvm格式的数据集，导入语句：dts.load_svmlight_file(name)；</li>
<li>从买了data.org在线下载获取的数据集：dts.fetch_mldata(name)；；</li>
</ul>
<h3 id="著名公开数据集"><a href="#著名公开数据集" class="headerlink" title="著名公开数据集"></a>著名公开数据集</h3><p>一些数据科学领域广泛使用（在教程文章、课程练习等场景也广泛使用）的数据集简介。</p>
<h4 id="iris"><a href="#iris" class="headerlink" title="iris"></a>iris</h4><p>鸢尾花数据集。首次出现在著名的英国统计学家和生物学家Ronald Fisher 1936年的论文《The use of multiple measurements in taxonomic problems》中，被用来介绍<strong>线性判别式分析</strong>。<br>数据集中，包括了三类不同的鸢尾属植物：Iris Setosa，Iris Versicolour，Iris Virginica。<br>每类50个样本、共150个样本。属性包括花萼长度、宽、花瓣长、宽，单位都是cm。</p>
<p><img src="/2020/09/22/famous-ds-datasets-and-source/iris-dataset-head-pic.png" alt="Iris数据集各列含义"></p>
<p>如果安装了seaborn、plotly、bokeh这些可视化库，可以通过上一章提到的语句获取iris数据。<br>一些在线的数据集下载地址如下：</p>
<ul>
<li><a href="https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html">https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html</a></li>
<li><a href="https://www.kaggle.com/arshid/iris-flower-dataset">https://www.kaggle.com/arshid/iris-flower-dataset</a></li>
</ul>
<h4 id="titanic"><a href="#titanic" class="headerlink" title="titanic"></a>titanic</h4><p>声名远扬的泰坦尼克号船员数据集，数据集描述的是船员的性别、年龄、所在船仓等级等特征及最后是否存活。网络上大量的文章是关于泰坦尼克号船员生存率分析的，通过分类或回归算法拟合船员的基本特征与获救情况的关系，甚至一些文章鼓吹将这个项目写入简历。</p>
<p><img src="/2020/09/22/famous-ds-datasets-and-source/titanic-dataset-head.png" alt="泰坦尼克数据集概览"></p>
<p>在seaborn库里可以通过<code>sns.load_dataset(&#39;titanic&#39;)</code>获取泰坦尼克数据集。<br>在线数据源：</p>
<ul>
<li><a href="https://www.kaggle.com/hesh97/titanicdataset-traincsv">https://www.kaggle.com/hesh97/titanicdataset-traincsv</a></li>
</ul>
<h4 id="boston"><a href="#boston" class="headerlink" title="boston"></a>boston</h4><p>波士顿房价数据集。经典的用于回归任务的数据集，机器学习类文章大家喜欢写的是波士顿房价预测，热度和泰坦尼克号船员生存率分析接近了。boston数据集有13个特征，包括各类用地比例、师生比例、每居民房子数、可达性指数等，除土地是否在查尔斯河旁边是一个二值变量，其余特征为数值类型。</p>
<p>该数据集在sklearn库里可以直接导入。</p>
<h4 id="diamonds"><a href="#diamonds" class="headerlink" title="diamonds"></a>diamonds</h4><p>钻石数据集。该数据集有10列，csv文件约2.64MB，包含了近54000颗钻石的价格及其他属性。Diamonds数据集在各种R语言数据分析文章里有很高的出镜率，大家普遍用来做探索性数据分析和可视化案例。</p>
<p><img src="/2020/09/22/famous-ds-datasets-and-source/diamonds-dataset-head.png" alt="diamonds数据列概览"></p>
<p>具体各特征含义如下：</p>
<ul>
<li>钻石价格：以美元计价；</li>
<li>克拉：钻石重量（0.2-5.01）；</li>
<li>切割质量：分为公平，良好，非常好，高级，理想 5个等级；</li>
<li>台面：钻石顶部宽度相对于最宽点（43-95）；</li>
<li>钻石颜色，从J（最差）到D（最好）；</li>
<li>纯度：测量钻石的纯净度（I1（最差），SI2，SI1，VS2，VS1，VVS2，VVS1，IF（最佳））；</li>
<li>X：长度mm（0-10.74）；</li>
<li>Y：宽度mm（0-58.9）；</li>
<li>Z：深度mm（0-31.8）；</li>
<li>深度：总深度百分比，根据X,Y,Z算出：<code>=z/平均值(x，y)= 2 * z /(x + y)(43-79)</code>；</li>
</ul>
<p>diamonds数据集详细描述：<br><a href="https://ggplot2.tidyverse.org/reference/diamonds.html">https://ggplot2.tidyverse.org/reference/diamonds.html</a></p>
<p>包含该数据集的库包括seaborn、plotnine及ggplot。</p>
<h4 id="gapminder"><a href="#gapminder" class="headerlink" title="gapminder"></a>gapminder</h4><p><a href="https://www.gapminder.org/about/">Gapminder</a> 本身是一家位于瑞典斯德哥尔摩的非盈利机构，其收集和公开了关于世界的经济、教育、环境、健康等专题数据。Hans Rosling的TED演讲用了几个生动的例子展现了gapminder统计数据的魅力。</p>
<p>plotly包含了一个gapminder样本数据集，<br>在线数据集下载：</p>
<ul>
<li><a href="https://www.gapminder.org/data/">https://www.gapminder.org/data/</a></li>
</ul>
<p><img src="/2020/09/22/famous-ds-datasets-and-source/gapminder-vis-demo-plotly.PNG" alt="gapminder数据集可视化案例"></p>
<h4 id="wine"><a href="#wine" class="headerlink" title="wine"></a>wine</h4><p>葡萄酒数据集，该数据集描述来自意大利同一地区三个不同品种的葡萄酒进行化学分析的结果，每种所含的13种成分的数量。特征包括Alcohol、Ash、Total phenols、Hue等13种。</p>
<h4 id="cars"><a href="#cars" class="headerlink" title="cars"></a>cars</h4><p>cars数据集现在有两种可能性，一种是在1983年美国统计协会(ASA)公布的，由Ramos和Donoho收集的406辆汽车数据，包括车重(weight)、马力(horsepower)、没加仑油行驶(MPG)、汽车产地(origin)等特征。</p>
<p><img src="/2020/09/22/famous-ds-datasets-and-source/cars-dataset-head-1.png" alt="汽车特征数据集概览"></p>
<p>该数据集在Altair库里有，Altair的教程文档里有关于cars数据集的可视化案例：<br><a href="https://altair-viz.github.io/altair-tutorial/notebooks/01-Cars-Demo.html">https://altair-viz.github.io/altair-tutorial/notebooks/01-Cars-Demo.html</a></p>
<p>另一种是斯坦福大学整理的16185张汽车图片数据集。</p>
<p><img src="/2020/09/22/famous-ds-datasets-and-source/cars-dataset-head-img.png" alt="汽车照片数据集介绍"></p>
<p>汽车图片数据集下载源：</p>
<ul>
<li><a href="http://ai.stanford.edu/~jkrause/cars/car_dataset.html">http://ai.stanford.edu/~jkrause/cars/car_dataset.html</a></li>
</ul>
<h4 id="anscombe"><a href="#anscombe" class="headerlink" title="anscombe"></a>anscombe</h4><p>安斯库姆四重奏(Anscombe’s Quartet) ，是一个用于展现当数据序列差别非常大时一些统计值却相等的著名数据集。Anscombe数据集由统计学家Francis Anscombe在1973年构造出来，一共包含了4组数据，每组11个X-Y散点。这四组数据均值、方差、相关系数及线性回归曲线(mean, variance, correlation, and linear regression lines)都相同，X的平均数都是9.0，Y值的平均数都是7.5；X值的方差都是11.0，Y值的方差都是4.12；X、Y之间的相关系数皆为0.816，线性回归线都是y=3.0+0.5x。从统计值来看，这四个数据集似乎非常接近，但具体分布差别巨大。<br>这个数据集体现了数据实际分布的可视化的重要性以及用对拟合方式的重要性。文字还是苍白了，可以看图去体会：</p>
<p><img src="/2020/09/22/famous-ds-datasets-and-source/seaborn-regplot-anscombe.png" alt="Anscombe&#39;s Quartet数据点分布"></p>
<p>I是最“正常”的一组数据，也是这几个统计值擅长勾画的内容，II所反映的事实上是一个精确的二次函数关系，只是在错误地应用了线性模型后，各项统计数字与第一组数据恰好都相同；III描述的是一个精确的线性关系，只是这里面有一个异常值，它导致了上述各个统计数字，尤其是相关度值的偏差；IV则是一个更极端的例子，数据集中在(8,7)附近，但异常值(19,12.5)使得平均数、方差、相关度、线性回归线等所有统计数字全部发生偏差。</p>
<p><em>注，上图绘制代码：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import seaborn as sns</span><br><span class="line">g &#x3D; sns.FacetGrid(df, col&#x3D;&quot;Series&quot;)</span><br><span class="line">g.map(sns.regplot, &quot;X&quot;, &quot;Y&quot;,color&#x3D;&#39;#1EAFAE&#39;,ci&#x3D;None)</span><br><span class="line">g.add_legend()</span><br></pre></td></tr></table></figure>


<h4 id="airports"><a href="#airports" class="headerlink" title="airports"></a>airports</h4><p>地理数据，美国机场的坐标点。包含5列，分别为airport code, city, state, latitude, and longitude。</p>
<p>在Altair、bokeh库里能直接导入使用。<br>数据集公开地址：</p>
<ul>
<li><a href="http://ourairports.com/data/">http://ourairports.com/data/</a></li>
</ul>
<h3 id="热门整合数据源"><a href="#热门整合数据源" class="headerlink" title="热门整合数据源"></a>热门整合数据源</h3><ul>
<li><p><strong>国家统计局数据</strong>：<br><a href="http://data.stats.gov.cn/">http://data.stats.gov.cn</a><br>数据来源中华人民共和国国家统计局，包含了我国经济民生等多个方面的数据，并且在月度、季度、年度都有覆盖，全面又权威。</p>
</li>
<li><p>Kaggle：一个数据竞赛网站，收集了很多著名和实用的数据集用于训练和竞赛。<a href="https://www.kaggle.com/">https://www.kaggle.com/</a></p>
</li>
<li><p><strong>UCI</strong>：机器学习数据集集合，挺老牌的，<br><a href="http://archive.ics.uci.edu/ml/index.php">http://archive.ics.uci.edu/ml/index.php</a>, 包括经典的Iris、波尔多葡萄酒等数据集；</p>
</li>
<li><p>卡内基·梅隆大学(CMU)统计学院网站的整合数据集页面：  <a href="http://lib.stat.cmu.edu/datasets/">http://lib.stat.cmu.edu/datasets/</a></p>
</li>
<li><p>机器学习数据集整合：</p>
<ul>
<li><a href="https://www.datasetlist.com/">Machine learning datasets</a></li>
<li><a href="https://archive.ics.uci.edu/ml/machine-learning-databases/%E3%80%82">https://archive.ics.uci.edu/ml/machine-learning-databases/。</a></li>
</ul>
</li>
<li><p>伯克利自动驾驶数据集：<a href="http://bdd-data.berkeley.edu/">http://bdd-data.berkeley.edu/</a></p>
</li>
<li><p>UCI 垃圾邮件数据集：<a href="https://archive.ics.uci.edu/ml/datasets/Spambase">https://archive.ics.uci.edu/ml/datasets/Spambase</a></p>
</li>
<li><p>北京城市实验室地理数据：<a href="https://www.beijingcitylab.com/data-released/data1-20/">https://www.beijingcitylab.com/data-released/data1-20/</a></p>
</li>
<li><p>体育大数据:<a href="http://www.sportsdt.com/">http://www.sportsdt.com/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据集</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>dataset</tag>
        <tag>viz</tag>
      </tags>
  </entry>
  <entry>
    <title>GEOJSON标准格式学习</title>
    <url>/2020/09/22/geo-geojson-format.html</url>
    <content><![CDATA[<p>最近做的项目需要详细了解geojson，因此查了一些资料，现在整理一份标准格式的记录，要理解本文需要首先了解json的基本知识，这里不过多展开，可以去参考w3school上的教程，简言之，json是通过键值对表示数据对象的一种格式，可以很好地表达数据，其全称为<strong>JavaScript Object Notation</strong>（JavaScript Object Notation），正如这个名称，JavaScript和json联系紧密，但是json可以应用的范围很广，不止于前端，它比XML数据更轻量、更容易解析（某种角度上说xml可以更自由地封装更多的数据）。很多编程语言都有对应的json解析库，例如Python的json库，C#的Newtonsoft.Json，Java的org.json。geojson是用json的语法表达和存储地理数据，可以说是json的子集。</p>
<p>例如下面就是一个点数据：</p>
<a id="more"></a>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;FeatureCollection&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;features&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;Feature&quot;</span>,</span><br><span class="line">	    <span class="attr">&quot;properties&quot;</span>:&#123;&#125;,</span><br><span class="line">	    <span class="attr">&quot;geometry&quot;</span>:&#123;</span><br><span class="line">		    <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;Point&quot;</span>,</span><br><span class="line">		    <span class="attr">&quot;coordinates&quot;</span>:[<span class="number">105.380859375</span>,<span class="number">31.57853542647338</span>]</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/geo-geojson-format/geo-json-pics-1.png" alt="例子图片"></p>
<p><em>（注：以下geojson的效果截图都来自<a href="http://geojson.io/#map=2/20.0/0.0">geojson.io</a>在线生成）</em></p>
<p>geojson将所有的地理要素分为Point、MultiPoint、LineString、MultiLineString、Polygon、MultiPolygon、GeometryCollection。首先是将这些要素封装到单个的geometry里，然后作为一个个的Feature（也就是要素）；要素放到一个要素集合里，从树状结构来理解FeatureCollection就是根节点，表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;FeatureCollection&quot;,</span><br><span class="line">  &quot;features&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有地理要素放在features的列表里。</p>
<h3 id="点要素Point"><a href="#点要素Point" class="headerlink" title="点要素Point"></a>点要素Point</h3><p>点要素是最简单的，类型type对应Point，然后坐标是一个1维的数组，里面有两个元素（如果是立体的坐标就是三维x,y,z），分别为经度和纬度。properties里面可以封装各种属性，例如名称、标识颜色等等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;Feature&quot;,</span><br><span class="line">	&quot;properties&quot;:&#123;&#125;,</span><br><span class="line">	&quot;geometry&quot;:&#123;</span><br><span class="line">		&quot;type&quot;:&quot;Point&quot;,</span><br><span class="line">		&quot;coordinates&quot;:[105.380859375,31.57853542647338]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id="多点要素MultiPoint"><a href="#多点要素MultiPoint" class="headerlink" title="多点要素MultiPoint"></a>多点要素MultiPoint</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;Feature&quot;,</span><br><span class="line">	&quot;properties&quot;:&#123;&#125;,</span><br><span class="line">	&quot;geometry&quot;:&#123;</span><br><span class="line">		&quot;type&quot;:&quot;MultiPoint&quot;,</span><br><span class="line">		&quot;coordinates&quot;:[[105.380859375,31.57853542647338],</span><br><span class="line">			    [105.580859375,31.52853542647338]</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>其核心坐标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">105.380859375,31.57853542647338</span><br><span class="line">105.580859375,31.52853542647338</span><br></pre></td></tr></table></figure>

<h3 id="线要素LineString"><a href="#线要素LineString" class="headerlink" title="线要素LineString"></a>线要素LineString</h3><p>线要素就是指线段，记录的是线的端点坐标，可视化时会按照记录顺序联结。对于曲线（如贝塞尔曲线）目前还没有很好的表达，但是在地理数据中，曲线一般会用LineString去拟合，现实地理世界中也没有标准的曲线地理要素。</p>
<p>线要素的坐标coordinates里的二维数组和多点要素基本一样，区别就在type上了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;Feature&quot;,</span><br><span class="line">	&quot;properties&quot;:&#123;&#125;,</span><br><span class="line">	&quot;geometry&quot;:&#123;</span><br><span class="line">		&quot;type&quot;:&quot;LineString&quot;,</span><br><span class="line">		&quot;coordinates&quot;:[[105.6005859375,30.65681556429287],</span><br><span class="line">		[107.95166015624999,31.98944183792288],</span><br><span class="line">		[109.3798828125,30.031055426540206],</span><br><span class="line">		[107.7978515625,29.935895213372444]]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对应的Kml表达：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Placemark</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ExtendedData</span>&gt;</span><span class="tag">&lt;/<span class="name">ExtendedData</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">LineString</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">coordinates</span>&gt;</span>108.65753173828125,34.1873818599505 108.72413635253905,34.25154099726973 108.77151489257812,34.16977214177208 108.88481140136719,34.229970811273084</span><br><span class="line">		<span class="tag">&lt;/<span class="name">coordinates</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">LineString</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Placemark</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="MultiLineString"><a href="#MultiLineString" class="headerlink" title="MultiLineString"></a>MultiLineString</h3><p>也是一个三维数组（和多边形一样）；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;Feature&quot;,</span><br><span class="line">	&quot;properties&quot;:&#123;&#125;,</span><br><span class="line">	&quot;geometry&quot;:&#123;</span><br><span class="line">		&quot;type&quot;:&quot;MultiLineString&quot;,</span><br><span class="line">		&quot;coordinates&quot;:</span><br><span class="line">		[</span><br><span class="line">			[</span><br><span class="line">		        [105.6005859375,30.65681556429287],</span><br><span class="line">		        [107.95166015624999,31.98944183792288],</span><br><span class="line">		        [109.3798828125,30.031055426540206],</span><br><span class="line">		        [107.7978515625,29.935895213372444]</span><br><span class="line">			],</span><br><span class="line">			[</span><br><span class="line">		        [109.3798828125,30.031055426540206],</span><br><span class="line">		        [107.1978515625,31.235895213372444]</span><br><span class="line">			]</span><br><span class="line">		]</span><br><span class="line">	            &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id="多边形Polygon"><a href="#多边形Polygon" class="headerlink" title="多边形Polygon"></a>多边形Polygon</h3><p>注：单个多边形是一个3维数组，可以包含多个二维数组，这种情况和MultiPolygon效果很像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;Feature&quot;,</span><br><span class="line">	&quot;properties&quot;:&#123;&#125;,</span><br><span class="line">	&quot;geometry&quot;:&#123;</span><br><span class="line">		&quot;type&quot;:&quot;Polygon&quot;,</span><br><span class="line">		&quot;coordinates&quot;:[</span><br><span class="line">			            [</span><br><span class="line">				          [106.10595703125,33.33970700424026],</span><br><span class="line">				          [106.32568359375,32.41706632846282],</span><br><span class="line">				          [108.03955078125,32.2313896627376],</span><br><span class="line">				          [108.25927734375,33.15594830078649],</span><br><span class="line">				          [106.10595703125,33.33970700424026]</span><br><span class="line">			            ]</span><br><span class="line">		              ]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id="多多边形MultiPolygon"><a href="#多多边形MultiPolygon" class="headerlink" title="多多边形MultiPolygon"></a>多多边形MultiPolygon</h3><h4 id="type-1-两个不会相交的多边形"><a href="#type-1-两个不会相交的多边形" class="headerlink" title="type 1 两个不会相交的多边形"></a>type 1 两个不会相交的多边形</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Feature&quot;,</span><br><span class="line">  &quot;properties&quot;: &#123;&#125;,</span><br><span class="line">  &quot;geometry&quot;: &#123;</span><br><span class="line">  &quot;type&quot;: &quot;MultiPolygon&quot;,</span><br><span class="line">  &quot;coordinates&quot;:</span><br><span class="line">    [ </span><br><span class="line">        [</span><br><span class="line">			[</span><br><span class="line">				[109.2041015625,30.088107753367257],</span><br><span class="line">				[115.02685546875,30.088107753367257],</span><br><span class="line">				[115.02685546875,32.7872745269555],</span><br><span class="line">				[109.2041015625,32.7872745269555],</span><br><span class="line">				[109.2041015625,30.088107753367257]</span><br><span class="line">		  </span><br><span class="line">		  </span><br><span class="line">			]</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">			[</span><br><span class="line">				[112.9833984375,26.82407078047018],</span><br><span class="line">				[116.69677734375,26.82407078047018],</span><br><span class="line">				[116.69677734375,29.036960648558267],</span><br><span class="line">				[112.9833984375,29.036960648558267],</span><br><span class="line">				[112.9833984375,26.82407078047018]</span><br><span class="line">			]</span><br><span class="line">		]</span><br><span class="line">    ]</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/geo-geojson-format/geo-json-pics-2.png" alt="两个不相交的多边形"></p>
<h4 id="type-2-两个镶套的多边形"><a href="#type-2-两个镶套的多边形" class="headerlink" title="type 2 两个镶套的多边形"></a>type 2 两个镶套的多边形</h4><p>小的在前面，范围大的在后面，用上4个中括号，但效果不是有洞的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     &quot;type&quot;: &quot;Feature&quot;,</span><br><span class="line">     &quot;properties&quot;: &#123;&#125;,</span><br><span class="line">     &quot;geometry&quot;: &#123;</span><br><span class="line">       &quot;type&quot;: &quot;MultiPolygon&quot;,</span><br><span class="line">       &quot;coordinates&quot;:</span><br><span class="line">       [ </span><br><span class="line">           [</span><br><span class="line">		    [</span><br><span class="line">			    [101.6455078125,27.68352808378776],</span><br><span class="line">			    [114.78515624999999,27.68352808378776],</span><br><span class="line">			    [114.78515624999999,35.209721645221386],</span><br><span class="line">			    [101.6455078125,35.209721645221386],</span><br><span class="line">			    [101.6455078125,27.68352808378776]</span><br><span class="line">		    ]	</span><br><span class="line">	    ],</span><br><span class="line">           [</span><br><span class="line">		    [</span><br><span class="line">			    [104.2822265625,30.107117887092357],</span><br><span class="line">			    [108.896484375,30.107117887092357],</span><br><span class="line">			    [108.896484375,33.76088200086917],</span><br><span class="line">			    [104.2822265625,33.76088200086917],</span><br><span class="line">			    [104.2822265625,30.107117887092357]</span><br><span class="line">		    ]</span><br><span class="line">	    ]</span><br><span class="line">	]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/geo-geojson-format/geo-json-pics-3.png" alt="两个镶套的多边形"></p>
<h4 id="type-3-有孔洞的多边形"><a href="#type-3-有孔洞的多边形" class="headerlink" title="type 3 有孔洞的多边形"></a>type 3 有孔洞的多边形</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &quot;type&quot;: &quot;Feature&quot;,</span><br><span class="line">      &quot;properties&quot;: &#123;&#125;,</span><br><span class="line">      &quot;geometry&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;MultiPolygon&quot;,</span><br><span class="line">        &quot;coordinates&quot;:</span><br><span class="line">    [ </span><br><span class="line">        [</span><br><span class="line">			[</span><br><span class="line">				[101.6455078125,27.68352808378776],</span><br><span class="line">				[114.78515624999999,27.68352808378776],</span><br><span class="line">				[114.78515624999999,35.209721645221386],</span><br><span class="line">				[101.6455078125,35.209721645221386],</span><br><span class="line">				[101.6455078125,27.68352808378776]</span><br><span class="line">				</span><br><span class="line">		  </span><br><span class="line">			],</span><br><span class="line">			[</span><br><span class="line">				[104.2822265625,30.107117887092357],</span><br><span class="line">				[108.896484375,30.107117887092357],</span><br><span class="line">				[108.896484375,33.76088200086917],</span><br><span class="line">				[104.2822265625,33.76088200086917],</span><br><span class="line">				[104.2822265625,30.107117887092357]</span><br><span class="line">			</span><br><span class="line">			]</span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/geo-geojson-format/geo-json-pics-4.png" alt="有孔洞的多边形"></p>
<p>可以仔细去品味type2和type3的区别。它们对应的kml表达区别是比较大的。</p>
<h3 id="GeometryCollection"><a href="#GeometryCollection" class="headerlink" title="GeometryCollection"></a>GeometryCollection</h3><p>GeometryCollection是多种基本地理要素的集合，就是里面可以包含点、线、面要素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;GeometryCollection&quot;,</span><br><span class="line">    &quot;geometries&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">         &quot;type&quot;: &quot;Point&quot;,</span><br><span class="line">          &quot;coordinates&quot;: [108.62, 31.02819]</span><br><span class="line">         &#125;, &#123;</span><br><span class="line">         &quot;type&quot;: &quot;LineString&quot;,</span><br><span class="line">          &quot;coordinates&quot;: [[108.896484375,30.1071178870],</span><br><span class="line">          [108.2184375,30.91717870],</span><br><span class="line">          [109.5184375,31.2175780]]</span><br><span class="line">         &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GeometryCollection不需要放在FeatureCollection里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;FeatureCollection&quot;,</span><br><span class="line">  &quot;features&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>geojson里面还有其他标签表达其他的属性，如外包矩形等，其中特别重要的是坐标系统，一般里面的坐标默认为WGS84，当然也可以是其他坐标系统的坐标，但是要标识。这部分内容之后再补充了。</p>
<p>更具体的内容可以参考<a href="https://tools.ietf.org/html/rfc7946">rfc7946</a>。</p>
]]></content>
      <categories>
        <category>格式解析</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 主题个性化配置(保持更新)</title>
    <url>/2020/09/22/hexo-personalize-config.html</url>
    <content><![CDATA[<p>初心：更好地利用前端交互性，做更优秀的笔记效果，更方便更新</p>
<p>配置Hexo总结。关于Hexo建站的教程太多了，很多细节很到位，不想重复，整体建站和配置的框架如下：</p>
<ul>
<li><input disabled type="checkbox"> 安装node（可用<code>node -v</code>命令检验是否安装成功）；添加国内阿里镜像进行加速（可选）；</li>
</ul>
<span id="more"></span>

<ul>
<li><input disabled type="checkbox"> 安装git（后续一些命令在gitbash里操作）；</li>
<li><input disabled type="checkbox"> 下载Hexo和一个主题（个人选了NexT）；</li>
<li><input disabled type="checkbox"> 简单配置主题并运行看效果；</li>
<li><input disabled type="checkbox"> 生成ssh key配置到GitHub；</li>
<li><input disabled type="checkbox"> <code>hexo d</code>部署到GitHub；</li>
<li><input disabled type="checkbox"> 绑定域名（可选）；</li>
<li><input disabled type="checkbox"> 继续优化个性化效果并更新到GitHub；</li>
</ul>
<h3 id="三大修改点"><a href="#三大修改点" class="headerlink" title="三大修改点"></a>三大修改点</h3><p>进行Hexo主题的个性化，个人总结三大修改点为：</p>
<ul>
<li>改配置；某些组件启用不启用，某些插件使用与否；相关设置都在两个配置文件里，即 hexo项目文件夹下的<code>_config.yml</code>和主题下的文件夹<code>themes/next/_config.yml</code>；（下文称前者为hexo配置文件，后者为主题配置文件）</li>
<li>改渲染模板；主题layout文件夹下的各种swig文件；</li>
<li>改CSS，各种颜色、居中等样式和排版效果；对应<code>themes/next/source/css</code>及子目录下的各种styl后缀的文件；</li>
</ul>
<p>建站一小时，配置十数小时。具体的一些常用和有趣的:</p>
<h3 id="丰富文章分类"><a href="#丰富文章分类" class="headerlink" title="丰富文章分类"></a>丰富文章分类</h3><ul>
<li>生成md时生成一个文件夹，更好地放图片等资源</li>
</ul>
<p>把hexo配置文件<code>_config.yml</code>中的<code>post_asset_folder</code>项，设置为true。</p>
<ul>
<li>生成时有更多属性，如toc等<br>修改项目scaffolds文件夹里的post.md文件为：（需要有的内容根据需求删减）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="attr">title</span>: &#123;&#123; title &#125;&#125;</span><br><span class="line"><span class="attr">date</span>: &#123;&#123; date &#125;&#125;</span><br><span class="line"><span class="attr">top</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">cover</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">password</span>:</span><br><span class="line"><span class="attr">toc</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">mathjax</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">summary</span>:</span><br><span class="line"><span class="attr">tags</span>:</span><br><span class="line"><span class="attr">categories</span>:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="个性化展示效果"><a href="#个性化展示效果" class="headerlink" title="个性化展示效果"></a>个性化展示效果</h3><h4 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h4><p>阅读全文</p>
<ul>
<li><p>阅读全文居中<br>mist主题中阅读全文默认是居左的，改为居中：在css中，找到<code>post-button</code>，把<code>text-align: center</code>变成<code>text-align: center !important;</code></p>
</li>
<li><p>头像点击后回到首页<br>头像图片文件的目录<code>\themes\next\source\images</code>，导航栏的站点概览渲染现在是移到了\themes\next\layout_partials\sidebar 目录下的site-overview.swig，不是在\themes\next\layout_macro\sidebar.swig，所以是修改site-overview.swig文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> theme.<span class="property">avatar</span>.<span class="property">url</span> %&#125;</span><br><span class="line">  &lt;img <span class="keyword">class</span>=<span class="string">&quot;site-author-image&quot;</span> itemprop=<span class="string">&quot;image&quot;</span> alt=<span class="string">&quot;&#123;&#123; author &#125;&#125;&quot;</span></span><br><span class="line">    src=<span class="string">&quot;&#123;&#123; url_for(theme.avatar.url) &#125;&#125;&quot;</span>&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>变成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> theme.<span class="property">avatar</span>.<span class="property">url</span> %&#125;</span><br><span class="line">&lt;a href=<span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;site-author-image&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&#123;&#123; author &#125;&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; url_for(theme.avatar.url) &#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>也就是添加了<code>&lt;a href=&quot;/&quot;&gt;</code> 和<code>&lt;/a&gt;</code>。</p>
</li>
</ul>
<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>都是改css</p>
<p>标题颜色:<code>themes\next\source\css\_common\components\post\post-header.styl </code></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><ul>
<li><p>正确显示图片<br>安装一个插件，注意版本挺关键，因此不能直接用npm install hexo-asset-image  –save，而是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></span><br></pre></td></tr></table></figure>
<p>还需要修改hexo配置文件<code>_config.yml</code>，把<code>post_asset_folder</code>的值变成 <code>true</code>，图片需要放在md文件同名的文件夹下，否则也可能没办法正确显示。</p>
</li>
<li><p>图床的图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;https://qlweilcf.github.io/images/avatar.jpg&quot; alt=&quot;earth&quot; style=&quot;float:left;height:90px;width:90px;margin-right:5px&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示图片文本</p>
</li>
</ul>
<p>用特定版本的hexo-asset-image，就可以正常显示图片对应的说明文本，文本和图片的相对位置可以微调css；</p>
<ul>
<li>图片居中<br><code>next\source\css\_common\components\post\post.styl</code></li>
</ul>
<p>在post里写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-body</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多张图片横排</li>
</ul>
<h4 id="post-发布内容"><a href="#post-发布内容" class="headerlink" title="post 发布内容"></a>post 发布内容</h4><ul>
<li><p>底部居中<br>找到<code>themes/next/source/css/_schemes/Mist/index.styl</code>文件中的footer，将.footer-inner的<code>text-align: left</code>修改为<code>center</code>。</p>
</li>
<li><p>不渲染某些文件<br>两种方法：<br>1，在项目根目录下的配置文件<code>_config.yml</code>中找到skip_render，在后面添加要跳过渲染的页面，例如<code>skip_render: viz\**</code>，那么就表示 <code>\source\viz</code> 目录下的所有文件将跳过渲染，直接复制到 public 文件夹发布。排除的规则可以用正则表达式，例如<code>skip_render: &#39;*.html&#39;</code><br>2，在文章头部添加<code>---layout: false---</code>。<br>不渲染的HTML里，css，JavaScript等的引入尽量写到html文件里；图片考虑图床或者变成base64编码写入HTML里。</p>
</li>
<li><p>标题下面显示文章字数、预计阅读时间</p>
</li>
</ul>
<p>安装wordcount：<code>npm install hexo-wordcount --save</code>，<br>修改主题配置文件：找到post_wordcount，把需要的设置为true，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_wordcount</span>:</span><br><span class="line">  <span class="attr">item_text</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount</span>: <span class="literal">true</span>        </span><br><span class="line">  <span class="attr">min2read</span>: <span class="literal">true</span>          </span><br><span class="line">  <span class="attr">totalcount</span>: <span class="literal">false</span>       </span><br><span class="line">  <span class="attr">separated_meta</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>修改渲染模板文件：<code>\themes\next\layout\_macro\post.swig</code>，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> not is_index and theme.<span class="property">busuanzi_count</span>.<span class="property">enable</span> and theme.<span class="property">busuanzi_count</span>.<span class="property">post_views</span> %&#125;</span><br><span class="line">            &lt;span <span class="keyword">class</span>=<span class="string">&quot;post-meta-item&quot;</span> title=<span class="string">&quot;&#123;&#123; __(&#x27;post.views&#x27;) &#125;&#125;&quot;</span> id=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> style=<span class="string">&quot;display: none;&quot;</span>&gt;</span><br><span class="line">              <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.busuanzi_count.post_views_icon &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">              <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>&#123;&#123; __(&#x27;post.views&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">              <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">          &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>变成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;%- <span class="keyword">if</span> not is_index and theme.<span class="property">busuanzi_count</span>.<span class="property">enable</span> and theme.<span class="property">busuanzi_count</span>.<span class="property">post_views</span> %&#125;</span><br><span class="line">            &lt;span <span class="keyword">class</span>=<span class="string">&quot;post-meta-item&quot;</span> title=<span class="string">&quot;&#123;&#123; __(&#x27;post.views&#x27;) &#125;&#125;&quot;</span> id=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> style=<span class="string">&quot;display: none;&quot;</span>&gt;</span><br><span class="line">              <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123; theme.busuanzi_count.post_views_icon &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">              <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>&#123;&#123; __(&#x27;post.views&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">              <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">			</span><br><span class="line">			<span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;post.wordcount&#x27;) &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-file-word-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> &#123;&#123; wordcount(post.content) &#125;&#125; 字 | ≈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">           <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;post.min2read&#x27;) &#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; min2read(post.content) &#125;&#125; 分钟</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">          &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p>修改h1~h5等是在<code>themes\next\source\css\_common\components\post</code>里的post-expand.styl修改，例如给h2添加左边矩形块：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#1eafae</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#1eafae</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="page-页面"><a href="#page-页面" class="headerlink" title="page 页面"></a>page 页面</h4><ul>
<li><p>about 页面，结合md+自定义效果<br>先写md渲染出html，然后在html基础上修改加内容和交互，把文件添加到skip_render名单里。</p>
</li>
<li><p>归档页面最上面一行文本显示</p>
</li>
</ul>
<p>修改<code>\themes\next\layout\archive.swig</code>，并把语言的映射修改一下。</p>
<h3 id="hexo常用命令行"><a href="#hexo常用命令行" class="headerlink" title="hexo常用命令行"></a>hexo常用命令行</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new page paper 新建一个page  about之类的</span><br><span class="line">hexo new newpostname 新建一个post</span><br><span class="line"></span><br><span class="line">hexo clean  清除现有post 简写为 hexo cl</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy   部署文章</span><br><span class="line">hexo s 本地测试运行</span><br><span class="line"></span><br><span class="line">先hexo g 更新之后在hexo s</span><br><span class="line"></span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d  </span><br><span class="line">一键化</span><br><span class="line"></span><br><span class="line">hexo publish draft newpage</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>有什么需求可以关注公众号和我讨论:</p>
<p><img src="/2020/09/22/hexo-personalize-config/lyns-sailing-for-lynsdatasite.png" alt="蛰虫始航"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.libinx.com/2017/2017-03-12-hexo-next-beautify/">Hexo-Next-CSS 样式修改</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>生产力工具</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter notebook文件格式解析与应用</title>
    <url>/2020/09/22/ipynb-format-process.html</url>
    <content><![CDATA[<p>最近遇到一个问题：</p>
<blockquote>
<p>如何合并多个jupyter notebook的笔记为一个笔记文件？</p>
</blockquote>
<p>经常用jupyter notebook写Python代码，看到这个需求不是想去找轮子而是想自己做解析和合并。通过深入文件格式去加深对jupyter notebook的了解。用jb 写代码有很多优势：交互式的编程体验、文档图表整合、扩展性强而且非常容易复现结果。从2017年开始，已有大量的北美顶尖计算机课程，开始完全使用Jupyter Notebook作为工具。如李飞飞的CS231N《计算机视觉与神经网络》课程，在16年时作业还是命令行Python的形式，但是17年的作业就全部在Jupyter Notebook上完成了。因此除了改主题安插件之外，探索更多的Jupyter Notebook用法和原理是有趣有用的。</p>
<a id="more"></a>


<p>用文本编辑器打开一个notebook文件，惊奇地发现不是乱码，说明不是直接存二进制格式而是文本格式，那就不用按数据块去解析了。如下图，熟悉的大括号和键值对让人想到json，仔细看果然是json，那读取就容易了，关键就是各个键的意义和数据组织。</p>
<p><img src="/2020/09/22/ipynb-format-process/00-ipynb%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%95%88%E6%9E%9C-0.png" alt="ipynb文件打开效果"></p>
<h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><p>Jupyter Notebook的文件是通过json格式存储和组织其中的数据的。JSON (JavaScript Object Notation)独立于编程语言，基础的结构就是<code>&#123;键1:值1,键2:值3&#125; </code>这样的字典形式，值可以是数字、字符串、数组和字典。<br>Jupyter Notebook的顶层结构是一个键值对：<br><code>&#123;&quot;metadata&quot;:&#123;&#125;,&quot;nbformat&quot;:4, &quot;nbformat_minor&quot;:0, &quot;cells&quot;:[]  &#125;  </code></p>
<p>我们写代码的一个个格子对应的就在cells里，我们交互产生的数据都记录在cells键对应的列表里，如下图</p>
<p><img src="/2020/09/22/ipynb-format-process/01-%E4%BB%A3%E7%A0%81%E5%9D%97-%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8C%BA%E5%9F%9F-002.PNG" alt="代码块区域示例"></p>
<p>其他的键 像metadata是一些描述性的元数据，因此我们重点关注cells的列表。</p>
<h3 id="内容部分"><a href="#内容部分" class="headerlink" title="内容部分"></a>内容部分</h3><p>我们在里面写代码的一个个小块就是一个个cell，它整体也是一个字典，包含cell_type(内容类型)、source(我们输入的内容)、metadata(描述性的元数据)；这三个键就构成了一个cell。如下面的思维导图，也可以结合上面 代码块区域示例 的图来理解。</p>
<p><img src="/2020/09/22/ipynb-format-process/02-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-01.PNG" alt="基础结构思维导图"></p>
<p>其中execution_count 、output和attachments是不一定每个cell都存在的键，因此做解析是要有判断语句。</p>
<ul>
<li>cell_type有3种选择，code/markdown/raw，下面对这三种类型分别解析。</li>
</ul>
<p>代码块通过cell的cell_type标识<code>&quot;cell_type&quot;=&quot;code&quot;</code></p>
<p><strong>代码块</strong>里装的就是我们写的一行行代码，代码装在source键对应的列表里，source键对应的类型是列表list，列表里是字符串，一行代码是一个字符串。execution_count表示执行次数，对应我们前端能看到的In里的次数。<br>metadata记各种元数据，包括一些插件产生的数据，例如我安装了一个看执行时间的插件ExecuteTime，每次运行可以看执行耗时和最后一次执行的时间，这个数据也是会记录在ipynb文件里，对应的就装在metadata里，如果在一个没安装这个插件的环境里运行就不会读metadata的对应内容，可以说metadata给jupyter提供了很好的扩展性。<br>代码输出的内容在output对应的列表里。output的列表里装的不直接是数值或字符串，而是字典，output_type有多种可能，包括正常的代码输出的stream、execute_result，还有报错输出的error。</p>
<p><strong>Markdown块</strong>是写报告和文档常用的cell，在前端会渲染出很好的效果，因为语义和格式就通过markdown本身约定的格式体现，对应记录的数据比代码块简单。不涉及输出所以不需要有output键，核心就是source和metadata。</p>
<p><strong>无格式块</strong>的官方说法是叫 Raw NBConvert，对应cell_type的值是raw，因为是纯文本效果，在页面上不做特殊渲染，和markdown有的内容基本一致，核心就在source的字符串列表里。</p>
<p>以上内容整理为思维导图如下：</p>
<h3 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h3><p>基于以上我们对jupyter notebook文件结构的了解，就可以开工写合并多个ipynb文件为一个的代码了。<br>假设我们需要合并一个文件夹下的所有ipynb文件为一个，根据文件名的顺序组织。<br>我们首先读取得到需要合并的文件名的列表，然后通过json库读取ipynb文件的内容，因为我们写的代码、文字、代码输出结果这些都在cells里，而且顺序是cells列表里元素的顺序，所以我们合并cells里的内容就实现了这一需求。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">wpt=<span class="string">&#x27;d:/readingForDS/&#x27;</span><span class="comment">#文件所在路径</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(wpt):</span><br><span class="line">    flst=files</span><br><span class="line">flst=[wpt+f <span class="keyword">for</span> f <span class="keyword">in</span> flst <span class="keyword">if</span> f.endswith(<span class="string">&#x27;.ipynb&#x27;</span>)]</span><br><span class="line">jmain=json.load(<span class="built_in">open</span>(flst[<span class="number">0</span>],<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> flst[<span class="number">1</span>:]:</span><br><span class="line">    jn=json.load(<span class="built_in">open</span>(f,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    jmain[<span class="string">&#x27;cells&#x27;</span>].extend(jn[<span class="string">&#x27;cells&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ipynb-combine.ipynb&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> wf:</span><br><span class="line">    json.dump(jmain,wf)<span class="comment">#写入文件</span></span><br></pre></td></tr></table></figure>

<p>因为nbformat等键是通用的，所以代码中直接用了第一个ipynb文件的nbformat值。一个合并的效果如下图（所用ipynb文件在<a href="https://github.com/QLWeilcf/LcfsPythonWork/tree/master/readingForDS">https://github.com/QLWeilcf/LcfsPythonWork/tree/master/readingForDS</a> 里可找到）。</p>
<p>关于合并多个ipynb文件这个需求有一个挺好的轮子是<a href="https://github.com/jbn/nbmerge">https://github.com/jbn/nbmerge</a> 。</p>
<p>同样的思路我们可以根据一些条件对一个大的ipynb文件拆分为多个文件，例如按章拆分一个读书笔记（每个章节的特征是用了markdown语法，如 <code>## 第3章 用Python读写Excel文件</code>）。</p>
<h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>了解了jupyter notebook的文件组织结构之后，除了合并ipynb文件还可以做哪些事情呢？其实我们可以造很多轮子。例如自己实现：</p>
<ul>
<li>导出ipynb文件为py脚本文件：</li>
<li>导出ipynb文件为markdown文件；</li>
<li>导出为HTML文件；</li>
</ul>
<p>导出ipynb文件为py脚本文件的代码示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ipynb 2 py</span></span><br><span class="line">jn_py=[]</span><br><span class="line">jn_py.extend([<span class="string">&#x27;#!/usr/bin/env python&#x27;</span>,<span class="string">&#x27;# coding: utf-8&#x27;</span>])</span><br><span class="line">ja=json.load(<span class="built_in">open</span>(<span class="string">&#x27;ipynb2pdf.ipynb&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> ja[<span class="string">&#x27;cells&#x27;</span>]:</span><br><span class="line">    <span class="keyword">if</span> c[<span class="string">&#x27;cell_type&#x27;</span>]==<span class="string">&#x27;markdown&#x27;</span>:</span><br><span class="line">        jn_py.append(<span class="string">&#x27;\n&#123;0&#125;\n&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;# &#x27;</span>.join(c[<span class="string">&#x27;source&#x27;</span>])))</span><br><span class="line">    <span class="keyword">elif</span> c[<span class="string">&#x27;cell_type&#x27;</span>]==<span class="string">&#x27;code&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> c[<span class="string">&#x27;execution_count&#x27;</span>]==<span class="literal">None</span>:</span><br><span class="line">            jn_py.append(<span class="string">&#x27;# In[ ]:&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            jn_py.append(<span class="string">&#x27;# In[&#123;0&#125;]:&#x27;</span>.<span class="built_in">format</span>(c[<span class="string">&#x27;execution_count&#x27;</span>]))</span><br><span class="line">        jn_py.append(<span class="string">&#x27;&#x27;</span>.join(c[<span class="string">&#x27;source&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> c[<span class="string">&#x27;cell_type&#x27;</span>]==<span class="string">&#x27;raw&#x27;</span>:</span><br><span class="line">        jn_py.append(<span class="string">&#x27;\n&#123;0&#125;\n&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;#&#x27;</span>.join(c[<span class="string">&#x27;source&#x27;</span>])))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ipynb2pdf-c2py.py&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> wf:</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> jn_py:</span><br><span class="line">        wf.write(k+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		</span><br><span class="line"><span class="comment"># ipynb 2 md</span></span><br><span class="line">md_str=<span class="string">&#x27;&#x27;</span> <span class="comment">#两种模式：直接装到一个字符串里或装到列表里，一行是一个字符串</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> ja[<span class="string">&#x27;cells&#x27;</span>]:</span><br><span class="line">    <span class="keyword">if</span> c[<span class="string">&#x27;cell_type&#x27;</span>]==<span class="string">&#x27;markdown&#x27;</span>:</span><br><span class="line">        md_str=md_str+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&#x27;&#x27;</span>.join(c[<span class="string">&#x27;source&#x27;</span>])+<span class="string">&#x27;\n\n&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> c[<span class="string">&#x27;cell_type&#x27;</span>]==<span class="string">&#x27;code&#x27;</span>:</span><br><span class="line">        md_str=md_str+<span class="string">&#x27;\n```python \n&#x27;</span>+<span class="string">&#x27;&#x27;</span>.join(c[<span class="string">&#x27;source&#x27;</span>])+<span class="string">&#x27;\n```\n\n&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(c[<span class="string">&#x27;outputs&#x27;</span>])&gt;<span class="number">0</span>: <span class="comment"># !=[]</span></span><br><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> c[<span class="string">&#x27;outputs&#x27;</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;text/html&#x27;</span> <span class="keyword">in</span> o[<span class="string">&#x27;data&#x27;</span>]: <span class="comment">#keys</span></span><br><span class="line">                    md_str=md_str+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&#x27;&#x27;</span>.join(o[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;text/html&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">&#x27;text/plain&#x27;</span> <span class="keyword">in</span> o[<span class="string">&#x27;data&#x27;</span>]:</span><br><span class="line">                    md_str=md_str+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&#x27;&#x27;</span>.join(o[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;text/plain&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> c[<span class="string">&#x27;cell_type&#x27;</span>]==<span class="string">&#x27;raw&#x27;</span>:</span><br><span class="line">        md_str=md_str+<span class="string">&#x27;\n&#x27;</span>+<span class="string">&#x27;&#x27;</span>.join(c[<span class="string">&#x27;source&#x27;</span>])+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ipynb2pdf-c2md.md&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> wf:</span><br><span class="line">    wf.write(md_str)</span><br></pre></td></tr></table></figure>


<p>【效果对比图】</p>
<p>因为有时候我们在Github上看ipynb格式的资料时，可能会加载不出来渲染的效果，这时候懂得了上面的jupyter notebook的文件组织结构后，我们可以从原始数据大致确定看的ipynb里有那些代码，输出的结果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结这篇文章的内容：</p>
<ul>
<li>Jupyter Notebook有良好的文档图表整合能力和扩展性，已有大量的北美CS课程使用Jupyter Notebook作为编程环境；</li>
<li>.ipynb文件是以json格式组织数据的；我们编写的代码、文本和输出存在cell列表里；</li>
<li>代码的顺序就是cell列表中元素顺序；</li>
<li>基于以上特点我们可以写代码合并和拆分notebook文件，还可实现ipynb文件转换为py、html格式文件。</li>
</ul>
<p>以上内容自己整理了一个xmind脑图，获取思维导图文件和文中示例代码ipynb文件可在公众号后台回复 <strong>jupyter</strong> 获取。</p>
]]></content>
      <categories>
        <category>格式解析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter notebook导出pdf并支持中文</title>
    <url>/2020/09/22/jupyter-notebook-to-pdf-ns.html</url>
    <content><![CDATA[<p><strong>Jupyter Notebook</strong> 是很好的数据科学创作环境，反正我做数据分析的项目或小练习的时候，基本都是在用jupyter notebook（原先是叫ipython notebook，所以现在文件后缀还是.ipynb），以前不怎么用到导出pdf功能，然后要用的时候就遇到很多坑了。jupyter提供导出的格式有.py、.html、.md、.pdf等。</p>
<a id="more"></a>

<p><img src="/2020/09/22/jupyter-notebook-to-pdf-ns/ipynb2pdf-0001.png" alt="jupyter notebook支持的导出格式"></p>
<p>从效果来看，网页中notebook的渲染是最好看的，导出的html对代码和超链接失真严重。在网页上点<em>Download as -&gt; PDF via LaTex</em>的时候先是说缺少Pandoc库，于是pip install pandoc，之后不再说缺少这个库了，而是<br> nbconvert failed: pdflatex not found on PATH 或者 nbconvert failed: PDF creating failed, captured latex output。查了一些资料后改用命令行，要避免*’xelatex’ 不是内部或外部命令，也不是可运行的程序或批处理文件*，需要先安装MiKTeX，在其<a href="https://miktex.org/download">官网下载</a>后，Windows版一路next安装就行，安装包有190MB，安装过程还是耗费些时间的，下载安装完成之后的步骤是：</p>
<h3 id="ipynb文件编译为tex"><a href="#ipynb文件编译为tex" class="headerlink" title="ipynb文件编译为tex"></a>ipynb文件编译为tex</h3><p>在命令行中定位到要转换的jupyter文件的路径下，输入<br> <strong>jupyter nbconvert –to latex yourNotebookName.ipynb</strong></p>
<p><img src="/2020/09/22/jupyter-notebook-to-pdf-ns/ipynb2pdf-0002.png" alt="编译ipynb文件为LaTeX文件"><br>在文件目录下就可以看到一个叫<strong>yourNotebookName.tex</strong>的LaTeX文件了。</p>
<h3 id="手动编辑latex文件"><a href="#手动编辑latex文件" class="headerlink" title="手动编辑latex文件"></a>手动编辑latex文件</h3><p>为了能支持输出中文，需要改一下tex文件，在编辑器（我用的是Notepad++）打开刚才生成的LaTeX文件，<br>在**\documentclass{article}**（没有这一句就在\documentclass[11pt]{ctexart} 的后面插入下面的语句）后面插入</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;fontspec, xunicode, xltxtra&#125;</span><br><span class="line"><span class="keyword">\setmainfont</span>&#123;Microsoft YaHei&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/jupyter-notebook-to-pdf-ns/ipynb2pdf-0003.png" alt="修改latex文件"></p>
<h3 id="转latex为pdf"><a href="#转latex为pdf" class="headerlink" title="转latex为pdf"></a>转latex为pdf</h3><p>随后在命令行下输入：（我演示文件用的是GeoCluster.tex）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xelatex yourNotebookName.tex</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/jupyter-notebook-to-pdf-ns/ipynb2pdf-0004.png" alt="命令行转latex为pdf"><br>之前没有运行过xelatex，首次运行会安装一些依赖文件，会慢一些，最后运行完毕：<br><img src="/2020/09/22/jupyter-notebook-to-pdf-ns/ipynb2pdf-0005.png" alt="运行完xelatex命令"><br>可以在文件夹下看到输出的文件：<br><img src="/2020/09/22/jupyter-notebook-to-pdf-ns/ipynb2pdf-0006.png" alt="最后文件夹下的结果"></p>
<ul>
<li>.ipynb 是我们的jupyter文件</li>
<li>.tex 是由jupyter notebook文件生成的</li>
<li>.pdf 是我们最后的目标文件由.tex文件生成</li>
<li>.log、.out、.aux是LaTex生成pdf的一些输出和日志</li>
</ul>
<p>总结一下，从jupyter notebook生成pdf文件需要的依赖项还是比较多的，Windows下安装MiKTeX才能用xelatex命令。生成步骤是先把ipynb文件编译为LaTex，然后为了支持中文修改一下lex文件，最后转换为pdf文件。 </p>
<p>最后效果如下，虽然还是比不上网页端.ipynb的直接渲染效果，但比起导出的html等格式，更好地作为展示格式。<br><img src="/2020/09/22/jupyter-notebook-to-pdf-ns/ipynb2pdf-0007.png" alt="生成pdf的效果"></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>用可视化地图讲照片的故事(Python+Leaflet)</title>
    <url>/2020/09/26/map-story-proj-photo-in-map.html</url>
    <content><![CDATA[<p>手机和数码相机拍的照片里除了我们能看到的RGB像元数据，还包含了拍摄时间、图像分辨率、感光值、GPS坐标等属性，记录在Exif(<em>Exchangeable image file format</em>)模块里。</p>
<p>随着手机像素越来越高，用手机记录身边的事（和自拍）已经变成很自然的动作，在一年里我们的手机肯定存了很多照片，照片和Exif数据块中的位置可以做哪些有趣的事情？一张图片和对应的拍摄位置如果没那么多可能性，那一系列照片和位置呢？</p>
<a id="more"></a>

<p>我们可以直观看近些年都去了哪里；可以制作和(男/女)朋友一起出去玩的地图故事；可以根据拍照时间和位置动态可视化游览路线；可以基于坐标的聚类整理照片，如拍了800张照片，把每个城市的照片批量整理到各自文件夹；……</p>
<p>地理位置属于个人隐私数据，相关应用需要注意隐私问题，之前挺火的一个谣言是可以根据别人朋友圈发的图知道别人的具体位置，但实际上微信会对朋友圈的图片进行压缩，Exif里的坐标数据是会删除掉的，所以朋友圈的图片是提取不了坐标的。以下实践基于部分自己这些年拍的照片，避免侵犯其他人隐私。</p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/01-%E6%9F%A5%E7%9C%8B%E7%85%A7%E7%89%87%E7%9A%84exif%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF.PNG" alt="查看照片中的Exif信息"></p>
<p>本文主要做的：<strong>批量提照片中的坐标-&gt;可视化照片位置-&gt;制作游历故事地图</strong></p>
<p>所用到的工具：</p>
<ul>
<li>  Python和exifread库</li>
<li>  Leaflet和两个插件</li>
</ul>
<h3 id="1，批量提照片中的坐标"><a href="#1，批量提照片中的坐标" class="headerlink" title="1，批量提照片中的坐标"></a>1，批量提照片中的坐标</h3><p>照片中的地理坐标记录在Exif块里，Exif信息以0xFFE1作为开头标记，采用TIFF格式，可以自己解析或直接用轮子exifread库，exifread是一个很方便使用的读取tiff和jpeg格式图片的Python库，在<a href="https://link.zhihu.com/?target=https://pypi.org/project/ExifRead/">pypi上的介绍</a>是:</p>
<blockquote>
<p>Easy to use Python module to extract Exif metadata from tiff and jpeg files.</p>
</blockquote>
<p>通过 <code>pip install exifread</code>安装后就可以使用了，我们现在只关心照片的坐标和拍摄时间，根据其教程探索参数和用法。</p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/01-%E6%9F%A5%E7%9C%8B%E7%85%A7%E7%89%87%E7%9A%84exif%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF.PNG" alt="exifread库的使用"></p>
<p>写代码提取这部分数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def extractExif(fpath):#提取坐标</span><br><span class="line">    try:</span><br><span class="line">        with open(fpath,&#39;rb&#39;) as rf:</span><br><span class="line">            exif&#x3D;exifread.process_file(rf)</span><br><span class="line">        eDate&#x3D;exif[&#39;EXIF DateTimeOriginal&#39;].printable</span><br><span class="line">        eLon&#x3D;exif[&#39;GPS GPSLongitude&#39;].printable</span><br><span class="line">        eLat&#x3D;exif[&#39;GPS GPSLatitude&#39;].printable</span><br><span class="line">        lon&#x3D;eLon[1:-1].replace(&#39; &#39;,&#39;&#39;).replace(&#39;&#x2F;&#39;,&#39;,&#39;).split(&#39;,&#39;)</span><br><span class="line">        #&#39;[116, 29, 10533&#x2F;500]&#39; to [116,29,10533,500]  type&#x3D;&#x3D;(list)</span><br><span class="line">        lon&#x3D;float(lon[0])+float(lon[1])&#x2F;60+float(lon[2])&#x2F;float(lon[3])&#x2F;3600</span><br><span class="line">        lat&#x3D;eLat[1:-1].replace(&#39; &#39;,&#39;&#39;).replace(&#39;&#x2F;&#39;,&#39;,&#39;).split(&#39;,&#39;)</span><br><span class="line">        lat&#x3D;float(lat[0])+float(lat[1])&#x2F;60+float(lat[2])&#x2F;float(lat[3])&#x2F;3600</span><br><span class="line">        return [lon,lat,eDate]  #经度,纬度,拍摄时间</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e,fpath)</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<p>注意的是如果拍照时没有读取地理位置权限那就不好记录拍照时的坐标了，所以使用时需要做一个判断。调用上面的函数批量取一个文件夹下照片的坐标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpt&#x3D;&#39;J:&#x2F;DS_refine&#x2F;SQL-lyn&#x2F;exifExtract&#x2F;image&#39;</span><br><span class="line">latLons&#x3D;[]</span><br><span class="line">for root, dirs, files in os.walk(wpt):</span><br><span class="line">    print(len(files))</span><br><span class="line">    for f in files:</span><br><span class="line">        exif&#x3D;extractExif(&#39;&#123;0&#125;&#x2F;&#123;1&#125;&#39;.format(wpt,f))</span><br><span class="line">        if exif:</span><br><span class="line">            exif[2]&#x3D;exif[2]+&#39; &#39;+f</span><br><span class="line">            latLons.append(exif)</span><br><span class="line">        else:</span><br><span class="line">            print(f,&#39;exif is None&#39;)</span><br></pre></td></tr></table></figure>

<p>有了照片和对应的位置，可以做可视化讲故事了。下面的实践需要了解一些前端HTML和JavaScript知识。</p>
<h3 id="2，在地图中展示坐标"><a href="#2，在地图中展示坐标" class="headerlink" title="2，在地图中展示坐标"></a>2，在地图中展示坐标</h3><p>直接展示地理点坐标有很多工具，百度/高德地图的API、Echarts、Leaflet、OpenLayers等。</p>
<p>这里用Leaflet框架和 marker-clustering.js 实现坐标点展示和缩小时点聚合的效果，这样能适应各种缩放层级。效果如下：</p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/03-markerClustring-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%88%E6%9E%9C-0.PNG" alt="markerClustring-可视化效果"></p>
<p>实现方式是在前端的html页面里引入 <code>leaflet.js</code>和 <code>leaflet.markercluster-src.js</code>，对map元素进行配置和设置好坐标数据，把html文件配置好之后，把数据写入js文件再调用就好。基于1中提取的坐标，保存为js文件，然后在浏览器打开html文件，就是上图中的效果了。另外需要说明的是，这些标记点(marker)点击之后都是能看到具体的文本的，展示的文本就是title里的内容，是有交互效果的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	var tiles &#x3D; L.tileLayer(&#39;https:&#x2F;&#x2F;&#123;s&#125;.tile.openstreetmap.org&#x2F;&#123;z&#125;&#x2F;&#123;x&#125;&#x2F;&#123;y&#125;.png&#39;, &#123;</span><br><span class="line">		maxZoom: 18,</span><br><span class="line">		attribution: &#39;&amp;copy; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.openstreetmap.org&#x2F;copyright&quot;&gt;OpenStreetMap&lt;&#x2F;a&gt; contributors&#39;</span><br><span class="line">	&#125;),</span><br><span class="line">	latlng &#x3D; L.latLng(37.552897,115.60571); &#x2F;&#x2F;设置地图的坐标中心点</span><br><span class="line">	var map &#x3D; L.map(&#39;map&#39;, &#123;center: latlng, zoom: 5, layers: [tiles]&#125;);</span><br><span class="line">	var markers &#x3D; L.markerClusterGroup();</span><br><span class="line"></span><br><span class="line">	for (var i &#x3D; 0; i &lt; addressPoints.length; i++) &#123;</span><br><span class="line">		var a &#x3D; addressPoints[i];</span><br><span class="line">		var title &#x3D; a[2];</span><br><span class="line">		var marker &#x3D; L.marker(new L.LatLng(a[0], a[1]), &#123; title: title &#125;);</span><br><span class="line">		marker.bindPopup(title);</span><br><span class="line">		markers.addLayer(marker);</span><br><span class="line">	&#125;</span><br><span class="line">	map.addLayer(markers);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/map-story-proj-photo-in-map/03-markerClustring-%E5%8F%AF%E8%A7%86%E5%8C%96-00-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.PNG" alt="所调用文件及结构展示"></p>
<p>而把这些坐标放到百度地图的效果如下：</p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/04-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%88%E6%9E%9C-04.PNG" alt="基于百度地图的点坐标可视化"></p>
<p>坐标多的话就是密密麻麻的红点。</p>
<p><em>注</em>：百度地图中采用的坐标需要是百度坐标系(bd-09)，而我们提取的坐标是GPS坐标，用的是WGS84坐标系，需要做转换，可以调用**<a href="https://link.zhihu.com/?target=https://github.com/QLWeilcf/coordTransform_py">coordTransform_py</a>**进行转换，高德地图采用的是火星坐标系，也需要进行转换。</p>
<p>只是展示坐标不怎么有趣，下面做一个左侧图文描述右侧可视化坐标的效果。</p>
<h3 id="3，游历故事地图"><a href="#3，游历故事地图" class="headerlink" title="3，游历故事地图"></a>3，游历故事地图</h3><p>给那些年去过的地方写一个地图游记。示例效果如下：</p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/05-storymap-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%88%E6%9E%9C-03.PNG" alt="那些年去过的地方"></p>
<p>还是用之前提取的坐标和Leaflet框架。用到的插件是storymap.js，同样引用js之后，改变其中的坐标数据，因为是讲一个故事，具体内容当然按自己想讲述的写，将 <code>&lt;sectiondata-place=&quot;bodo&quot;&gt;</code>中的bodo和js代码中markers里的bodo对应好就好，例如bodo改为beijing。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var markers &#x3D; &#123;</span><br><span class="line">    beijing: &#123;lat:39.886426, lon: 116.404762, zoom: 6&#125;,</span><br><span class="line">    tianjin: &#123;lat:39.134594, lon: 117.191961, zoom: 7&#125;,</span><br><span class="line">    fuyang: &#123;lat:32.645140, lon: 116.268333, zoom: 7&#125;,</span><br><span class="line">    ningbo: &#123;lat:29.763531, lon: 121.898233, zoom: 8&#125;,</span><br><span class="line">    liuzhou: &#123;lat:24.313703, lon: 109.406884, zoom: 7&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4，整合聚类点到游历地图里"><a href="#4，整合聚类点到游历地图里" class="headerlink" title="4，整合聚类点到游历地图里"></a>4，整合聚类点到游历地图里</h3><p>在我们做的游历地图里增加点聚类的效果，一个简单做法是在storymap.js里增加对markercluster.js的调用，从而可以用markerClusterGroup() 重写基本的marker标记点类型。效果如下：</p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/05-storymap-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%88%E6%9E%9C-02.PNG" alt="地图故事效果图"></p>
<p>在html里可以根据自己的想法增加更多的内容，例如具体的地址文本，只需要调用百度/高德地图的Web服务 API中的逆地理编码服务就可以实现，逆地理编码就是指将经纬度转换为详细结构化的地址，如把WGS84坐标系的坐标[116.421046,39.903004]逆地理编码对应北京市东城区北京站。</p>
<p>也可以继续探索更多的Leaflet插件。</p>
<p>另外可以换底图，例如换成Satellite卫星底图，改map初始化时地图瓦片图层的调用url就行 <code>L.tileLayer(&#39;http://&#123;s&#125;.tile.osm.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#39;</code>，效果如下，是不是也很生动呢？</p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/06-%E6%8D%A2%E5%BA%95%E5%9B%BE-01-mapbox.PNG" alt="用Mapbox的Satellite底图的效果1"></p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/06-%E6%8D%A2%E5%BA%95%E5%9B%BE-02-mapbox.PNG" alt="用Mapbox的Satellite底图的效果2"></p>
<p>空间位置可以做很多分析和很多有趣的事情，Python也是很强大的工具，仅需要发挥想象力。</p>
<p>其他可视化形式效果如图：</p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/07-%E5%85%B6%E4%BB%96%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BD%A2%E5%BC%8F-01-%E4%B8%8B%E8%BE%B9%E8%8F%9C%E5%8D%95%E6%A0%8F.PNG" alt="可视化形式之下菜单栏"></p>
<p><img src="/2020/09/26/map-story-proj-photo-in-map/07-%E5%85%B6%E4%BB%96%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BD%A2%E5%BC%8F-02-%E7%85%A7%E7%89%87%E7%9B%B4%E6%8E%A5%E6%98%BE%E7%A4%BA-Leaflet-GeographPhotos.PNG" alt="可视化形式之照片直接显示"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://link.zhihu.com/?target=https://pypi.org/project/ExifRead/">ExifRead</a> ：便捷读取Exif的Python库</li>
<li><a href="https://link.zhihu.com/?target=https://leafletjs.com/">Leaflet</a>：便捷友好的交互地图开源js库</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/Leaflet/Leaflet.markercluster/">markercluster.js</a>：地图标记点聚类库,Leaflet插件</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/atlefren/storymap">storymap.js</a>：地图上的故事,Leaflet插件</li>
</ul>
<p>以上的一些代码同步 更新于<a href="https://link.zhihu.com/?target=https://github.com/QLWeilcf/VisualizedLyn/blob/master/storylineWithCluster">QLWeilcf/VisualizedLyn</a></p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>viz</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python处理PDF_读写批量合并等</title>
    <url>/2020/09/22/python-with-pdf.html</url>
    <content><![CDATA[<p>PDF作为可移植文档格式(Portable Document Format)，在日常生活中经常接触到，最近处理一些数据更是频繁接触一些需要批量处理pdf文件的需求，因此便想整理一下自己实践的用Python处理PDF格式数据的笔记。本文会保持更新。<br>PDF处理的高频需求有：读取、写入、格式转换（pdf提取文本写入txt、根据url写入pdf等）<br>、批处理（多个pdf合并为1个、切分pdf）等等。</p>
<a id="more"></a>

<p>查了下相关资料，Python操作PDF的库有（只是应用的话肯定不至于造轮子从二进制数据开始读）：pdfminer、pdfminer3k、PyPDF、PyPDF2、pdf2htmlex、pdf2image、pdf2xlsx等。<br><img src="/2020/09/22/python-with-pdf/python-with-pdf-01.png" alt="pdf库"></p>
<h3 id="用pdf2合并和切分PDF"><a href="#用pdf2合并和切分PDF" class="headerlink" title="用pdf2合并和切分PDF"></a>用pdf2合并和切分PDF</h3><p>比较几个库之后打算先从PyPDF2快速实现一些功能。其官方文档为<a href="https://pythonhosted.org/PyPDF2/">PyPDF2 Documentation</a>，根据文档，PDF2库包含了 PdfFileReader PdfFileMerger PageObject PdfFileWriter 四个常用的主要的调用类，意思也很明确。<br>先用<code>pip install PyPDF2</code>安装库。</p>
<h4 id="批量合并pdf"><a href="#批量合并pdf" class="headerlink" title="批量合并pdf"></a>批量合并pdf</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfFileReader, PdfFileWriter <span class="comment">#导入需要的类（库）</span></span><br><span class="line">wp=<span class="string">&#x27;D:/doc_of_pdf/&#x27;</span> <span class="comment">#work_path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#合并同一个文件夹下的pdf文件</span></span><br><span class="line">flst=[] <span class="comment">#获得pdf文件路径</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(wp):</span><br><span class="line">    flst=files</span><br><span class="line">flst=[wp+f <span class="keyword">for</span> f <span class="keyword">in</span> flst]</span><br><span class="line">out_pdf=PdfFileWriter()</span><br><span class="line"><span class="keyword">for</span> pf <span class="keyword">in</span> flst:</span><br><span class="line">    in_pdf=PdfFileReader(<span class="built_in">open</span>(pf, <span class="string">&#x27;rb&#x27;</span>)) <span class="comment">#二进制打开</span></span><br><span class="line">    page_count=in_pdf.getNumPages() <span class="comment">#输入pdf的页数</span></span><br><span class="line">    <span class="keyword">for</span> pc <span class="keyword">in</span> <span class="built_in">range</span>(page_count): </span><br><span class="line">        out_pdf.addPage(in_pdf.getPage(pc)) <span class="comment">#逐页循环</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(wp+<span class="string">&#x27;合并笔记_1-3章.pdf&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> wf:</span><br><span class="line">    out_pdf.write(wf)</span><br><span class="line"><span class="comment">#out_pdf.getNumPages()</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/python-with-pdf/python-with-pdf-02.png" alt="执行前后对比"></p>
<h4 id="切分pdf为多个pdf"><a href="#切分pdf为多个pdf" class="headerlink" title="切分pdf为多个pdf"></a>切分pdf为多个pdf</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将一个pdf文件根据一定规则切分为多个</span></span><br><span class="line"></span><br><span class="line">sc_pdf=PdfFileReader(<span class="built_in">open</span>(flst[<span class="number">0</span>], <span class="string">&#x27;rb&#x27;</span>)) <span class="comment">#对第一章笔记进行处理</span></span><br><span class="line">count_sc=sc_pdf.getNumPages()</span><br><span class="line"><span class="comment">#每7页切分为1个PDF文件</span></span><br><span class="line">out_pdf=PdfFileWriter() <span class="comment">#用以输出pdf</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(count_sc):</span><br><span class="line">    <span class="keyword">if</span> c%<span class="number">7</span>==<span class="number">0</span> <span class="keyword">and</span> c&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(wp+<span class="string">&#x27;切分_&#123;0&#125;.pdf&#x27;</span>.<span class="built_in">format</span>(c),<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> wf:</span><br><span class="line">            out_pdf.write(wf)</span><br><span class="line">        out_pdf=PdfFileWriter() <span class="comment">#重建一个空对象</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        out_pdf.addPage(sc_pdf.getPage(c))</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/python-with-pdf/python-with-pdf-03.png" alt="切分测试结果截图"></p>
<p>通过上面的实践，可以看到实现这几个需求高频使用到的方法就是新建一个Reader或Writer对象，通过<code>.getNumPages()</code>获取一共的页码，通过<code>.getPage(page)</code>获取特定页，<code>.addPage()</code>写入页码。</p>
<h2 id="图片转pdf"><a href="#图片转pdf" class="headerlink" title="图片转pdf"></a>图片转pdf</h2><p>需要用到额外的PIL库；处理图片的神器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#单张图片转pdf</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfFileReader, PdfFileWriter</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;D:/docOfStu/pypdf2-mindmap-01.JPG&#x27;</span>)</span><br><span class="line">img.save(<span class="string">&#x27;D:/docOfStu/pypdf2-mindmap-01.pdf&#x27;</span>, <span class="string">&#x27;PDF&#x27;</span>) <span class="comment">#通过PIL库保存为pdf格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多张图片转pdf</span></span><br><span class="line">ilst=[<span class="string">&#x27;D:/docOfStu/pypdf2-mindmap-01.jpg&#x27;</span>,<span class="string">&#x27;D:/docOfStu/pypdf2-mindmap-02.jpg&#x27;</span>] <span class="comment">#图片列表 </span></span><br><span class="line"><span class="comment"># for root, dirs, files in os.walk(wpt): ilst=files  #也可以通过os.walk(wpt) 读取文件夹wpt下所有图片</span></span><br><span class="line">out_pdf=PdfFileWriter()</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> ilst:</span><br><span class="line">    img = Image.<span class="built_in">open</span>(f)</span><br><span class="line">    fw=f.replace(<span class="string">&#x27;.jpg&#x27;</span>,<span class="string">&#x27;.pdf&#x27;</span>)</span><br><span class="line">    img.save(fw)</span><br><span class="line">    out_pdf.appendPagesFromReader(PdfFileReader(<span class="built_in">open</span>(fw,<span class="string">&#x27;rb&#x27;</span>))) <span class="comment">#也可拆这句为 sc_pdf=PdfFileReader(open(fw,&#x27;rb&#x27;)); out_pdf.addPage(sc_pdf.getPage(0))</span></span><br><span class="line">out_pdf.write(<span class="built_in">open</span>(<span class="string">&#x27;D:/docOfStu/pypdf2-mindmap-04.pdf&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/22/python-with-pdf/python-with-pdf-04.png" alt="图片转pdf对比效果"></p>
<p>代码同步更新于：<a href="https://github.com/QLWeilcf/Stack_lcf/blob/master/pdfProccWithpy.ipynb">QLWeilcf_pdfProccWithpy.ipynb</a>。</p>
<hr>
<p>to be continue…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://pythonhosted.org/PyPDF2/">PyPDF2 Documentation</a></li>
<li><a href="https://pypi.org/project/pdfminer/">pdfminer</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python监测电影是否开始预售</title>
    <url>/2020/09/26/spyder-monitor-movies-pre-sales.html</url>
    <content><![CDATA[<p>对于一些大家期待的电影会想值得它什么时候预售，特别是某些热门的电影，若是不及时知道预售开始的消息很可能抢不到好位置的票。对于某部特别热门的电影，有童鞋在朋友圈说不怕期中，4月就怕抢不到某电影首映的票。虽然一些相关的公众号或者微博会在得到消息后及时更新，但是从技术的角度考虑，随着各种集成票务平台的发展，我们可以自己跑个程序监测某些电影是否开启了预售。</p>
<a id="more"></a>

<p>拿看电影的猫眼电影为例，思路就是<strong>先看看开启预售的电影和未开启预售的电影主页间的差别，然后得到需要监测的电影主页的url之后，用爬虫监测页面内容的变化，在确认有购票(预售)信息后及时通知自己</strong>。<br><img src="/2020/09/26/spyder-monitor-movies-pre-sales/spyder-monitor-movies-1.png" alt="未开启预售电影与开启了预售的电影页面的区别"></p>
<p>针对猫眼电影的监测有两种做法，一种是看<em>首页-&gt;即将上映</em>中标注预售的电影列表里是否有目标电影；<br><img src="/2020/09/26/spyder-monitor-movies-pre-sales/spyder-monitor-movies-2.png" alt="对猫眼首页预售电影列表进行监测"></p>
<p>第二种是看目标电影的主页里是否有<strong>购票按钮</strong>，下面主要实现一下第二种思路，自己确实很希望能及时知道《复联四》预售的消息。首先从猫眼电影网页版主页找到目标电影，还是拿《Avengers: Endgame》举例，点击进入主页，复制url，按道理猫眼每部电影主页url是不变的，在网页打开源码定位到“想看、评分”的部分，对应的是<code>&lt;div class=&quot;action-buyBtn&quot;&gt;</code>部分，根据其他开启了预售的电影页面代码，如果开启预售这里会有个购票按钮的，因此主要监测这部分HTML的变化，自己习惯于用xpath，因此复制xpath，写出以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monitorBtnbuy</span>(<span class="params">url,t=<span class="number">0</span></span>):</span><span class="comment">#url:需要监测的电影主页</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#主循环</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            txt=requests.get(url).text</span><br><span class="line">            html=etree.HTML(txt)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ptxt=html.xpath(<span class="string">&#x27;/html/body/div[3]/div/div[2]/div[2]/a/text()&#x27;</span>) <span class="comment">#复制下来的xpath</span></span><br><span class="line">                <span class="keyword">if</span> ptxt==[]: <span class="comment">#如果开启预售ptxt会是[&#x27;特惠购票&#x27;] 否则是空列表</span></span><br><span class="line">                    time.sleep(<span class="number">30</span>) <span class="comment">#sleep一段时间继续爬页面</span></span><br><span class="line">                <span class="keyword">elif</span> ptxt[<span class="number">0</span>]==<span class="string">&#x27;特惠购票&#x27;</span>: <span class="comment">#赶紧想办法提醒自己</span></span><br><span class="line">                    <span class="comment">#可以用各种提醒方式，如print、弹出窗口，发微信消息，发邮件等</span></span><br><span class="line">                    print(<span class="string">&#x27;开启预售了！！&#x27;</span>)</span><br><span class="line">                    <span class="comment">#pass</span></span><br><span class="line">            <span class="keyword">except</span>:<span class="comment">#输出错误信息</span></span><br><span class="line">                traceback.print_exc()</span><br><span class="line">        time.sleep(<span class="number">3</span>) </span><br><span class="line">        t+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> t&gt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">#因为是测试所以加了个break</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">&#x27;https://maoyan.com/films/1156894&#x27;</span> <span class="comment">#</span></span><br><span class="line">monitorBtnbuy(url,t=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>拿一个已经开启预售的电影测试，再拿目标网页进行测试，能正常跑。因为是测试，把sleep的时间调为2秒，测试完之后设置为每15分钟或30分钟获取一下页面。</p>
<p>接下来完善提醒部分，可以用各种提醒方式，如控制台输出、弹出窗口，发微信消息，发邮件等，为了确保我及时知道，选择弹窗+微信消息，Python中写轻量化的GUI页面用内置的tkinter比较方便，微信提醒选择封装比较好的<a href="https://github.com/youfou/wxpy">wxpy</a>。如果页面更新了包含预售消息，会同时有微信消息（我选择是发送到自己的一个群里），然后跑代码的电脑端会有一个弹窗（messagebox）。收到提醒就赶紧去买票。</p>
<p>继续完善<code>monitorBtnbuy(url)</code>函数，最后代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> wxpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOneUrl</span>(<span class="params">url</span>):</span> <span class="comment">#获取一个页面</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        <span class="comment">#r.encoding=r.apparent_encoding</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showMsg</span>():</span></span><br><span class="line">    window = tk.Tk()</span><br><span class="line">    window.title(<span class="string">&#x27;prrrrrr&#x27;</span>)</span><br><span class="line">    window.geometry(<span class="string">&#x27;400x400&#x27;</span>)</span><br><span class="line">    tk.Button(window,text=<span class="string">&#x27;presale&#x27;</span>).pack()</span><br><span class="line">    window.mainloop()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showMsg2</span>():</span></span><br><span class="line">    win = tk.Tk()</span><br><span class="line">    win.title(<span class="string">&#x27;prrrrrr&#x27;</span>)</span><br><span class="line">    win.geometry(<span class="string">&#x27;400x400&#x27;</span>)</span><br><span class="line">    tk.Button(win,text=<span class="string">&#x27;presale&#x27;</span>).pack()</span><br><span class="line">    win.mainloop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monitorBtnbuy</span>(<span class="params">url,t=<span class="number">0</span></span>):</span></span><br><span class="line">    bot = Bot()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        txt=getOneUrl(url)</span><br><span class="line">        <span class="keyword">if</span> txt==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            html=etree.HTML(txt)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ptxt=html.xpath(<span class="string">&#x27;/html/body/div[3]/div/div[2]/div[2]/a/text()&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> ptxt==[]:</span><br><span class="line">                    <span class="keyword">if</span> t%<span class="number">5</span>==<span class="number">0</span>:</span><br><span class="line">                        print(<span class="string">&#x27;现在是&#123;0&#125;,还没有预售信息；t=&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(time.asctime(),t))</span><br><span class="line">                        time.sleep(<span class="number">180</span>)</span><br><span class="line">                    <span class="keyword">if</span> t%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                        time.sleep(<span class="number">60</span>*<span class="number">15</span>) <span class="comment">#每次t是偶数sleep15分钟</span></span><br><span class="line">                    time.sleep(<span class="number">120</span>) <span class="comment">#2mins</span></span><br><span class="line">                <span class="keyword">elif</span> ptxt[<span class="number">0</span>]==<span class="string">&#x27;特惠购票&#x27;</span>: <span class="comment">#赶紧想办法提醒自己</span></span><br><span class="line">                    print(time.asctime(),ptxt[<span class="number">0</span>])</span><br><span class="line">                    group = bot.groups().search(<span class="string">&#x27;def-self&#x27;</span>)[<span class="number">0</span>] <span class="comment">#给特定的群里发消息</span></span><br><span class="line">                    group.send(<span class="string">&#x27;预售开始！&#x27;</span>)</span><br><span class="line">                    group.send(url)</span><br><span class="line">                    print(<span class="string">&#x27;msg.send()&#x27;</span>)</span><br><span class="line">                    showMsg()</span><br><span class="line">                    showMsg2()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                traceback.print_exc()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        t+=<span class="number">1</span></span><br><span class="line">        <span class="comment">#if t&gt;20:break</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">&#x27;https://maoyan.com/films/248172&#x27;</span></span><br><span class="line">monitorBtnbuy(url)</span><br></pre></td></tr></table></figure>
<p>运行效果如下：<br><img src="/2020/09/26/spyder-monitor-movies-pre-sales/spyder-monitor-movies-3.png" alt="监测运行效果"></p>
<p>目前的实现还是有些简单，可以加上更多的监测，例如对淘票票、美团、自己常去电影院的官网等也同时进行监测，万一APP更新了购票入口但网页没有，还需要对APP进行抓包，准确率会更高，更及时。<br>以上代码同步于<a href="https://github.com/QLWeilcf/cunyu/blob/master/moviePresaleMonitor.py">github:moviePresaleMonitor</a>。</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite使用笔记</title>
    <url>/2020/09/22/sql-sqlite-ns.html</url>
    <content><![CDATA[<p>SQL语句顺序： select from left join where group by having order by asc、desc limit</p>
<a id="more"></a>

<p>SQL执行顺序：FROM-&gt;ON-&gt;JOIN-&gt;WHERE-&gt;GROUP BY-&gt;SUM,COUNT函数-&gt;HAVING-&gt;SELECT-&gt;DISTINCT-&gt;ORDER-BY-&gt;LIMIT</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>数独的暴力回溯解法和Python-GUI</title>
    <url>/2020/09/20/sudoku-backtracking.html</url>
    <content><![CDATA[<p>数独起源于18世纪初瑞士数学家欧拉等人研究的拉丁方阵，20世纪70年代，经过美国及日本学者的推广和改良，定名为数独(Sudoku)，大致的意思是“独个的数字”或“只出现一次的数字”。<br>标准的九宫格数独包含9×9个格子，且每3×3的区域组成一宫，数独的规则要求<strong>在空出来的格子里填如1~9的数字，要满足每行、每列和每宫内的数字都不重复</strong>，也就是行、列及宫里都是由不重复的1~9构成。数独还包含了一些6×6、不规则九宫等个性数独，本篇仅讨论标准九宫格数独的情况。</p>
<a id="more"></a>

<p><img src="/2020/09/20/sudoku-backtracking/1-%E5%90%84%E7%A7%8D%E6%95%B0%E7%8B%AC-001.PNG" alt="各种数独"></p>
<p>手动解的技巧有唯余解法、基础排除法、区块排除法、数对唯余法等，进阶的有唯一矩形法、数对占位法、双分支匹配等。<br>【数独示例及手动解法概览】</p>
<p>(数独解法概览来自<a href="https://book.douban.com/subject/30161079" title="标准数独(从入门到精通)">标准数独</a>）<br>用电脑解最通用的还是穷举整个解空间，根据数独规则进行剪枝和回溯。效率和递归深度、需要缓存的中间过程有关，递归深度主要由挖空的个数决定。最简单的穷举算法是对每个单元格都用1~9分别尝试，满足条件继续尝试下一个挖空的格，直到所有单元格都填了合适的数字，且检查符合数独规则就算找到一个解。唯一解要求当前盘面有且只有这一个解。</p>
<p>进一步的做法是为每个挖空的格子维护一个候选数列表，用这个列表中的值进行试数，出现矛盾就回溯，很暴力但其实挺有效的。更高级一点的舞蹈链法及利用模拟退火等方法，也还是离不开试数和回溯的思路。因此下面主要实现的是基于候选数的回溯解法。</p>
<p>首先数独中的数值我们可以用一个一维长度为81的数组表示，也可以用二维9×9的数组表示，下面采用9×9的数组表示，例如一个数独，其盘面用二维数组表示如下：</p>
<p>【图】</p>
<p>回溯的思路是：从第一个挖空的单元格开始，根据其相关20格（本行、本列及所在宫内的单元格）生成候选数列表lst，lst的生成直接地利用了唯余法进行排除，对列表lst中的值进行向下尝试，尝试下一个挖空的单元格，当不满足数独规则时，回退到上一个挖空的单元格。</p>
<p>写成代码如下：</p>
<p>【图】</p>
<p>再把<code>getPrem(x,y,board) </code>及<code>cheackNotSame(x,y,v,board)</code>实现后，就可以变成完整的代码了，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class sovSudoku:  #求解数独</span><br><span class="line">    def __init__(self,board&#x3D;[]):</span><br><span class="line">        self._b&#x3D;board.copy()  #直接写&#x3D;board会直接修改传进来的列表</span><br><span class="line">    def trysxy(self,x,y): #主循环，尝试x，y处的解答</span><br><span class="line">        if self._b[x][y]&#x3D;&#x3D;0: #不等于0的情况在调用外处理</span><br><span class="line">            pv&#x3D;self.getPrem(x,y)</span><br><span class="line">            #for v in range(1,10): #从1到9尝试</span><br><span class="line">            for v in pv:</span><br><span class="line">                self._t+&#x3D;1 #递归次数+1</span><br><span class="line">                if self.checkNotSame(x,y,v):# 符合 行列宫均满足v符合条件 的</span><br><span class="line">                    self._b[x][y]&#x3D;v</span><br><span class="line">                    nx,ny&#x3D;self.getNext(x,y) #得到下一个0值格</span><br><span class="line">                    if nx&#x3D;&#x3D;-1: #没有下一个0格了；and ny&#x3D;&#x3D;-1可以写但没必要</span><br><span class="line">                        return True</span><br><span class="line">                    else:</span><br><span class="line">                        _end&#x3D;self.trysxy(nx,ny) #向下尝试,递归</span><br><span class="line">                        if not _end:</span><br><span class="line">                            self._b[x][y]&#x3D;0 #回溯，继续for v循环</span><br><span class="line">                            #只需要改x，y处的值，不改其他值</span><br><span class="line">                        else:</span><br><span class="line">                            return True</span><br><span class="line">	</span><br><span class="line">    def checkNotSame(self,x,y,val):#检查每行,列及宫内是否有和b[x,y]相同项</span><br><span class="line">        for row_item in self._b[x]: #第x行</span><br><span class="line">            if row_item&#x3D;&#x3D;val:</span><br><span class="line">                return False</span><br><span class="line">        for rows in self._b:#y所在列</span><br><span class="line">            if rows[y]&#x3D;&#x3D;val:</span><br><span class="line">                return False</span><br><span class="line">        ax&#x3D;x&#x2F;&#x2F;3*3 #把0~3中的值映射到[0,3]</span><br><span class="line">        ab&#x3D;y&#x2F;&#x2F;3*3</span><br><span class="line">        for r in range(ax,ax+3):</span><br><span class="line">            for c in range(ab,ab+3):#注意r&#x3D;&#x3D;x &amp; c&#x3D;&#x3D;y的情况下，其实没必要，val不会是0</span><br><span class="line">                if self._b[r][c]&#x3D;&#x3D;val:</span><br><span class="line">                    return False</span><br><span class="line">        return True</span><br><span class="line">    def getNext(self,x,y): #得到下一个未填项,从x,y往下数，值等于0就返回新下标</span><br><span class="line">        for ny in range(y+1,9): #下标是[0,8]</span><br><span class="line">            if self._b[x][ny]&#x3D;&#x3D;0:</span><br><span class="line">                return (x,ny)</span><br><span class="line">        for row in range(x+1,9):</span><br><span class="line">            for ny in range(0,9):</span><br><span class="line">                if self._b[row][ny]&#x3D;&#x3D;0:</span><br><span class="line">                    return (row,ny)</span><br><span class="line">        return (-1,-1) #不存在下一个未填项的情况</span><br><span class="line">    def getPrem(self,x,y): #得到x，y处可以填的值</span><br><span class="line">        prem&#x3D;[]</span><br><span class="line">        rows&#x3D;list(self._b[x])</span><br><span class="line">        rows.extend([self._b[i][y] for i in range(9)])</span><br><span class="line">        cols&#x3D;set(rows)</span><br><span class="line">        for i in range(1,10):</span><br><span class="line">            if i not in cols:</span><br><span class="line">                prem.append(i)</span><br><span class="line">        return prem</span><br><span class="line">    def solve(self):</span><br><span class="line">        #x,y&#x3D;(0,0) if self._b[0][0]&#x3D;&#x3D;0 else self.getNext(0,0)</span><br><span class="line">        if self._b[0][0]&#x3D;&#x3D;0:#更容易理解的写法</span><br><span class="line">            self.trysxy(0,0)</span><br><span class="line">        else:</span><br><span class="line">            x,y&#x3D;self.getNext(0,0)</span><br><span class="line">            self.trysxy(x,y)</span><br><span class="line">			#以下为辅助代码</span><br><span class="line">	def updateSudo(self,cb): #传入一个数独盘面</span><br><span class="line">        if len(cb)&#x3D;&#x3D;9 and len(cb[0])&#x3D;&#x3D;9:</span><br><span class="line">            self._b&#x3D;cb</span><br><span class="line">        else:</span><br><span class="line">            print(&#39;files size not shape&#39;,len(cb),len(cb[0]))</span><br><span class="line">    def __str__(self): #print(sovSudoku)</span><br><span class="line">        return &#39;&#123;0&#125;&#123;1&#125;&#123;2&#125;&#39;.format(&#39;[&#39;,&#39;,\n&#39;.join([str(i) for i in self._b]),&#39;]&#39;)</span><br></pre></td></tr></table></figure>

<p>对于上面的最难数独，在本机上求解效果如下，耗时在秒级，回溯性能也不是很差。<br>【图】</p>
<p>网上再找几个数独进行测试，各自耗时如下：</p>
<p>【图】</p>
<p>在leetcode上有两道数独相关的题目，第37题就是根据输入的数独（用9×9的二维数组表示）求结果。它是用<code>&#39;.&#39;</code>代表挖空，把上面的代码改一下，提交运行的效果如下：</p>
<p>【图】</p>
<p>运行时间在秒级以下，因为回溯会有多次栈调用，内存花费在10多MB。大于平常的一些练习题。</p>
<p>第36题是检查当前盘面的合法性，不考虑该数独能否求解，只需要根据数独规则判断是否满足数独条件，将以上代码修改后提交的结果如下：</p>
<p>【图】</p>
<h3 id="数独游戏GUI"><a href="#数独游戏GUI" class="headerlink" title="数独游戏GUI"></a>数独游戏GUI</h3><p>有了上面的检查数独是否合法以及解数独的代码后，再加上生成数独的代码就可以写一个小游戏训练自己了。81个单元格，假设每次挖掉n 个数字形成一个数独题目，根据排列组合的算法，一共有C(81,n)种挖法。要保证数独有唯一解，则<a href="https://www.ituring.com.cn/book/1605" title="算法的乐趣">至少要保留17个提示数</a>，也就是说n 最多只能是81-17=64。n取1,2这种数也没什么好玩的，只挖一两个空太好解了，因此n应该有个合理的最小值，如果每行挖两个空，那就是18个空，因此n可以取[18,64]，从量级上我们就能看出，就算我们每天接触1万个数独，穷尽一生接触到的数独题目数量也只占冰山一角，因此不需要担心会刷到重复的数独，概率太低。直接随机某个位置随机填入一个数字再随机其他位置来生成数独效率并不高，比较合理的做法是程序内部有几个完整的数独，通过<strong>数字置换</strong>和<strong>随机挖空</strong>来产生新的数独。</p>
<p>考虑数独的特点，如果我们有一个数组[6,8,5,1,9,4,3,2,7]，表示将数独中的数字1变成数字6，把2变成8，以此类推……，类似凯撒加密的做法。由数独的特点可以推出新生成的数独也是符合规则的。</p>
<p>挖空操作就是随机挖去n处的值，再验证是否有唯一解，就可以生成一个数独题目了。</p>
<p>GUI程序的流程还是遵从：</p>
<blockquote>
<p>导入tk库，创建主窗体-&gt;添加控件-&gt;处理交互-&gt;进入主事件循环</p>
</blockquote>
<p>最后实现的GUI如下：</p>
<p>【几个盘面以及交互，初始数独，填写验证，电脑解】</p>
<p>各按钮交互简介：</p>
<ul>
<li>生成数独： 随机生成一个数独；</li>
<li>验证答案： 没填完的情况下，根据当前所填进行验证；填完了，不满足条件则提示，满足说明解答正确，进行弹窗；</li>
<li>电脑解：电脑对当前基础盘面进行计算，把值渲染到数独上（可以对字体、颜色进行进一步个性化）；</li>
<li>清空：把所有值都清空，方便用户输入一个盘面。</li>
</ul>
<p>部分代码如下，继续用内置的tkinter库实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root=tk.Tk()</span><br><span class="line">root.geometry(<span class="string">&#x27;310x350+400+100&#x27;</span>) <span class="comment">#大小和位置</span></span><br><span class="line">root.title(<span class="string">&#x27;Sudoku&#x27;</span>)</span><br><span class="line">btnlst=[] <span class="comment"># 每一个输入框  全局变量</span></span><br><span class="line">evs=[] <span class="comment">#和btnlst对应的变量列表 仅get，set操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initOneSudo</span>(<span class="params">s0</span>):</span> <span class="comment">#根据初始数独和挖空个数，生成一个一维的数独列表</span></span><br><span class="line">    s1=xyTo81(s0) <span class="comment">#s0是二维的</span></span><br><span class="line">    u=randint(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> u!=<span class="number">0</span>:s1=resetsd(s1,u) <span class="comment">#对s1中的数进行“替换加密”</span></span><br><span class="line">    m=randint(<span class="number">18</span>,<span class="number">41</span>) <span class="comment">#挖空个数。目前允许多解</span></span><br><span class="line">    wlst=[] <span class="comment">#挖空位置 </span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(wlst)&lt;m:</span><br><span class="line">        i=randint(<span class="number">0</span>,<span class="number">80</span>)</span><br><span class="line">        <span class="keyword">while</span> i <span class="keyword">in</span> wlst:</span><br><span class="line">            i+=<span class="number">2</span> <span class="comment">#或者这里继续用随机数</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">80</span>:</span><br><span class="line">                i-=<span class="number">30</span></span><br><span class="line">        s1[i]=<span class="number">0</span></span><br><span class="line">        wlst.append(i)</span><br><span class="line">    <span class="keyword">return</span> s1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initSudo</span>(<span class="params">s1,evs</span>):</span></span><br><span class="line">    sk1=xyTo81(s1)</span><br><span class="line">    <span class="keyword">if</span> evs==[]:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">81</span>):</span><br><span class="line">            evs.append(tk.IntVar(root,sk1[j]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">81</span>):</span><br><span class="line">            evs[j].<span class="built_in">set</span>(sk1[j])</span><br><span class="line">    <span class="keyword">return</span> evs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">board</span>):</span></span><br><span class="line">    <span class="keyword">if</span> board[<span class="number">0</span>][<span class="number">0</span>]!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> validCheck(<span class="number">0</span>,<span class="number">0</span>,board)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nx,ny=getNext(<span class="number">0</span>,<span class="number">0</span>,board)</span><br><span class="line">        <span class="keyword">if</span> nx==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> validCheck(nx,ny,board)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validCheck</span>(<span class="params">x,y,b</span>):</span><span class="comment">#检查数独是否合法</span></span><br><span class="line">    v=b[x][y]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span> r!=x:</span><br><span class="line">            <span class="keyword">if</span> b[r][y]==v:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> r!=y:</span><br><span class="line">            <span class="keyword">if</span> b[x][r]==v:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    ax=x//<span class="number">3</span>*<span class="number">3</span></span><br><span class="line">    ab=y//<span class="number">3</span>*<span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(ax,ax+<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(ab,ab+<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> b[r][c]==v <span class="keyword">and</span> r!=x <span class="keyword">and</span> c!=y:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    nx,ny=getNext(x,y,b)</span><br><span class="line">    <span class="keyword">if</span> nx==-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> validCheck(nx,ny,b)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 主函数   s0:内置的基础数独</span></span><br><span class="line">s1=initOneSudo(s0)  <span class="comment">#81</span></span><br><span class="line">s1=nighty2xy(s1,n=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">s1cp=s1.copy()</span><br><span class="line">s2=zeroToNAstr(s1,<span class="number">0</span>) <span class="comment">#9*9</span></span><br><span class="line">evs=initSudo(s2,[])</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span> <span class="comment">#用81个输入框表示每个数独单元格</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span> r&gt;<span class="number">2</span> <span class="keyword">and</span> r&lt;<span class="number">6</span> <span class="keyword">and</span> c&gt;<span class="number">2</span> <span class="keyword">and</span> c&lt;<span class="number">6</span>:</span><br><span class="line">            btnlst.append(tk.Entry(root,textvariable=evs[i],justify=<span class="string">&#x27;center&#x27;</span>))</span><br><span class="line">        <span class="keyword">elif</span> r&gt;<span class="number">2</span> <span class="keyword">and</span> r&lt;<span class="number">6</span>:</span><br><span class="line">            btnlst.append(tk.Entry(root,textvariable=evs[i],justify=<span class="string">&#x27;center&#x27;</span>))</span><br><span class="line">            btnlst[i][<span class="string">&#x27;background&#x27;</span>]=<span class="string">&#x27;#AFEEEE&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> c&gt;<span class="number">2</span> <span class="keyword">and</span> c&lt;<span class="number">6</span>:</span><br><span class="line">            btnlst.append(tk.Entry(root,textvariable=evs[i],justify=<span class="string">&#x27;center&#x27;</span>))</span><br><span class="line">            btnlst[i][<span class="string">&#x27;background&#x27;</span>]=<span class="string">&#x27;#AFEEEE&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            btnlst.append(tk.Entry(root,textvariable=evs[i],justify=<span class="string">&#x27;center&#x27;</span>))</span><br><span class="line">        btnlst[i].place(x=<span class="number">5</span>+c*<span class="number">30</span>,y=<span class="number">0</span>+r*<span class="number">30</span>,width=<span class="number">30</span>,height=<span class="number">30</span>)</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">btnClick</span>(<span class="params">x</span>):</span> <span class="comment">#按钮点击的回调函数</span></span><br><span class="line">    <span class="keyword">global</span> evs,s1,s1cp</span><br><span class="line">    <span class="keyword">if</span> x==<span class="string">&#x27;c&#x27;</span>: <span class="comment">#清空</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">81</span>):</span><br><span class="line">            evs[i].<span class="built_in">set</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> x==<span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        s1=initOneSudo(s0) <span class="comment">#81</span></span><br><span class="line">        s1cp=nighty2xy(s1,n=<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">for</span> k1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">81</span>):</span><br><span class="line">            <span class="keyword">if</span> s1[k1]==<span class="number">0</span>:</span><br><span class="line">                evs[k1].<span class="built_in">set</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                evs[k1].<span class="built_in">set</span>(s1[k1])</span><br><span class="line">    <span class="keyword">elif</span> x==<span class="string">&#x27;m&#x27;</span>: <span class="comment">#电脑解；这里涉及用户输入，确实需要的约束判断挺多的</span></span><br><span class="line">        s5,msg=getSudo(evs,<span class="number">0</span>) <span class="comment">#9*9</span></span><br><span class="line">        <span class="keyword">if</span> msg[<span class="number">0</span>]!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,msg[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">elif</span> msg[<span class="number">1</span>]!=<span class="string">&#x27;&#x27;</span>: <span class="comment">#有空值来验证</span></span><br><span class="line">            s6=s5.copy()</span><br><span class="line">            isvs=isValidSudoku(s6)</span><br><span class="line">            <span class="keyword">if</span> isvs==-<span class="number">1</span>:</span><br><span class="line">                messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;当前盘面为空，请先手动输入一个合法盘面或点生成数独&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> isvs:</span><br><span class="line">                ss=sovSudoku(s1cp)</span><br><span class="line">                ss.solve()</span><br><span class="line">                s3=ss.getSudoku() <span class="comment">#[[1,2],[3,4]]</span></span><br><span class="line">                s4=xyTo81(s3)</span><br><span class="line">                <span class="keyword">for</span> k1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">81</span>): <span class="comment">#从s3写入盘面</span></span><br><span class="line">                    <span class="keyword">if</span> s4[k1]==<span class="number">0</span>:</span><br><span class="line">                        evs[k1].<span class="built_in">set</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        evs[k1].<span class="built_in">set</span>(s4[k1])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;当前盘面包含不满足数独条件的值，请检查&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#填完了的情况</span></span><br><span class="line">            s6=s5.copy()</span><br><span class="line">            isvs=isValidSudoku(s6)</span><br><span class="line">            <span class="keyword">if</span> isvs==-<span class="number">1</span>:</span><br><span class="line">                messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;当前盘面为空，请先手动输入一个合法盘面或点生成数独&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> isvs:</span><br><span class="line">                messagebox.showinfo(<span class="string">&#x27;恭喜&#x27;</span>,<span class="string">&#x27;恭喜，当前数独已解答正确！&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;当前盘面包含不满足数独条件的值，请检查&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> x==<span class="string">&#x27;s&#x27;</span>: <span class="comment">#验证盘面</span></span><br><span class="line">        s5,msg=getSudo(evs,<span class="number">0</span>) <span class="comment">#9*9</span></span><br><span class="line">        <span class="keyword">if</span> msg[<span class="number">0</span>]!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,msg[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">elif</span> msg[<span class="number">1</span>]!=<span class="string">&#x27;&#x27;</span>: <span class="comment">#有空值来验证</span></span><br><span class="line">            s6=s5.copy()</span><br><span class="line">            isvs=isValidSudoku(s6)</span><br><span class="line">            <span class="keyword">if</span> isvs==-<span class="number">1</span>:messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;当前盘面为空，请先手动输入一个合法盘面或点生成数独&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> isvs:messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;当前盘面满足数独条件,请继续作答或选择电脑解答&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;当前盘面包含不满足数独条件的值，请检查&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#填完了的情况</span></span><br><span class="line">            s6=s5.copy()</span><br><span class="line">            isvs=isValidSudoku(s6)</span><br><span class="line">            <span class="keyword">if</span> isvs:messagebox.showinfo(<span class="string">&#x27;恭喜&#x27;</span>,<span class="string">&#x27;恭喜，当前数独已解答正确！&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;当前盘面包含不满足数独条件的值，请检查&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机生成 电脑解 验证答案</span></span><br><span class="line">ranInitBtn=tk.Button(root,text=<span class="string">&#x27;生成数独&#x27;</span>,command=<span class="keyword">lambda</span> x=<span class="string">&#x27;n&#x27;</span>:btnClick(x)) <span class="comment">#new one sudo</span></span><br><span class="line">ranInitBtn.place(x=<span class="number">5</span>,y=<span class="number">310</span>,width=<span class="number">60</span>,height=<span class="number">30</span>)</span><br><span class="line"><span class="comment">#……</span></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>


<h3 id="打包GUI为exe文件"><a href="#打包GUI为exe文件" class="headerlink" title="打包GUI为exe文件"></a>打包GUI为exe文件</h3><p>还是用<code>pyinstaller</code>把程序变成exe可执行文件，大小是8点多M，作为Python导出的exe文件，这个大小是有优势的，结果如下：</p>
<p>【内存大小，图】</p>
<p>本文从解数独的手动解法引入，讲到解数独常用的回溯法，并且按照思路实现回溯代码，通过这一思路去解两个LeetCode题，为了可玩性增加随机生成一个数独的代码，并把以上功能整合为一个GUI程序，用于平时的数独训练，并且把这一GUI脚本打包为一个exe文件，在Windows系统下使用。</p>
]]></content>
      <categories>
        <category>GUI</category>
      </categories>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>用pandas处理时间格式数据</title>
    <url>/2019/09/26/time-format-in-pandas.html</url>
    <content><![CDATA[<p>我们在处理时间相关的数据时有很多库可以用，最常用的还是内置的datetime、time这两个。做数据分析时基本都会导入pandas库，而pandas提供了Timestamp和Timedelta两个也很强大的类，并且在其<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Timestamp.html">官方文档</a>上直接写着对标datetime.datetime，所以就打算深入一下pandas内置的Timestamp的用法，在不导入datetime等库的时候实现对时间相关数据的处理。</p>
<h2 id="Timestamp基本构成"><a href="#Timestamp基本构成" class="headerlink" title="Timestamp基本构成"></a>Timestamp基本构成</h2><a id="more"></a>

<p>根据Timestamp的官方文档，通过<code>pd.Timestamp(&#39;2019-09-26&#39;)</code>和<code>pd.Timestamp(year=2019, month=9, day=26, hour=15)</code>等形式可以得到一个时间戳类型的对象，Timestamp的常用输入参数有：</p>
<ul>
<li>ts_input:要转为时间戳的数据，可以是字符串，整数或小数，int/float类型要和unit搭配着用；</li>
<li>unit：标识ts_input输入int/float到底是距1970-1-1的天数还是秒数还是毫秒数等；</li>
<li>year/month/day/hour/minute/second等：生成特定年月日的时间类型数据，年月日必须要有，否则会报TypeError；</li>
<li>tz：timezone，时区；</li>
</ul>
<p>整理为思维导图如下：</p>
<p><img src="/2019/09/26/time-format-in-pandas/3-timestamp-01.PNG" alt="timestamp"></p>
<p>Timestamp对象常用的属性如下，根据名称都挺容易理解是什么数据</p>
<ul>
<li>.dayofyear：返回这个时间是当年的第几天，1月1号是第1天；如<code>pd.Timestamp(&#39;2019-1-15&#39;).dayofyear</code>返回值是15；类似的属性还有：<em>dayofweek/weekofyear</em>；</li>
<li>.day：时间戳中的天，相当于是本月第几天；类似的属性还有<em>year/month/hour/minute/second/nanosecond/microsecond</em>；</li>
<li>.daysinmonth：本月有多少天，如8月是31天，平年的2月是28天，也可以写做days_in_month；和day属性不一样。</li>
<li>.asm8：把时间戳转成numpy里的datetime64格式；</li>
<li>.value：得到一个距离1970年1月1号的纳秒数值；相当于int(pd.Timestamp(‘%Y-%mm-%dd’).asm8)；</li>
<li>.is_leap_year：是否是闰年，类似的属性有<em>is_month_end/is_quarter_end/is_quarter_start</em>等；</li>
</ul>
<p>整理为思维导图如下：</p>
<p><img src="/2019/09/26/time-format-in-pandas/3-timestamp-02.PNG" alt="timestamp"></p>
<p>Timestamp对象常用的操作方法有：</p>
<ul>
<li>.timestamp()：转换为一个浮点数表示的POSIX时间戳；POSIX时间戳也称Unix时间戳(Unix timestamp)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。和其对应的是fromtimestamp()；如<code>pd.Timestamp.fromtimestamp(1569081600.0) =Timestamp(&#39;2019-09-22 00:00:00&#39;)</code>；</li>
<li>.strftime()：转为特定格式的字符串；如<code>pd.Timestamp(&#39;2019-9-22 14:12:13&#39;).strftime(&#39;%Y/%m/%d&#39;)=&#39;2019/9/22&#39;</code>；</li>
<li>.strptime(string, format)：和strftime()相反，从特定格式字符串转时间戳，<code>pd.Timestamp.strptime(&#39;2019-9-22 14:12:13&#39;,&#39;%Y-%m-%d %H:%M:%S&#39;)</code>；关于各种字母代表哪个个时间元素（如m代表month而M代码minute）看<a href="https://docs.python.org/2/library/datetime.html">datetime的文档</a>；</li>
<li>.date()：把时间戳转为一个日期类型的对象，只有年月日，<code>pd.Timestamp(&#39;2019-9-22 14:12:13&#39;).date()=datetime.date(2019, 9, 22)</code>；</li>
<li>.combine(date, time)：把一个date类型和一个time类型合并为datetime类型；</li>
<li>.to_datetime64()：把时间戳转为一个numpy.datetime64类型；</li>
</ul>
<p>整理的思维导图如下：</p>
<p><img src="/2019/09/26/time-format-in-pandas/3-timestamp-03.PNG" alt="timestamp"></p>
<p>关于pd.Timedelta，时间间隔类型的知识，整理如下：</p>
<p><img src="/2019/09/26/time-format-in-pandas/4-timedelta-01.PNG" alt="timedelta"></p>
<h2 id="需求与应用"><a href="#需求与应用" class="headerlink" title="需求与应用"></a>需求与应用</h2><p>从上面的描述我们可以看到Timestamp是很强大的，和datetime相比也不遑多让。</p>
<p>处理时间序列相关数据的需求主要有：生成时间类型数据、时间间隔计算、时间统计、时间索引、格式化输出。</p>
<p>例如业务中的算注册到首次付费时间、算活动开始到该用户付费时间、算停留时长（从进入页面到退出页面的时间或从打开APP到退出的时间差）、获取当前时间算年龄以进行数据验证等。</p>
<p>下面主要通过一个比较综合的示例整合以上需求：</p>
<blockquote>
<p>假设有某人1年的早午晚餐消费数据(数据已脱敏)，其消费时间的列是一个 ‘2018-12-31 17:03:26’ 这样的字符串；读入DataFrame后需转为Timestamp类型，并根据时间特征标记是早餐还是午餐或晚餐，统计吃早餐天数，看早餐时间分布（箱线图效果）等</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df=pd.read_excel(<span class="string">&#x27;cost-data-2018.xls&#x27;</span>)<span class="comment">#读入数据  #type(df[&#x27;日期&#x27;][0])==&#x27;str&#x27;</span></span><br><span class="line">df[<span class="string">&#x27;消费时间&#x27;</span>]=pd.to_datetime(df[<span class="string">&#x27;日期&#x27;</span>]) </span><br><span class="line">df=df.loc[df[<span class="string">&#x27;子类&#x27;</span>]==<span class="string">&#x27;早午晚餐&#x27;</span>] <span class="comment">#只研究早午晚餐类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eatClassing</span>(<span class="params">x</span>):</span><span class="comment">#早午晚餐分类</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>&lt;=x.hour&lt;<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;早餐&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="number">10</span>&lt;=x.hour&lt;<span class="number">16</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;午餐&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;晚餐&#x27;</span> <span class="comment">#</span></span><br><span class="line">df[<span class="string">&#x27;ecls&#x27;</span>]=df[<span class="string">&#x27;消费时间&#x27;</span>].apply(eatClassing) <span class="comment">#ecls有三种可能：早餐/午餐/晚餐</span></span><br><span class="line"><span class="comment">#2018吃早餐天数</span></span><br><span class="line">df[<span class="string">&#x27;years&#x27;</span>]=df[<span class="string">&#x27;消费时间&#x27;</span>].apply(<span class="keyword">lambda</span> x:x.year)</span><br><span class="line">sdf=df.loc[df[<span class="string">&#x27;years&#x27;</span>]==<span class="number">2018</span>]</span><br><span class="line">dd=<span class="built_in">len</span>(sdf[sdf[<span class="string">&#x27;ecls&#x27;</span>]==<span class="string">&#x27;早餐&#x27;</span>])</span><br><span class="line">ddr=dd/(pd.Timestamp(<span class="string">&#x27;2018-12-31&#x27;</span>)-pd.Timestamp(<span class="string">&#x27;2018-1-1&#x27;</span>)).days <span class="comment">#吃早餐比率</span></span><br><span class="line">print(dd,ddr)</span><br><span class="line"><span class="comment">#绘制吃饭时间分布</span></span><br><span class="line">df[<span class="string">&#x27;tfs&#x27;</span>]=df[<span class="string">&#x27;消费时间&#x27;</span>].apply(<span class="keyword">lambda</span> x:x.hour+x.minute/<span class="number">60</span>+x.second/<span class="number">3600</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制箱线图</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline  <span class="comment">#代码在jupyter notebook里跑，其他环境用plt.show()</span></span><br><span class="line">mor=df.loc[df[<span class="string">&#x27;ecls&#x27;</span>]==<span class="string">&#x27;早餐&#x27;</span>,[<span class="string">&#x27;tfs&#x27;</span>]]</span><br><span class="line">mor.boxplot()</span><br><span class="line"><span class="comment">#同样的方法可以画午餐、晚餐的图：mor1=df.loc[df[&#x27;ecls&#x27;]==&#x27;午餐&#x27;,[&#x27;tfs&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制小提琴图（violinplot）</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">vdf=df.sort_values(by=[<span class="string">&#x27;消费时间&#x27;</span>])</span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&quot;whitegrid&quot;</span>,palette=<span class="string">&quot;pastel&quot;</span>,color_codes=<span class="string">&#x27;ture&#x27;</span>)</span><br><span class="line">k=&#123;<span class="string">&#x27;早餐&#x27;</span>:<span class="string">&#x27;breakfast&#x27;</span>,<span class="string">&#x27;午餐&#x27;</span>:<span class="string">&#x27;lunch&#x27;</span>,<span class="string">&#x27;晚餐&#x27;</span>:<span class="string">&#x27;dinner&#x27;</span>&#125;</span><br><span class="line">vdf[<span class="string">&#x27;eclass&#x27;</span>]=vdf[<span class="string">&#x27;ecls&#x27;</span>].apply(<span class="keyword">lambda</span> x:k[x])</span><br><span class="line">sns.violinplot(x=<span class="string">&quot;eclass&quot;</span>, y=<span class="string">&quot;tfs&quot;</span>, data=vdf, split=<span class="literal">True</span>,inner=<span class="string">&quot;quart&quot;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2019/09/26/time-format-in-pandas/7-%E5%A4%A7%E5%9B%BE%E6%A6%82%E8%A7%88-01.PNG" alt="效果图"></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>Python处理时间数据的另一种选择，在标准库之外|Arrow使用笔记</title>
    <url>/2020/12/09/timeproc-arrow-lynsns.html</url>
    <content><![CDATA[<h2 id="Arrow简介"><a href="#Arrow简介" class="headerlink" title="Arrow简介"></a>Arrow简介</h2><p>Arrow是一个优秀的Python时间处理库，比起Python内置的多个日期时间库，它简化了时间类型数据的解析和输出方法，增强了时间属性的获取能力。经过多年的发展，现在其他有追求的第三方Python时间处理库基本都会对标Arrow，足矣见其影响力。目前Arrow是0.17版，其<a href="https://github.com/arrow-py/arrow">GitHub页面</a> 上有6千多Star，而且保持着活跃的更新，可见其未来会更加强大。</p>
<p><img src="/2020/12/09/timeproc-arrow-lynsns/time-1210-arrow-1-1-xmind.PNG" alt="Arrow概览导图"></p>
<a id="more"></a>

<h2 id="时间数据输入与转换"><a href="#时间数据输入与转换" class="headerlink" title="时间数据输入与转换"></a>时间数据输入与转换</h2><p>从各种输入解析为时间对象是经常面对的需求，Arrow库将数据的输入解析统一封装在arrow.get()函数里，不需要去记time的strptime、gmtime等方法，只要将输入数据传给get，就可以得到一个时间对象，例如<code>dt=arrow.get(&#39;2020-12-07&#39;)</code>。当get()不输入参数时得到的是当前的UTC时间，相当于<code>datetime.utcnow()</code>；get(s)则解析字符串s里的日期要素；get()传入浮点数(float)或int则把输入当成时间戳进行解析；get还可以传入time或datetime的对象，转为arrow的时间对象。<br>arrow的时间对象是封装为自己的自定义类型，要转为datetime的时间对象可以调用<code>dt.datetime</code>，同理要转为时间戳格式使用<code>dt.timestamp</code>，时间戳一般为一个浮点数，表示时间基准点至特定时间dt的总秒数（小数部分对应毫秒等更精细的时间要素），基准点是格林威治时间1970年01月01日00时00分00秒这一时刻，也就是说如果dt是1970年1月1日0时0分0秒，则时间戳的值为0，而小于1970年是负数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> arrow <span class="comment">#Anaconda下已经安装</span></span><br><span class="line">arrow.get(<span class="string">&#x27;2020-12-07 14:20:10&#x27;</span>) <span class="comment">#内置的对象，不是datetime</span></span><br><span class="line"><span class="comment">#Out[]: &lt;Arrow [2020-12-07T14:20:10+00:00]&gt;</span></span><br><span class="line">arrow.now() <span class="comment">#获取当前时间</span></span><br><span class="line">dt=arrow.get(<span class="number">1607334506</span>) <span class="comment">#get可输入Unix时间戳，也可以输入datetime对象</span></span><br><span class="line">dt=arrow.get(datetime(<span class="number">2020</span>,<span class="number">12</span>,<span class="number">7</span>), <span class="string">&#x27;US/Pacific&#x27;</span>)</span><br><span class="line">dt=arrow.get(<span class="string">&#x27;June was born in May 1980&#x27;</span>, <span class="string">&#x27;MMMM YYYY&#x27;</span>)</span><br><span class="line">dt.datetime <span class="comment">#转为dateime类型</span></span><br><span class="line"><span class="comment">#datetime.datetime(2020, 12,...)</span></span><br><span class="line">dt.naive <span class="comment">#转为当地时区的datetime类型</span></span><br><span class="line">dt.year <span class="comment">#dt所在的年，输出 2020</span></span><br><span class="line">dt.floor(<span class="string">&#x27;hour&#x27;</span>) <span class="comment">#从小时处截断，取dt的小时，后面的分钟秒都是0</span></span><br><span class="line"><span class="comment">#&lt;Arrow [2020-12-07T14:00:00+00:00]&gt;</span></span><br><span class="line"><span class="comment">#对应的有 .ceil(&#x27;hour&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>arrow和Python内置的time、datetime库并不割裂，arrow有dt.time、dt.datetime、dt.timestamp将时间数据从Arrow内置对象转为time等库的时间对象，另一方面，从datetime等时间对象转为arrow对象也是容易的，不仅仅是通过<code>get()</code>转换，arrow的range、span_range也支持datetime对象作为参数输入。<br><code>arrow.now()</code> 可以获取当前时间，另外arrow也有<code>.utcnow()</code>获取当前时间UTC(Coordinated Universal Time，世界协调时)时间，在now()函数中可以传入时区 例如写<code>arrow.now(&#39;Asia/Shanghai&#39;)</code>。</p>
<p>要修改时间的某些部分使用replace函数，输入的参数是时间要素的那些属性，如year、month等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d2=d1.replace(hour=<span class="number">3</span>)</span><br><span class="line">d3=d1.shift(weeks=+<span class="number">4</span>) <span class="comment">#当前时间4周后</span></span><br><span class="line">d4=d1.to(<span class="string">&#x27;local&#x27;</span>) <span class="comment">#换时区</span></span><br></pre></td></tr></table></figure>
<p>replace更侧重属性的修改，而shift更多是一种时间偏移的感觉，从当前时间向前或向后偏移一个时间间隔，通常在时间序列的生成中使用到。在转换时区时，除了修改时区的值外，还有一类需求是把当前时间转换为其他时区下的时间，例如dt是北京时间9点，转换成美国东部时间是多少点，这个使用的是<code>dt.to(&#39;US/Eastern&#39;)</code>。</p>
<p>arrow使用format进行格式化，从时间对象转为特定格式的字符串，arrow没有使用strptime的 %Y类型的占位符，而是省略了%号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt.<span class="built_in">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>)</span><br><span class="line"><span class="comment">#&#x27;2020-12-07&#x27;</span></span><br><span class="line">dt.<span class="built_in">format</span>() <span class="comment">#不输入参数其实对应 YYYY-MM-DD HH:mm:ss ZZ</span></span><br><span class="line"><span class="comment">#&#x27;2020-12-07 20:42:18+08:00&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p>arrow可以方便地生成一组时间，和其他数值组合成时间序列，这是datetime等内置库的弱点。通过Arrow.range(frame,start,end)可以生成从start开始，到end结束，按frame为周期重复的一个时间序列，range还支持的参数有<a href="https://arrow.readthedocs.io/en/stable/">tz及limit</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(arrow.Arrow.<span class="built_in">range</span>(<span class="string">&#x27;hour&#x27;</span>,arrow.now(),arrow.now().shift(hours=<span class="number">5</span>)))</span><br><span class="line"><span class="comment">#输出:</span></span><br><span class="line"><span class="comment">#[&lt;Arrow [2020-12-10T20:54:19.878759+08:00]&gt;,&lt;Arrow [2020-12-10T21:54:19.878759+08:00]&gt;,  ...]</span></span><br></pre></td></tr></table></figure>

<p>arrow另一大特色是可以把时间对象转为人类容易理解的自然语言形式进行输出，对应的方法为<code>dt.humanize()</code>，humanize还可以根据locale参数输出特定语言的自然语言，有趣的封装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dt&#x3D;arrow.now().shift(hours&#x3D;-1)</span><br><span class="line">dt.humanize() #当前时间的自然语言表示</span><br><span class="line">#&#39;an hour ago&#39;</span><br><span class="line">future &#x3D;dt.shift(minutes&#x3D;75)</span><br><span class="line">dt.humanize(future, granularity&#x3D;&quot;minute&quot;)</span><br><span class="line">#&#39;in 75 minutes&#39; #两个时间的对比自然语言表示</span><br><span class="line">dt.humanize(locale&#x3D;&#39;ko_kr&#39;) #在韩语里的自然语言</span><br><span class="line">#&#39;2시간 전&#39;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上文可看出，Arrow有着简洁友好的接口，get统筹各种输入的解析，replace负责各种时间要素的修改，format解决各类格式化输出的需求，range处理时间序列生成问题。<br>通过dt.year等很自然地获取时间对象的要素，也提供了dt.time等从Arrow自定义对象转为内置的time、datetime对象。Arrow通过收束接口增强了易用性，满足了大部分时间格式处理的需求，而类似的Pendulum、Maya等时间库在解析字符串及输出自然语言方面更进一步，在一些细节上比Arrow更强一些。</p>
<p><img src="/2020/12/09/timeproc-arrow-lynsns/Arrow-111.png" alt="Arrow整体导图"></p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://github.com/arrow-py/arrow">Arrow GitHub页面</a></li>
<li><a href="https://arrow.readthedocs.io/en/stable/">Arrow 文档</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>设定基准点去时间旅行|Delorean使用笔记</title>
    <url>/2020/12/11/timeproc-delorean-lynsns.html</url>
    <content><![CDATA[<p>Delorean是一个在dateutil基础上进一步拓展的Python时间库，以《回到未来》中的时间旅行车命名。Delorean目前已经发展到<a href="https://delorean.readthedocs.io/en/latest/">1.0版本</a> ，其接口更偏向面向对象的写法，时间戳使用epoch定义，时间对象可以和datetime.timedelta进行计算，Delorean默认都调为UTC时间以避免一些时区的问题，实践代码如下。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> delorean <span class="keyword">import</span> Delorean</span><br><span class="line">dt=Delorean() <span class="comment">#获取当前时间，相当于now</span></span><br><span class="line">d2=dt.replace(hour=<span class="number">8</span>) <span class="comment">#改时间要素的值</span></span><br><span class="line">d=delorean.parse(<span class="string">&#x27;2020/01/01&#x27;</span>)</span><br><span class="line">d2.humanize() <span class="comment">#转时间为自然语言</span></span><br><span class="line"><span class="comment">#&#x27;3 hours ago&#x27;</span></span><br><span class="line">d.datetime.year <span class="comment">#获取年份</span></span><br><span class="line"><span class="comment">#2020</span></span><br><span class="line">d.datetime.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="comment">#转为字符串</span></span><br></pre></td></tr></table></figure>
<p>Delorean的接口也挺简约，处理字符串输入使用parse、时间偏移使用replace，概览的思维导图如下。</p>
<p><img src="/2020/12/11/timeproc-delorean-lynsns/time-1211-delorean-1-1-xmind.PNG" alt="Delorean接口概览"></p>
<h2 id="时间解析与转换"><a href="#时间解析与转换" class="headerlink" title="时间解析与转换"></a>时间解析与转换</h2><p>Delorean有多个接口用于解析和转换其他格式数据为时间对象，解析字符串用parse、处理时间戳用epoch、输入的是datetime对象直接用Delorean()。</p>
<ul>
<li>delorean.parse(text)：从字符串解析时间，例如parse(‘2020/01/01’)；</li>
<li>delorean.epoch(ts)：时间戳转时间对象，例如epoch(1357971038.13)；</li>
<li>Delorean(datetime=dt)：从datetime对象转为Delorean时间对象；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt=delorean.parse(<span class="string">&quot;2020/09/01 00:00:00 +0800&quot;</span>)</span><br><span class="line"><span class="comment">#Delorean(datetime=datetime.datetime(2020,9,1,0,0), timezone=pytz.FixedOffset(480))</span></span><br><span class="line">dt.datetime <span class="comment">#转为datetime类型</span></span><br><span class="line">d.datetime.month <span class="comment">#获取月份</span></span><br><span class="line">dt.next_tuesday() <span class="comment">#dt的下周二对应的时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Delorean时间对象要转为datetime对象使用就写<code>dt.datetime</code>，要获取年月日等时间属性，先转datetime再使用datetime的接口。转换及获取属性的一些方法如下：</p>
<ul>
<li>dt.datetime：转为datetime类型；</li>
<li>dt.date：转为datetime的日期类型，输出例如datetime.date(2020,12,7)；</li>
<li>dt.naive：转为当前时区的时间，输出也是datetime类型；</li>
<li>dt.epoch：转为时间戳；</li>
<li>dt.datetime.strftime(fmt)：转为格式化字符串；</li>
<li>dt.datetime.year：获取时间对象的年份，不支持直接 dt.year；</li>
<li>dt.humanize()：把时间输出为自然语言；</li>
</ul>
<h2 id="时间偏移"><a href="#时间偏移" class="headerlink" title="时间偏移"></a>时间偏移</h2><p>在Delorean里年月日等时间要素的调整接口是replace，而改时区是使用的shift，我觉得整合到一个方法里会更好，其他库如Arrow是这么做的，replace可以改时区。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt.replace(hour=<span class="number">8</span>) <span class="comment">#改时间</span></span><br><span class="line">dt.shift(<span class="string">&#x27;US/Eastern&#x27;</span>) <span class="comment">#改时区</span></span><br><span class="line">dt-dt.replace(hour=<span class="number">1</span>) <span class="comment">#时间间隔</span></span><br><span class="line">dt - timedelta(hours=<span class="number">2</span>) <span class="comment">#两小时之前</span></span><br></pre></td></tr></table></figure>
<p>Delorean时间对象相减得到的是datetime的timedelta类型，故dt也可以直接和datetime的timedelta想加减，说明Delorean时间对象和datetime的兼容性也很高。</p>
<p>【图】</p>
<h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p>Delorean中生成一组时间值使用的是stops，源码里用到了dateutil模块的rrule方法，设定的参数包括：</p>
<ul>
<li>freq：两个时间点之间的时间间隔，声明序列重复的周期；写法是delorean.DAILY、delorean.MONTHLY等</li>
<li>count：生成多少个时间对象；</li>
<li>start：序列第一个时间点的时间，如果不设置则使用当前时间；</li>
<li>stop：序列的结束的时间；</li>
</ul>
<p>Delorean还有range_daily()、range_hourly()等接口，功能类似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(delorean.stops(freq=delorean.DAILY,count=<span class="number">10</span>))</span><br><span class="line"><span class="comment">#Out[]:</span></span><br><span class="line"><span class="comment">#[Delorean(datetime=datetime.datetime(2020, 12, 07, 8, 2, 51), timezone=&#x27;UTC&#x27;),</span></span><br><span class="line"><span class="comment"># Delorean(datetime=datetime.datetime(2020, 12, 08, 8, 2, 51), timezone=&#x27;UTC&#x27;), ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Delorean是个挺全面的时间库，和datetime的协作很方便，但接口有些杂了，不够简洁和成体系，获取属性还需要转为datetime，显得常用的功能却没有优先封装，与Arrow、Pendulum还有些差距，是一个值得了解的Python时间库。Delorean功能的总结思维导图如下。</p>
<p><img src="/2020/12/11/timeproc-delorean-lynsns/Delorean-11.png" alt="Delorean思维导图"></p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://delorean.readthedocs.io/en/latest/">Delorean文档</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>博采众长穿梭时空|Maya库使用笔记</title>
    <url>/2020/12/13/timeproc-maya-lynsns.html</url>
    <content><![CDATA[<h2 id="Maya简介"><a href="#Maya简介" class="headerlink" title="Maya简介"></a>Maya简介</h2><p>用time、datetime等内置库处理时区需要挺多的代码，而且写法很不优雅，Maya是一个不错的第三方时间库，在pytz、pendulum等库基础上增强了对时区的处理。<br>Maya的时间对象是自定义的MayaDT对象，是按时间戳表示的，因此在时区问题上更容易进行转换了。从功能上看，Maya的时间创建能力上排名前列，在时间偏移和属性获取上方面接口也挺简洁，综合来看是不错的Python时间库，在GitHub上<a href="https://github.com/timofurrer/maya">目前有3.2k的star</a> 。</p>
<h2 id="时间输入与转换"><a href="#时间输入与转换" class="headerlink" title="时间输入与转换"></a>时间输入与转换</h2><a id="more"></a>

<p>Maya提供了丰富的接口用于从各种数据中解析出时间对象，既有简约的<code>from_datetime()</code>把datetime对象转为MayaDT时间对象，也有强大的<code>when()</code>和<code>parse()</code>从字符串中解析时间要素。一些示例代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> maya</span><br><span class="line">maya.parse(<span class="string">&#x27;2020-12-08T03:15&#x27;</span>) <span class="comment">#字符串转maya时间对象</span></span><br><span class="line"><span class="comment">#Out[]:&lt;MayaDT epoch=1607397346.636102&gt;</span></span><br><span class="line">maya.when(<span class="string">&#x27;1011-02-07&#x27;</span>) <span class="comment">#因为是用的epoch，小于1970年是负数</span></span><br><span class="line"><span class="comment">#&lt;MayaDT epoch=-30259958400.0&gt;</span></span><br><span class="line">dt=maya.now() <span class="comment">#获取当前时间</span></span><br><span class="line">maya.when(<span class="string">&#x27;tomorrow&#x27;</span>) <span class="comment">#明天的这个时候,直接从自然语言转MayaDT</span></span><br><span class="line">maya.MayaDT.from_datetime(datetime.now()) <span class="comment">#datetime对象转MayaDT</span></span><br><span class="line">maya.MayaDT.from_struct(time.gmtime()) </span><br><span class="line">maya.MayaDT(<span class="number">1606533154</span>) <span class="comment">#时间戳转Maya时间对象</span></span><br><span class="line">dt.day <span class="comment">#获取时间要素属性</span></span><br></pre></td></tr></table></figure>

<p>Maya库记录时间对象是用epoch时间戳，表示的是时间基准点至特定时间dt的总秒数，该基准点在Unix及类Unix系统中是格林威治时间1970年01月01日00时0分0秒，也称为Unix时间戳(Timestamp)。<br>Maya可以充分地把其他基础库的时间对象转为MayaDT对象。<br>另一方面，把一个MayaDT对象转为datetime对象或者转换为字符串也挺简单。</p>
<ul>
<li>dt.datetime()：把dt转为datetime对象；</li>
<li>dt.date：转为datetime库的date对象，也就是只保留年月日，date后面没有小括号；</li>
<li>dt.epoch：输出时间戳；</li>
<li>dt.iso8601()：输出符合<a href="https://help.tableau.com/current/pro/desktop/zh-cn/dates_calendar.htm">ISO-8601标准</a> 的字符串，例如’2020-12-07T00:00:00Z’；对应的还有<code>dt.rfc3339()</code>和<code>dt.rfc2822()</code>；</li>
</ul>
<p>要输出为自定形式的字符串会麻烦一些，没有format方法可以用，需要用maya.Datetime.strftime(dt.datetime(),fmt)进行转换，fmt是time模块所支持的占位字符串，例如’%Y-%m-%d %H:%M:%S’。这里maya.Datetime就是用的datetime库的strftime。</p>
<h2 id="属性获取与特性"><a href="#属性获取与特性" class="headerlink" title="属性获取与特性"></a>属性获取与特性</h2><p>MayaDT展示的虽然是epoch一个浮点数，其获取时间对象的年月日等时间要素的接口并不少，可以很自然地通过<code>dt.day</code>等得到时间要素，和datetime没有隔阂，year、month、second等都有，通过<code>dt.timezone</code>获取时区。其默认的时区是UTC的，其特性是获取属性时是转换为datetime再获取属性的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt=maya.parse(<span class="string">&#x27;2020-12-07&#x27;</span>)</span><br><span class="line">dt.year <span class="comment">#2020</span></span><br><span class="line">dt.timezone <span class="comment">#UTC</span></span><br><span class="line">dt.local_datetime()</span><br><span class="line">dt.local_timezone</span><br><span class="line">dt.iso8601()</span><br><span class="line">dt.slang_time() <span class="comment">#输出为自然语言</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MayaDT</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">year</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.datetime().year</span><br></pre></td></tr></table></figure>

<p>Maya也是支持自然语言的输出的，只需要使用<code>dt.slang_time()</code>，也可以结合时间偏移功能连缀使用。slang是俚语的意思。MayaDT有slang_time和slang_date两个方法可以使用，slang_date更专注在日期维度的表达。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt=maya.when(<span class="string">&#x27;2020, 12, 7&#x27;</span>)</span><br><span class="line">dt.slang_time()</span><br><span class="line"><span class="comment"># &#x27;8 hours ago&#x27;</span></span><br><span class="line">dt.add(days=<span class="number">10</span>).slang_time()</span><br><span class="line"><span class="comment"># &#x27;in 1 week&#x27;</span></span><br><span class="line">dt.snap(<span class="string">&#x27;@d+3h&#x27;</span>).slang_time()</span><br><span class="line"><span class="comment"># &#x27;5 hours ago&#x27;</span></span><br><span class="line">dt.slang_date()</span><br><span class="line"><span class="comment"># &#x27;today&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="时间偏移及序列"><a href="#时间偏移及序列" class="headerlink" title="时间偏移及序列"></a>时间偏移及序列</h2><p>Maya对时间偏移抽象的接口是add和subtract，和其他库接口一致。<code>dt.subtract(days=1)</code>代表dt向前推移1天，输入的参数是years、days这些，数值可以为负数，subtract(days=-1)和add(days=1)效果是一致的。另外一种简写的方法是使用snap，例如<code>dt.snap(&#39;@d+3h&#39;)</code>表示在dt当天的基础上加3个小时，只要符合规则，可以写<code>dt.snap(&quot;+8h@d+1d+11h&quot;)    </code>这类复杂的操作，这三个方法生成的是新对象，不是直接修改原dt对象。<br>Maya的snap方法是调用的snaptime库，具体snap字符串参数的规则可以看<a href="https://github.com/zartstrom/snaptime">snaptime文档</a> 。</p>
<p>Maya要生成一个时间序列可以使用maya.intervals或者MayaInterval类，实例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(maya.intervals(start=maya.now(),</span><br><span class="line">                    end=maya.now().add(days=<span class="number">1</span>),</span><br><span class="line">					interval=<span class="number">60</span>*<span class="number">60</span>))</span><br><span class="line"><span class="comment">#生成start到end的每小时间隔的时间值序列</span></span><br><span class="line"></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> maya.MayaInterval(start=now, end=now.add(hours=<span class="number">1</span>))]</span><br></pre></td></tr></table></figure>
<p>MayaInterval的参数有start、end和duration，duration间隔单位也是秒。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Maya通过把时间统一表示为时间戳避免了各种时区问题，能够达到独立于系统和机器环境，站在datetime、pendulum、snaptime等模块的肩膀上，实现了各种实用的时间计算方法，增强了对时区的处理，在满足基本功能的基础上，别有特色地简化了满足ISO-8601、RFC-2822时间表达字符串的输入输出。</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://github.com/timofurrer/maya">maya github</a></li>
<li><a href="https://help.tableau.com/current/pro/desktop/zh-cn/dates_calendar.htm">ISO-8601标准</a> </li>
<li><a href="https://github.com/zartstrom/snaptime">snaptime文档</a> </li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战Arrow，需要怎样的实力？Pendulum使用笔记</title>
    <url>/2020/12/10/timeproc-pendulum-lynsns.html</url>
    <content><![CDATA[<h2 id="Pendulum简介"><a href="#Pendulum简介" class="headerlink" title="Pendulum简介"></a>Pendulum简介</h2><p>Pendulum是一款很优秀的Python时间处理模块，其内置数据类型拓展自datetime，与datetime有着很好的兼容性。Pendulum比dateutil功能更丰富，足矣和Arrow对标。Pendulum[ˈpendʒələm]意为钟摆，很好的时间意向。Pendulum在时间解析、转换、属性获取、时区、时间序列等方面都有很好的表现，其用于时间处理的语句概览如下。</p>
<p><img src="/2020/12/10/timeproc-pendulum-lynsns/time-1211-pendulum-1-1-xmind.PNG" alt="Pendulum概览导图"></p>
<a id="more"></a>

<h2 id="时间对象生成"><a href="#时间对象生成" class="headerlink" title="时间对象生成"></a>时间对象生成</h2><p>Pendulum内置对象是一个自定义的DateTime对象，但可以当成datetime使用，也就是说dt.year、.strftime()等是完全可以正常使用的，并且Pendulum的一些函数需要输入DateTime作为参数时，输入datetime对象也兼容。<br>Pendulum支持手动输入年月日等属性构建时间对象，也能非常方便地把时间戳或字符串转换为时间对象，一些常用方法如下。</p>
<ul>
<li>pendulum.datetime(2020,5,7)：输入年月日等生成DateTime，对应着datetime.datetime()的写法;</li>
<li>pendulum.now()：获取当前时间，时区直接取当地时区，还有 .today() .tomorrow() .yesterday() 等可以用；</li>
<li>pendulum.local(args)：获取当地时间的对象，可以输入年月日等；</li>
<li>pendulum.parse(text)：从文本中解析出时间对象，有个类似的方法是pendulum.from_format(text,s)；</li>
<li>pendulum.from_timestamp(ts)：把时间戳ts转为时间对象；</li>
<li>pendulum.timezone(“Europe/Paris”)：生成一个时区对象；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pendulum</span><br><span class="line">pendulum.datetime(<span class="number">2020</span>,<span class="number">12</span>,<span class="number">1</span>, tz=<span class="string">&#x27;America/Toronto&#x27;</span>)</span><br><span class="line"><span class="comment">#DateTime(2020,12,1,0,0,0,tzinfo=Timezone(&#x27;America/Toronto&#x27;))</span></span><br><span class="line">dt=pendulum.now()</span><br><span class="line"><span class="comment">#DateTime(2020,12,8,18,0,8,697484,tzinfo=Timezone(&#x27;Asia/Shanghai&#x27;))</span></span><br><span class="line">pendulum.tomorrow() <span class="comment">#明天的这个时候</span></span><br><span class="line">pendulum.parse(<span class="string">&#x27;2020-05-21T22:00:00&#x27;</span>, tz=<span class="string">&#x27;Europe/Paris&#x27;</span>)</span><br><span class="line">pendulum.from_timestamp(<span class="number">1607343278</span>)</span><br></pre></td></tr></table></figure>

<h2 id="要素获取与格式化"><a href="#要素获取与格式化" class="headerlink" title="要素获取与格式化"></a>要素获取与格式化</h2><p>从各种数据格式中解析出时间对象后，获取其日期属性及进行计算是最常见的，和datetime一致，通过<code>dt.year</code>得到对象dt所在年份，这也是很自然的写法，Pendulum有一个特色属性是<code>.age</code>，是对应日期在目前的年龄。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dt=pendulum.now()</span></span><br><span class="line">dt.year <span class="comment"># .month .second 等</span></span><br><span class="line"><span class="comment"># 2020</span></span><br><span class="line">dt.week_of_year <span class="comment">#dt所在周是本年第几周</span></span><br><span class="line">dt.int_timestamp <span class="comment">#把dt表示为整数的timestamp</span></span><br><span class="line"><span class="comment">#还有.float_timestamp可以用</span></span><br><span class="line">dt.age <span class="comment">#dt对应日期目前的年龄</span></span><br></pre></td></tr></table></figure>

<p>将DateTime对象转为字符串既有<code>dt.strftime(fmt)</code>可以用，fmt占位符意义datetime库一致，还有一个和Arrow对标的<code>dt.format(fmt)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"><span class="comment">#&#x27;2020-12-07&#x27;</span></span><br><span class="line">dt.<span class="built_in">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>)</span><br><span class="line"><span class="comment">#&#x27;2020-12-07&#x27;</span></span><br><span class="line">dt.<span class="built_in">format</span>(<span class="string">&#x27;dddd Do [of] MMMM YYYY HH:mm:ss A&#x27;</span>)</span><br><span class="line"><span class="comment">#&#x27;Monday 7th of December 2020 20:20:36 PM&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="时间偏移"><a href="#时间偏移" class="headerlink" title="时间偏移"></a>时间偏移</h2><p>要修改DateTime对象dt的属性使用dt.set()方法，例如修改年份为2019年，是<code>dt.set(year=2019)</code>，这种方法生成的是新的时间对象。要生成一段时间后的时间对象，也可以用dt.add/subtract方法，也就是时间偏移的效果。Pendulum的接口很丰富，修改时间要素还可以使用on和at，例如<code>dt.on(1975).at(22)</code>，on处理年月日，at处理时间的小时分钟和秒。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d2=dt.<span class="built_in">set</span>(year=<span class="number">2019</span>) <span class="comment">#把年份变成2019</span></span><br><span class="line">dt.add(years=-<span class="number">1</span>) <span class="comment">#把时间变成1年前，注意是years不是year</span></span><br><span class="line">dt.subtract(years=<span class="number">1</span>) <span class="comment">#1年前</span></span><br><span class="line">dt.start_of(<span class="string">&#x27;day&#x27;</span>) <span class="comment">#获得当天的0点时间，也即开始时间</span></span><br><span class="line"><span class="comment">#对应的有 dt.end_of(&#x27;day&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>两个时间的时间间隔，在datetime里是timedelta，Pendulum库是抽象为Period。可以直接通过d2-d1生成，或者用diff()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt-dt.<span class="built_in">set</span>(year=<span class="number">2019</span>)</span><br><span class="line"><span class="comment">#&lt;Period [2019-12-11T14:26:54.769932+08:00 -&gt; 2020-12-11T14:26:54.769932+08:00]&gt;</span></span><br><span class="line">p=dt.diff(dt.<span class="built_in">set</span>(year=<span class="number">2019</span>))</span><br><span class="line">p.years  </span><br><span class="line"><span class="comment">#Out[]:1</span></span><br><span class="line">p.in_hours()</span><br><span class="line"><span class="comment"># 8784</span></span><br></pre></td></tr></table></figure>

<p>diff_for_humans方法可以将时间间隔按自然语言输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pendulum.now().diff_for_humans(dt)</span><br><span class="line"><span class="comment">#&#x27;2 minutes after&#x27;</span></span><br><span class="line">dur = pendulum.duration(days=<span class="number">15</span>)</span><br><span class="line">dur.in_words(locale=<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line"><span class="comment">#&#x27;2 weeks 1 day&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p>要生成一个时间序列使用Period和Range结合，先约定序列的开始时间和结束时间，再设定频率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = pendulum.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">end = pendulum.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">period = pendulum.period(start, end)</span><br><span class="line"><span class="built_in">list</span>(period.<span class="built_in">range</span>(<span class="string">&#x27;days&#x27;</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment">#[DateTime(2020, 1, 1, 0, 0, 0, tzinfo=Timezone(&#x27;UTC&#x27;)),</span></span><br><span class="line"><span class="comment"># DateTime(2020, 1, 3, 0, 0, 0, tzinfo=Timezone(&#x27;UTC&#x27;)), ...</span></span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Pendulum是一个能和Arrow对标的时间处理库。Arrow的易用性体现在接口简洁，Pendulum的易用性表现在很多datetime的方法都兼容。Pendulum通过其内置的DateTime对象实现和拓展datetime.datetime的功能，同时封装出Duration、Period及Timezones处理时间偏移、时区、时间序列。Pendulum的官方文档<a href="https://pendulum.eustace.io/">1</a>美观漂亮，而且写得很详细，是非常优秀的文档范例。<br>【整体的xmind】</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://github.com/sdispater/pendulum">Pendulum Github</a>；</li>
<li>[Pendulum <a href="https://pendulum.eustace.io/">doc</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>统计图表的优雅变换:Altair|可视化系列06</title>
    <url>/2020/09/03/viz-altair-stat-datasets-elegant-trans.html</url>
    <content><![CDATA[<h3 id="Altair简介"><a href="#Altair简介" class="headerlink" title="Altair简介"></a>Altair简介</h3><p>Altair是一个强大且简明的声明式统计可视化Python库，它能够快速绘制出各种优雅可交互的统计图表。<br>Altair基于一个前端图表库Vega-Lite，因此绘图的成果也可以通过 <em>chart.to_json()</em> 在前端项目中结合vega库使用。Vega-Lite是一套交互式图形语法，通过简洁的JSON键值对配置快速生成可视化结果，来支持数据分析工作。Altair可读作阿泰尔，天文学中指牵牛星、牛郎星，天鹰座中最明亮的恒星，用这个意象也表达了这个库的野望。</p>
<a id="more"></a>

<p>Altair的语法特点是：建立chart对象后，通过约定是什么图形(点、线、柱或其他)、轴域映射方式、颜色输出可视化图表。理念通关实践去理解，直接看绘图的框架。</p>
<h3 id="基础绘图"><a href="#基础绘图" class="headerlink" title="基础绘图"></a>基础绘图</h3><p>Altair绘图代码框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> altair <span class="keyword">as</span> alt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>:[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>], <span class="string">&#x27;y&#x27;</span>:[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>]&#125;)</span><br><span class="line">alt.Chart(df,width=<span class="number">400</span>,height=<span class="number">300</span>).mark_point().encode(</span><br><span class="line">    x=<span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;y&#x27;</span></span><br><span class="line">).interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/03/viz-altair-stat-datasets-elegant-trans/0-903-06-01-1.png" alt="Altair散点图绘制效果"></p>
<p>从上面的语句能看到的是其写法很像ggplot2、plotnine这类库，建立chart对象再声明图表类型和x、y轴数据映射，并可以用链式写法不断垒个性化配置上去，这也是声明式(declarative)语法的特点。通过 <code>pip install altair</code> 安装好Altair库之后，通过<code>alt.Chart(df,width=400,height=300)</code>创建一个绘图对象，<code>.mark_point()</code>表明是映射为散点图，散点图需要对应的x,y序列坐标，在<code>.encode()</code>里声明，<code>.interactive()</code>让输出的图表有基础的交互功能。</p>
<p><code>.encode()</code>对应的配置参数有：</p>
<ul>
<li>x: x轴的数据，水平方向数据序列；</li>
<li>y: y轴的数据列表，对应竖直方向；</li>
<li>size: 点状类型的半径，或其他类型的长度等；</li>
<li>color: 图形元素的颜色，支持CSS颜色的各种写法，可以是一列也可以是一个16进制的字符串；</li>
<li>opacity: 图元透明度，用的是opacity，不是alpha喔；</li>
<li>shape: 点状元素的形状；</li>
<li>tooltip: 鼠标放到图元上时显示的提示文本列；</li>
<li>order: 声明图层顺序；</li>
</ul>
<p>另外<em>column</em>和<em>row</em>是在分面时用的，根据选定的列进行分面的水平拆分和垂直拆分。<br>Altair更擅长画统计图表，因此下面的案例在数据方面全用数据框(DataFrame)格式进行实践。</p>
<p>同样的数据，同样的列映射到x轴和y轴，encode的写法是一致的，改变图表类型只需要<code>.mark_point</code>变成<code>.mark_line</code>绘制折线图。</p>
<p><img src="/2020/09/03/viz-altair-stat-datasets-elegant-trans/0-905-06-08-altair-mask.PNG" alt="几种mark"></p>
<p>从图中可以看出，Altair有好几种方法绘制出散点图，mark_point()统领散点图，而mark_circle()、mark_square()等和<code>_point()</code>的不同之处在于circle限制了用圆形，而point是可通过size配置形状的。</p>
<p>Altair可以轻松地绘制出折线图及阶梯线图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alt.Chart(df,width=<span class="number">400</span>,height=<span class="number">300</span>).mark_line(color=<span class="string">&#x27;#1EAFAE&#x27;</span>).encode(</span><br><span class="line">    x=<span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;y&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>【Altair绘制折线图】  0-903-06-02-1.PNG</p>
<p>在mark_line里设置interpolate为step-after则折线图变阶梯线图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所用到的数据集</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>:[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;y&#x27;</span>:[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>],</span><br><span class="line">                 <span class="string">&#x27;z&#x27;</span>:[<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>],</span><br><span class="line">                 <span class="string">&#x27;h&#x27;</span>:[<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>],</span><br><span class="line">                 <span class="string">&#x27;k&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]&#125;)</span><br><span class="line">alt.Chart(df).mark_line(interpolate=<span class="string">&#x27;step-after&#x27;</span>).encode(</span><br><span class="line">    x=<span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;y&#x27;</span></span><br><span class="line">) <span class="comment">#阶梯线</span></span><br></pre></td></tr></table></figure>

<p>【添加参数折线图变阶梯线】 0-903-06-03</p>
<p>将mark_line变成mark_bar是绘制柱图，包括柱状图和条形图。只需要互换x和y的映射赋值，可以实现条形图和柱状图的调换。因为默认的柱宽度比较小，画布宽度显得小了，在Chart对象里使用width参数声明图表整体宽度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alt.Chart(df,width=<span class="number">400</span>).mark_bar().encode(</span><br><span class="line">    x=<span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;y&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>【基础柱图  0-905-06-05-altair-1.PNG】</p>
<p>图中一个小细节是<code>Fri.</code>在最前面，因为x轴默认进行了排序，这一点和plotnine很像，要保持原来的<code>[&#39;Mon.&#39;,&#39;Tue.&#39;,...]</code>顺序，需要设置x轴的配置，那如何设置呢？先验知识是，在encode中，最简单的参数写法是<code>.encode(x=&#39;x&#39;)</code>这种传入列名的写法，在Python中，一切皆是对象，Altair关于X轴对象封装为了altair.X()，因此另一种写法是<code>.encode( x= alt.X(&#39;x&#39;))</code>，故在altair.X()里可以设置排序顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alt.Chart(df,width=<span class="number">350</span>).mark_bar(color=<span class="string">&#x27;#1EAFAE&#x27;</span>).encode(</span><br><span class="line">    x=alt.X(<span class="string">&#x27;x&#x27;</span>,sort=<span class="literal">None</span>),</span><br><span class="line">    y=alt.Y(<span class="string">&#x27;y&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>【x轴按默认顺序的柱状图】<br>【0-905-06-06-altair-1.PNG】</p>
<p>alt.X里的sort参数可以取值为”ascending”、”descending”或者None。alt.X对象常用的配置参数还有：title(设置标题)、stack(堆叠图的起始偏移处)、aggregate(数据聚合方式，可以是sum、count、min等)<br>。完整的可视化信息图还需要配置文本标签、图例、标题等，Altair相关的参数也挺容易用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar=alt.Chart(d1,width=<span class="number">400</span>).mark_bar(color=<span class="string">&#x27;#1EAFAE&#x27;</span>).encode(</span><br><span class="line">    x=alt.X(<span class="string">&#x27;x&#x27;</span>,sort=<span class="literal">None</span>,title=<span class="string">&#x27;date&#x27;</span>),</span><br><span class="line">    y=alt.Y(<span class="string">&#x27;y&#x27;</span>,title=<span class="string">&#x27;count&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">t=bar.mark_text(</span><br><span class="line">    baseline=<span class="string">&#x27;top&#x27;</span>,</span><br><span class="line">    ).encode(text=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">(bar+t).properties(</span><br><span class="line">    title=<span class="string">&#x27;weekly ride&#x27;</span></span><br><span class="line">).configure_title(</span><br><span class="line">    fontSize=<span class="number">20</span>,</span><br><span class="line">    anchor=<span class="string">&#x27;middle&#x27;</span>,</span><br><span class="line">    color=<span class="string">&#x27;gray&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Altair还能绘制茎叶图，其他可视化库要绘制茎叶图挺复杂的甚至画不出来，而Altair能优雅画出。<br>【数据列轻松绘茎叶图】</p>
<h3 id="统计制图"><a href="#统计制图" class="headerlink" title="统计制图"></a>统计制图</h3><p>特别能体现Altair优雅的地方在于，x，y的映射可以包含汇总函数，例如对于一个二维的订单表，统计各月份单数绘制为柱状图，只需要把x赋值为<code>month(order_time)</code>，令y的值为<code>count()</code>即可。一个简单的例子如下，可视化展示df表中列k里各元素的出现次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alt.Chart(df,width=<span class="number">300</span>).mark_bar(color=<span class="string">&#x27;#1EAFAE&#x27;</span>).encode(</span><br><span class="line">    x=<span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;count()&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>【在Altair里使用聚合运算】<br>【0-905-07-02-altair-1.PNG】</p>
<p>Altair内置了一些经典的数据科学数据集，封装在vega_datasets里，在使用pip安装Altair时也会同步安装上。下面通过著名的iris鸢尾花数据集展现Altair在统计制图方面的优势。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> vega_datasets <span class="keyword">import</span> data</span><br><span class="line">iris = data.iris() <span class="comment">#使用Altair的内置数据集</span></span><br><span class="line">alt.Chart(iris).mark_bar().encode(</span><br><span class="line">    alt.X(<span class="string">&#x27;sepalWidth:Q&#x27;</span>, <span class="built_in">bin</span>=alt.BinParams(maxbins=<span class="number">20</span>)),</span><br><span class="line">    alt.Y(<span class="string">&#x27;count()&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【绘制iris数据集的花萼宽度直方图】<br>0-905-07-03-altair-1.PNG</p>
<p>在alt.X和alt.Y中，还可以对数据集进行排序和筛选再绘图，很多处理细节都封装好了，调用起来写的语句可以很优雅。<br>通过配置以上提到的各种参数绘制出蝴蝶图，如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left =  alt.Chart(d1,height=<span class="number">230</span>,width=<span class="number">270</span>).encode(</span><br><span class="line">    y=alt.Y(<span class="string">&#x27;x:O&#x27;</span>, axis=<span class="literal">None</span>),</span><br><span class="line">    x=alt.X(<span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">            title=<span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">            sort=alt.SortOrder(<span class="string">&#x27;descending&#x27;</span>))</span><br><span class="line">).mark_bar(color=<span class="string">&#x27;#1EAFAE&#x27;</span>).properties(title=<span class="string">&#x27;Female&#x27;</span>)</span><br><span class="line"></span><br><span class="line">middle =alt.Chart(d1).encode(</span><br><span class="line">    y=alt.Y(<span class="string">&#x27;x&#x27;</span>, axis=<span class="literal">None</span>),</span><br><span class="line">    text=alt.Text(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">).mark_text().properties(height=<span class="number">230</span>,width=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">right = alt.Chart(d1,height=<span class="number">230</span>,width=<span class="number">270</span>).encode(</span><br><span class="line">    y=alt.Y(<span class="string">&#x27;x&#x27;</span>, axis=<span class="literal">None</span>),</span><br><span class="line">    x=alt.X(<span class="string">&#x27;z&#x27;</span>, title=<span class="string">&#x27;pop&#x27;</span>)</span><br><span class="line">).mark_bar(color=<span class="string">&#x27;#FFA069&#x27;</span>,</span><br><span class="line">           cornerRadiusTopRight=<span class="number">5</span>, <span class="comment">#设置圆角矩形</span></span><br><span class="line">           cornerRadiusBottomRight=<span class="number">5</span>).properties(title=<span class="string">&#x27;Male&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alt.concat(left,middle, right, spacing=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>【蝴蝶图】<br>0-905-07-01-altair-1.PNG</p>
<h3 id="分面"><a href="#分面" class="headerlink" title="分面"></a>分面</h3><p>将一系列图排成一横排可以使用concat方法<code>alt.concat(c1,c2)</code>，上图就用到了，或者使用更优雅的<code>c1|c2</code>进行分面，而要实现上下排列的分面，使用<code>c1&amp;c2</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h=alt.Chart(iris,width=<span class="number">300</span>).mark_bar(color=<span class="string">&#x27;#1EAFAE&#x27;</span>).encode(</span><br><span class="line">    alt.X(<span class="string">&#x27;sepalWidth:Q&#x27;</span>, <span class="built_in">bin</span>=alt.BinParams(maxbins=<span class="number">20</span>)),</span><br><span class="line">    alt.Y(<span class="string">&#x27;count()&#x27;</span>)</span><br><span class="line">).interactive()</span><br><span class="line">box=alt.Chart(iris,width=<span class="number">300</span>).mark_boxplot(color=<span class="string">&#x27;#1EAFAE&#x27;</span>).encode(</span><br><span class="line">    x=<span class="string">&#x27;species&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;petalLength&#x27;</span></span><br><span class="line">).interactive()</span><br><span class="line"></span><br><span class="line">h|box <span class="comment">#横向排列</span></span><br><span class="line"><span class="comment"># h &amp; box #上下排列</span></span><br></pre></td></tr></table></figure>

<p>【横向排列分面】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = data.cars()</span><br><span class="line"></span><br><span class="line">alt.Chart(df.mark_circle().encode(</span><br><span class="line">    alt.X(alt.repeat(<span class="string">&quot;column&quot;</span>), <span class="built_in">type</span>=<span class="string">&#x27;quantitative&#x27;</span>),</span><br><span class="line">    alt.Y(alt.repeat(<span class="string">&quot;row&quot;</span>), <span class="built_in">type</span>=<span class="string">&#x27;quantitative&#x27;</span>),</span><br><span class="line">    color=<span class="string">&#x27;Origin:N&#x27;</span></span><br><span class="line">).properties(</span><br><span class="line">    width=<span class="number">100</span>,</span><br><span class="line">    height=<span class="number">100</span></span><br><span class="line">).repeat(</span><br><span class="line">    row=[<span class="string">&#x27;Horsepower&#x27;</span>, <span class="string">&#x27;Acceleration&#x27;</span>, <span class="string">&#x27;Miles_per_Gallon&#x27;</span>],</span><br><span class="line">    column=[<span class="string">&#x27;Miles_per_Gallon&#x27;</span>, <span class="string">&#x27;Acceleration&#x27;</span>, <span class="string">&#x27;Horsepower&#x27;</span>]</span><br><span class="line">).interactive()</span><br></pre></td></tr></table></figure>

<p>【一个挺完整的分面图】<br>【0-903-06-06-2.PNG】</p>
<p>除了对图表进行分面排列外，<br>组合多种类型的图到一个坐标系里也很重要。 在Altair中，<code>|</code>和<code>&amp;</code>用于分面，而<code>+</code>号用于把多个图表对象(alt.Chart)组合在一个坐标系里，组合图有两种写法，写法1是从头新建多个图表对象，最后用+号连接，写法2是公用一些配置，通过<code>bar.mark_circle()</code>覆盖掉原先的<code>mark_x</code>形成新的对象，再通过+号连接，这种写法通过公用一些属性再覆盖图的类型简化代码，两种写法的例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar= alt.Chart(d3).mark_bar(height=<span class="number">2</span>).encode(x=<span class="string">&#x27;y&#x27;</span>,y=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">point = alt.Chart(d2).mark_point(filled=<span class="literal">True</span>).encode(x=<span class="string">&#x27;y&#x27;</span>,y=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">bar + point  <span class="comment"># 写法1</span></span><br><span class="line"><span class="comment"># 写法2</span></span><br><span class="line">bar= alt.Chart(d3).mark_bar(height=<span class="number">2</span>).encode(x=<span class="string">&#x27;y&#x27;</span>,y=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">bar + bar.mark_circle()</span><br></pre></td></tr></table></figure>

<p>【组合绘制棒棒糖图】<br>0-905-07-06-altair-1</p>
<p>要让Altair绘制的图具有交互性是很容易的（交互的细节都封装了，直接调用高差的方法就行），通过给图表对象加上<code>.interactive()</code> 便可获得基础的缩放和拖拽交互。而且在分面图里使用interactive之后，对其中的子图进行缩放，其他图也会联动缩放，非常实用。一些深入的交互功能可以通过封装的<code>chart.add_selection()</code>、<code>alt.selection_multi()</code>和<code>.transform_filter()</code>等实现。一些细节是，在Altair中，散点图的交互，只有y轴缩放，x轴不变，而柱状图xy都会缩放，直方图则是只在x轴缩放，挺有趣的。</p>
<h3 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h3><p>一个成熟的可视化库都应该有定制主题进行颜色、图元的配置。在Altair中，定制主题的写法如下，很像直接写一个json对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lyns_marks</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;config&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;view&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;height&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">                <span class="string">&#x27;width&#x27;</span>: <span class="number">400</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;mark&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;#1eafae&#x27;</span>,</span><br><span class="line">                <span class="comment">#&#x27;fill&#x27;:&#x27;#1eafae&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">alt.themes.register(<span class="string">&#x27;lyns_theme&#x27;</span>,lyns_marks)</span><br><span class="line"></span><br><span class="line">alt.themes.enable(<span class="string">&#x27;lyns_theme&#x27;</span>) <span class="comment">#使用该主题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Altair也支持地理信息的可视化，用Altair库画地图的示例代码如下，为了方便和容易复现，继续使用vega_datasets里的数据集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sphere = alt.sphere()</span><br><span class="line">graticule = alt.graticule()</span><br><span class="line">world=data.world_110m.url</span><br><span class="line">source = alt.topo_feature(world, <span class="string">&#x27;countries&#x27;</span>)</span><br><span class="line">alt.layer(</span><br><span class="line">    alt.Chart(sphere).mark_geoshape(fill=<span class="string">&#x27;lightblue&#x27;</span>),</span><br><span class="line">    alt.Chart(graticule).mark_geoshape(stroke=<span class="string">&#x27;white&#x27;</span>, strokeWidth=<span class="number">0.5</span>),</span><br><span class="line">    alt.Chart(source).mark_geoshape(fill=<span class="string">&#x27;#1eafae&#x27;</span>, stroke=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">).project(<span class="string">&#x27;naturalEarth1&#x27;</span></span><br><span class="line">).properties(width=<span class="number">600</span>, height=<span class="number">400</span>).configure_view(stroke=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>【Altair绘制世界地图】<br>0-905-07-08-altair-1.PNG</p>
<p>将绘制的图表保存到本地可以用<code>bar.save(&#39;altair_bar.html&#39;)</code>保存为HTML文档，保留着交互功能，要直接保存为PNG图片或PDF需要再安装一个altair_saver包，再调用<code>bar.save(&#39;altair_bar.png&#39;)</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Altair是一个语法挺简洁、功能挺强大的Python可视化库，它封装了很多实用的方法用于统计数据的可视化，能用优雅的语法方便地对二维表格数据(代表格式是pandas的DataFrame)进行筛选分组汇总映射为各种图表类型，配置各种图元参数也很便捷，对地理空间数据支持也不错。可惜的是目前还没有支持饼图这一图表类型。<br>Altair基于Vega-lite套件封装的可视化功能，再底层是D3。在Vega体系里，封装的Python可视化库还有vincent及PdVega等。其中<a href="https://github.com/wrobstory/vincent">vincent</a>在2016年之后就不再更新，其github页面上建议去了解Altair。而<a href="https://altair-viz.github.io/pdvega/">PdVega</a>本身就和Altair关系密切，其文档的地址就是altair-viz.github.io/pdvega，很能说明问题，当然这两个库是差异化发展的，PdVega的特点是针对Jypyter Notebook环境进行了针对性的适配，并且API向pandas内置的plotting看齐。</p>
<p>在公众号后台回复 <strong>Altair</strong> 获取本文的xmind笔记和ipynb代码文件。<br>【Altair库思维导图 Altair可视化XMIND】</p>
<p>最后，用Altair绘制一个Altair的icon；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d3=pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>:[<span class="number">0</span>,<span class="number">10.1</span>],<span class="string">&#x27;b&#x27;</span>:[<span class="number">0</span>,<span class="number">100.2</span>]&#125;)</span><br><span class="line">d4=pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>:[<span class="number">10</span>,<span class="number">20</span>],<span class="string">&#x27;b&#x27;</span>:[<span class="number">100</span>,<span class="number">100</span>]&#125;)</span><br><span class="line">d5=pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>:[<span class="number">18</span>,<span class="number">28</span>],<span class="string">&#x27;b&#x27;</span>:[<span class="number">70</span>,<span class="number">70</span>]&#125;)</span><br><span class="line">d6=pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>:[<span class="number">26</span>,<span class="number">36</span>],<span class="string">&#x27;b&#x27;</span>:[<span class="number">40</span>,<span class="number">40</span>]&#125;)</span><br><span class="line">a1=alt.Chart(d3).mark_area(color=<span class="string">&#x27;#FBC02D&#x27;</span>).encode(</span><br><span class="line">    x=<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;b&#x27;</span></span><br><span class="line">).interactive()</span><br><span class="line">a2=alt.Chart(d4).mark_area(color=<span class="string">&#x27;#03A9F4&#x27;</span>).encode(</span><br><span class="line">    x=<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;b&#x27;</span></span><br><span class="line">).interactive()</span><br><span class="line">a3=alt.Chart(d5).mark_area(color=<span class="string">&#x27;#4FC3F7&#x27;</span>).encode(</span><br><span class="line">    x=<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;b&#x27;</span></span><br><span class="line">).interactive()</span><br><span class="line">a4=alt.Chart(d6).mark_area(color=<span class="string">&#x27;#B3E5FC&#x27;</span>).encode(</span><br><span class="line">    x=<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;b&#x27;</span></span><br><span class="line">).interactive()</span><br><span class="line">a5=a1+a2+a3+a4</span><br><span class="line">a5.configure_axis(grid=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>【动图，gif 序列 01-2185-1】</p>
<p>参考资料：</p>
<ul>
<li><a href="https://altair-viz.github.io/">Altair官网</a></li>
<li><a href="https://github.com/uwdata/visualization-curriculum">notebook上的Altair教程</a></li>
<li><a href="https://github.com/wrobstory/vincent">vincent</a></li>
<li><a href="https://altair-viz.github.io/pdvega/">PdVega</a></li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>viz</tag>
      </tags>
  </entry>
  <entry>
    <title>基于图形语法的声明式可视化框架:bqplot</title>
    <url>/2020/09/28/viz-bqplot.html</url>
    <content><![CDATA[<h3 id="bqplot简介"><a href="#bqplot简介" class="headerlink" title="bqplot简介"></a>bqplot简介</h3><p>官方文档简介是 一个jupyter notebook上的基于图形语法的声明式可视化框架<br>该库的目标是提供一套框架统一的二维可视化API，并且提供合理的交互接口。</p>
<p>和numpy的配合挺好的，pandas的一列也可以直接用</p>
<a id="more"></a>


<p>通过pip安装bqplot库之后，需要通过以下语句设置jupyter插件对bqplot，否则可能出不了图。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">jupyter nbextension enable --py --sys-prefix bqplot</span><br></pre></td></tr></table></figure>

<p>绘图框架</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bqplot <span class="keyword">import</span> Bars, Figure,LinearScale</span><br><span class="line"></span><br><span class="line">bar = Bars(x=df[<span class="string">&#x27;x&#x27;</span>],y=df[<span class="string">&#x27;y&#x27;</span>],scales=&#123;<span class="string">&#x27;x&#x27;</span>:LinearScale(), <span class="string">&#x27;y&#x27;</span>:LinearScale()&#125;)</span><br><span class="line">Figure(marks=[bar])</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/28/viz-bqplot/0-908-14-01-1-bqplot-line.png" alt="bqplot-line"></p>
<p>默认是折线；<br>有交互，可以放大缩小漫游，交互控件。</p>
<p>在语句组织方面，也可以先建立一个画布，往上加元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bqplot <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure(title=<span class="string">&#x27;bqplot 散点图&#x27;</span>)</span><br><span class="line">scc= plt.scatter(x, y)</span><br><span class="line">scc.colors = [<span class="string">&#x27;Red&#x27;</span>]  <span class="comment">#设置散点颜色</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>通过<code>scc.y =df[&#39;z&#39;]</code>可以更新y轴的数据，刷新显示的图。</p>
<p>scatter_plot.marker = ‘diamond’</p>
<p>Pyplot 的语法</p>
<p>the Grammar of Graphics paradigm 图形语法范式<br>有两套API接口，一套是上面用到的神似mat的写法，另一套属于pyplot的语法</p>
<p>The other one, the verbose API, is meant to expose every element of a plot individually,<br>冗长的语法，可以逐个操作图形中的每个元素；to build complex and feature-rich GUIs<br>o understand this verbose API, it helps to revisit what exactly the components of a plot are.  重新认识一张图的组成，首先是scale<br>A Scale is a mapping from (function that converts) data coordinates to figure coordinates.<br>比例尺，一个把数据从数据坐标系转换到图形元素坐标系  的映射<br>Scale takes a set of values in any arbitrary unit (say number of people, or $, or litres) and converts it to pixels (or colors for a ColorScale).<br>例如：一串数值到像素多少，颜色值到颜色</p>
<p>要完整画一条曲线（一些注释发文的时候删掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_sc = bqplot.OrdinalScale()</span><br><span class="line">y_sc = LinearScale(<span class="built_in">min</span>=<span class="number">0</span>,<span class="built_in">max</span>=<span class="number">100</span>)  <span class="comment">#没影响min()函数的使用</span></span><br><span class="line">x_data =z</span><br><span class="line">y_data =y</span><br><span class="line">ax_x = Axis(label=<span class="string">&#x27;X&#x27;</span>, scale=x_sc)  <span class="comment">#axis里是scale，lines里是scales</span></span><br><span class="line">ax_y = Axis(label=<span class="string">&#x27;Y&#x27;</span>, scale=y_sc,orientation=<span class="string">&#x27;vertical&#x27;</span>) <span class="comment">#需要指定orientation，否则都叠加在横轴</span></span><br><span class="line"></span><br><span class="line">line= Lines(x=x, y=y, scales=&#123;<span class="string">&#x27;x&#x27;</span>:x_sc, <span class="string">&#x27;y&#x27;</span>:y_sc&#125;)</span><br><span class="line">fig = Figure(marks=[line], title=<span class="string">&#x27;bqplot 折线&#x27;</span>,</span><br><span class="line">             axes=[ax_x,</span><br><span class="line">                   ax_y])</span><br><span class="line">line.colors=[<span class="string">&#x27;#1EAFAE&#x27;</span>]</span><br><span class="line">display(fig)</span><br></pre></td></tr></table></figure>



<p><img src="/2020/09/28/viz-bqplot/0-908-14-01-2-bqplot-line.png" alt="bqplot折线图优化属性"></p>
<p>建立画布，要初始化比例尺、坐标轴，<br>需要指定orientation，否则都叠加在横轴<br>axes_options 设置xz y轴标签属性<br>axes_options = {‘x’: {‘label’: ‘Date’, ‘tick_format’: ‘%m/%d’},<br>                ‘y’: {‘label’: ‘Price’, ‘tick_format’: ‘0.0f’}}<br>fig = plt.figure(title=’Changing Styles’, background_style={‘fill’: ‘lightgreen’},<br>                 title_style={‘font-size’: ‘20px’,’fill’: ‘DarkOrange’})                </p>
<p>plt.scatter(x, y)</p>
<p>绘制柱状图</p>
<p>其他是 from bqplot import Bars<br>注意是bars不是bar，从接口来看属于bqplot.marks.Bars<br>plt.bar()也可以；也是可以用bar.stroke = ‘red’ 设置样式？两套语法这个是通用的？<br>堆叠柱</p>
<p>每个柱颜色不同，能画条形图么？可以<br>orientation=’vertical’<br>条形图，标签是从下往上的；</p>
<p>color_mode 参数</p>
<h2 id="Color-mode-has-2-values-‘group’-and-‘element’"><a href="#Color-mode-has-2-values-‘group’-and-‘element’" class="headerlink" title="Color mode has 2 values. ‘group’ and ‘element’."></a>Color mode has 2 values. ‘group’ and ‘element’.</h2><h2 id="‘group’-means-for-every-x-all-bars-have-same-color"><a href="#‘group’-means-for-every-x-all-bars-have-same-color" class="headerlink" title="‘group’ means for every x all bars have same color."></a>‘group’ means for every x all bars have same color.</h2><h2 id="‘element’-means-for-every-dimension-of-y-all-bars-have-same-color"><a href="#‘element’-means-for-every-dimension-of-y-all-bars-have-same-color" class="headerlink" title="‘element’ means for every dimension of y, all bars have same color."></a>‘element’ means for every dimension of y, all bars have same color.</h2><p>默认是auto，<br>基础图</p>
<p>标签是一个独立的图层</p>
<p>加文本标签，加一个bar_label图层</p>
<p>饼图-基础饼图-更新数据效果-排序效果-变成环状图效果</p>
<p>可以扔一个动图里</p>
<p>Object Model 是<br>pie = Pie(sizes=data<br>Figure(marks=[pie]<br>的写法<br>fig = plt.figure(animation_duration=1000)<br>pie = plt.pie(df[‘y’], display_labels=’outside’,labels=df[‘y’])<br>fig<br>是pyplot的写法；</p>
<p>The ‘labels’ trait of a Pie instance must be a list but a value of class ‘pandas.core.series.Series’<br>Element of the ‘labels’ trait of a Pie instance must be a unicode string, but a value of 76 &lt;class ‘int’&gt; was specified.</p>
<p>复合图</p>
<p>marks=[bar,line]</p>
<p>分面之类的呢？<br>文档里根本收不到facet</p>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>scatter_chart.selected = [1, 2, 3]<br>使图形有选中的效果</p>
<p>增加事件监听：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">change</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;This is a trait change. Foo was called by the fact that we moved the Scatter&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;In fact, the Scatter plot sent us all the new data: &#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;To access the data, try modifying the function and printing the data variable&#x27;</span>)</span><br><span class="line">scatter_plot.observe(foo, <span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>y变化时就会执行foo(change)</p>
<p>其他的监听事件：</p>
<p>#Adding call back to scatter events</p>
<h1 id="print-custom-mssg-on-hover-and-background-click-of-Blue-Scatter"><a href="#print-custom-mssg-on-hover-and-background-click-of-Blue-Scatter" class="headerlink" title="print custom mssg on hover and background click of Blue Scatter"></a>print custom mssg on hover and background click of Blue Scatter</h1><p>scatter_chart.on_hover(print_event)<br>scatter_chart.on_background_click(print_event)</p>
<p>#print custom mssg on click of an element or legend of Red Scatter<br>scatter_chart2.on_element_click(print_event)<br>scatter_chart2.on_legend_click(print_event)</p>
<p>bar_chart.interactions = {<br>    ‘legend_hover’: ‘highlight_axes’,<br>    ‘hover’: ‘tooltip’,<br>    ‘click’: ‘select’,<br>}<br>点击柱的时候会有选中高亮的效果<br>鼠标位置hover触发tooltip</p>
<p>支持地图：<br>可以放大缩小漫游<br>可以配置投影方式，</p>
<p>说明+代码+一个动图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(title=<span class="string">&#x27;Pyplot 分层设色世界地图&#x27;</span>)</span><br><span class="line">plt.scales(scales=&#123;<span class="string">&#x27;projection&#x27;</span>: Mercator(), <span class="string">&#x27;color&#x27;</span>: ColorScale(scheme=<span class="string">&#x27;YlGnBu&#x27;</span>)&#125;)</span><br><span class="line">map1= plt.geo(map_data=<span class="string">&#x27;WorldMap&#x27;</span>,colors=&#123;<span class="string">&#x27;default_color&#x27;</span>: <span class="string">&#x27;Grey&#x27;</span>&#125;,</span><br><span class="line">              interactions=&#123;<span class="string">&#x27;click&#x27;</span>: <span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;hover&#x27;</span>: <span class="string">&#x27;tooltip&#x27;</span>&#125;,</span><br><span class="line">              tooltip=Tooltip(fields=[<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;color&#x27;</span>]), <span class="comment">#交互提示框</span></span><br><span class="line">              color=&#123;<span class="number">156</span>:<span class="number">66</span>, <span class="number">643</span>:<span class="number">53</span>, <span class="number">76</span>:<span class="number">90</span>, <span class="number">840</span>:<span class="number">21</span>, <span class="number">304</span>:<span class="number">28</span>, <span class="number">124</span>:<span class="number">78</span>, <span class="number">55</span>:<span class="number">99</span>&#125;)</span><br><span class="line">fig           <span class="comment">#根据WorldMap中的id进行颜色映射</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>地图不需要额外的import</p>
<p>输出</p>
<p>fig.save_png()</p>
<p>总结</p>
<p>缺点：在jupyter环境中容易用，在其他ide里要调图不容易；<br>是图形对象，不是静态图片，关闭notebook后再打开就看不见绘图效果了，需要重新运行；</p>
<p>参考资料</p>
<p>官方文档 <a href="https://bqplot.readthedocs.io/en/latest/">https://bqplot.readthedocs.io/en/latest/</a><br>github：<a href="https://github.com/bqplot/bqplot">https://github.com/bqplot/bqplot</a></p>
<p>和mat写法相似，比mat有语句更简洁的交互，数据更新时的渐变挺不错；</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
      </tags>
  </entry>
  <entry>
    <title>手绘效果为图表添色，cutecharts带你画Q版可视图|可视化系列04</title>
    <url>/2020/05/01/viz-cutecharts.html</url>
    <content><![CDATA[<h3 id="cutecharts简介"><a href="#cutecharts简介" class="headerlink" title="cutecharts简介"></a>cutecharts简介</h3><p>Matplotlib默认主题下绘制的可视化图形如一位高贵冷艳、不沾烟火的冰山女神，而cutecharts的图就像不拘常规、潇洒无羁的活力少年。</p>
<p><img src="/2020/05/01/viz-cutecharts/04-00-mat-vscute-0.PNG" alt="纤尘不染vs洒脱无畏"><br>cutecharts是基于chart.xkcd的Python可视化库，chart.xkcd则是基于SVG来绘制可视化图表的JavaScript库，cutecharts充分利用了JavaScript灵活易用的特点，通过简单的语句让可视化图形有强大的表现力和优秀的交互效果，对操作系统和设备的依赖很低。</p>
<p>cutecharts进行可视化的基本代码框架如下：</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cutecharts.charts <span class="keyword">as</span> ctc</span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>:[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;y&#x27;</span>:[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>],</span><br><span class="line">				 <span class="string">&#x27;z&#x27;</span>:[<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>]&#125;)</span><br><span class="line">chart = ctc.Line(<span class="string">&quot;title&quot;</span>,width=<span class="string">&#x27;500px&#x27;</span>,height=<span class="string">&#x27;400px&#x27;</span>) <span class="comment">#新建折线图</span></span><br><span class="line">chart.set_options(</span><br><span class="line">    labels=<span class="built_in">list</span>(df[<span class="string">&#x27;x&#x27;</span>]),  <span class="comment">#注意输入的是可迭代对象，但直接df[&#x27;x&#x27;]不行</span></span><br><span class="line">    x_label=<span class="string">&quot;Weekday&quot;</span>, </span><br><span class="line">    y_label=<span class="string">&quot;US&quot;</span> )</span><br><span class="line">chart.add_series(<span class="string">&quot;This Week&quot;</span>, <span class="built_in">list</span>(df[<span class="string">&#x27;y&#x27;</span>])) <span class="comment">#同样不能直接df[&#x27;y&#x27;]</span></span><br><span class="line">chart.add_series(<span class="string">&quot;Last Week&quot;</span>, <span class="built_in">list</span>(df[<span class="string">&#x27;z&#x27;</span>]))</span><br><span class="line">chart.render_notebook()</span><br></pre></td></tr></table></figure>

<p>cutecharts通过charts建立绘图对象，应用层的类有Line/Bar/Scatter等5个，<br>在语法上，通过charts.Line(“title”,width,height)建立折线图对象，设置标题、图表大小，然后统一通过.add_series()传入各坐标轴的数据，通过.set_options()设置各种图表参数，如坐标轴标签、轴标题和图元颜色等。<br>set_options和add_series的语句顺序可以调换。<code>chart.render_notebook()</code>将图在jupyter notebook中渲染出来。</p>
<h3 id="Line"><a href="#Line" class="headerlink" title="Line"></a>Line</h3><p>绘制一个折线图的代码和绘图效果上面已经提到，add_series()对应一条线，多个add_series()就是在图中绘制多条折线。<code>.set_options()</code>可以设置的参数如下：</p>
<ul>
<li>labels：X坐标轴的数据，输入的是可迭代对象，但直接df[‘x’]不行，不支持Series；</li>
<li>x_label/y_label：分别对应X坐标轴名称和Y坐标轴名称；</li>
<li>y_tick_count：Y轴刻度分割段数；</li>
<li>colors 颜色数组，支持满足CSS样式的各种颜色输入方式；</li>
<li>legend_pos：图例位置，可选四个位置{“upLeft”, “upRight”, “downLeft”, “downRight”}，默认upLeft；</li>
<li>font_family：设置文本的字体；</li>
</ul>
<p><img src="/2020/05/01/viz-cutecharts/04-02-cutecharts-tick.PNG" alt="cutecharts 常用参数对应图元"></p>
<h4 id="图像输出"><a href="#图像输出" class="headerlink" title="图像输出"></a>图像输出</h4><p>我们通过.Line()创建图并且通过<code>.add_series()</code>及<code>.set_options()</code>设置数据及图元之后，通过<code>chart.render(&quot;fname.html&quot;)</code>输出为本地的HTML文档，打开HTML就是一个可视化图像。render的参数有dest表示输出文件的路径，template_name表示渲染所用的模板。<br><code>chart.render_notebook()</code>是在jupyter notebook中直接出图。<code>chart.load_javascript()</code>加载 JS 依赖，在 JupyterLab 渲染时用。</p>
<h3 id="Scatter"><a href="#Scatter" class="headerlink" title="Scatter"></a>Scatter</h3><p>Scatter用于绘制散点图，例子代码及绘图效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chart = ctc.Scatter(<span class="string">&#x27;title&#x27;</span>,width=<span class="string">&#x27;500px&#x27;</span>,height=<span class="string">&#x27;400px&#x27;</span>)</span><br><span class="line">chart.set_options(</span><br><span class="line">    x_label=<span class="string">&quot;xlabel&quot;</span>, </span><br><span class="line">    y_label=<span class="string">&quot;ylabel&quot;</span> ,</span><br><span class="line">    colors=[<span class="string">&#x27;#1EAFAE&#x27;</span>,<span class="string">&#x27;#BA5C25&#x27;</span>],</span><br><span class="line">    dot_size=<span class="number">1</span>)</span><br><span class="line">chart.add_series(<span class="string">&quot;y&quot;</span>,[(c[<span class="string">&#x27;y&#x27;</span>],c[<span class="string">&#x27;z&#x27;</span>]) <span class="keyword">for</span> i,c <span class="keyword">in</span> df.iterrows()])</span><br><span class="line">chart.add_series(<span class="string">&quot;dy&quot;</span>,[(c[<span class="string">&#x27;z&#x27;</span>],c[<span class="string">&#x27;y&#x27;</span>]) <span class="keyword">for</span> i,c <span class="keyword">in</span> df.iterrows()])</span><br><span class="line">chart.render_notebook()</span><br></pre></td></tr></table></figure>



<p><img src="/2020/05/01/viz-cutecharts/04-03-Scatter-cutechart-501.PNG" alt="Scatter效果图"></p>
<p><code>.set_options()</code>支持设置的参数如下：</p>
<ul>
<li>x_label/y_label：分别对应X坐标轴名称和Y坐标轴名称；</li>
<li>x_tick_count/y_tick_count：X轴和Y轴刻度分割段数；</li>
<li>is_show_line：是否绘制散点连线的效果；</li>
<li>dot_size  目前没有点的形状？</li>
<li>colors 颜色数组，如果是一个颜色也要写成<code>[&#39;#1EAFAE&#39;]</code>形式；</li>
<li>time_format：日期数据类型的展示格式；</li>
<li>legend_pos：图例位置，可选四个位置{“upLeft”, “upRight”, “downLeft”, “downRight”}，默认upLeft；</li>
<li>font_family：设置文本的字体；</li>
</ul>
<p>根据上面的参数解释，需要说明的是，绘制带端点的折线用的是Scatter并设置is_show_line=True，而不是用Line。</p>
<h3 id="Bar"><a href="#Bar" class="headerlink" title="Bar"></a>Bar</h3><p>ctc.Bar()用于绘制柱状图。例子代码及绘图效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chart &#x3D; ctc.Bar(&#39;title&#39;,width&#x3D;&#39;500px&#39;,height&#x3D;&#39;400px&#39;)</span><br><span class="line">chart.set_options(</span><br><span class="line">    labels&#x3D;list(df[&#39;x&#39;]),</span><br><span class="line">    x_label&#x3D;&quot;Weekday&quot;, </span><br><span class="line">    y_label&#x3D;&quot;US&quot; ,</span><br><span class="line">    colors&#x3D;[&#39;#1EAFAE&#39; for i in range(len(df))]</span><br><span class="line">    )</span><br><span class="line">chart.add_series(&quot;y&quot;,list(df[&#39;y&#39;]))</span><br><span class="line">chart.add_series(&quot;z&quot;,list(df[&#39;z&#39;]))</span><br><span class="line">chart.render_notebook()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/05/01/viz-cutecharts/04-04-bar-501.PNG" alt="bar效果图"></p>
<p><code>.set_options()</code>支持设置的参数如下：</p>
<p><img src="/2020/05/01/viz-cutecharts/04-05-bar-fms-cute-xmind.PNG" alt="bar参数"></p>
<h3 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h3><p>ctc.Pie()用于绘制饼图。例子代码及绘图效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chart &#x3D; ctc.Pie(&#39;title&#39;,width&#x3D;&#39;500px&#39;,height&#x3D;&#39;400px&#39;)</span><br><span class="line">chart.set_options(</span><br><span class="line">    labels&#x3D;list(df[&#39;x&#39;]),</span><br><span class="line">    inner_radius&#x3D;0</span><br><span class="line">    )</span><br><span class="line">chart.add_series(list(df[&#39;y&#39;])) #只接受一个参数，也就是数据列</span><br><span class="line">chart.render_notebook()</span><br></pre></td></tr></table></figure>



<p><img src="/2020/05/01/viz-cutecharts/04-06-pie-sun-cute-501.PNG" alt="饼图和环状图"></p>
<p>和之前的图不同的是，Pie的<code>.add_series()</code>只接受一个参数，也就是数据列。<code>.set_options()</code>支持设置的参数如下：</p>
<p><img src="/2020/05/01/viz-cutecharts/04-07-pie-cute-xmind.PNG" alt="pie参数"></p>
<h3 id="Radar"><a href="#Radar" class="headerlink" title="Radar"></a>Radar</h3><p>ctc.Radar()用于绘制雷达图。例子代码及绘图效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chart &#x3D; ctc.Radar(&#39;Radar&#39;,width&#x3D;&#39;700px&#39;,height&#x3D;&#39;600px&#39;)</span><br><span class="line">chart.set_options(</span><br><span class="line">    labels&#x3D;list(df[&#39;x&#39;]),</span><br><span class="line">    legend_pos&#x3D;&#39;upRight&#39;</span><br><span class="line">    )</span><br><span class="line">chart.add_series(&#39;y&#39;,list(df[&#39;y&#39;]))</span><br><span class="line">chart.add_series(&quot;z&quot;,list(df[&#39;z&#39;]))</span><br><span class="line">chart.render_notebook()</span><br></pre></td></tr></table></figure>



<p><img src="/2020/05/01/viz-cutecharts/04-08-radar-cutechart.PNG" alt="radar效果图"></p>
<p><code>.set_options()</code>支持设置的参数如下：</p>
<p><img src="/2020/05/01/viz-cutecharts/04-09-rader-fms-cute-xmind.PNG" alt="radar 参数"></p>
<h3 id="chart-xkcd"><a href="#chart-xkcd" class="headerlink" title="chart.xkcd"></a>chart.xkcd</h3><p>cutecharts基于chart.xkcd进行封装，通过看两个库的源码可以看到的是chart.xkcd枚举了Line、Bar、Radar等图来绘制具有手绘效果的图像。cutecharts几个绘图接口和chart.xkcd的对应关系如下：</p>
<p><img src="/2020/05/01/viz-cutecharts/04-10-cutecharts-and-xkcd.PNG" alt="cutecharts和xkcd的对应"></p>
<p>chart.xkcd还有一个StackedBar()用于绘制堆叠柱状图，目前cutecharts还没有。从源码中能看到，chart.xkcd用到了d3-selection、d3-scale等d3.js的脚手架来做交互和DOM操纵(关于D3可视化后续公众号会更新6篇系列文章进行实践，目前有一篇<a href>概览性文章</a>)，同时为了实现手绘效果，在具体绘制柱状图等图表时，通过<code>addFilter.js</code>添加偏移量形成手绘线条的效果、通过xkcd字体来实现文本的手写效果。通过 <code>addAxis.js</code>、<code>addLegend.js</code>等绘制坐标轴和文本，要深入chart.xkcd具体的绘图细节，可以去深入研究一下源码。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基于JavaScript库实现可视化，可以很好地实现交互、高亮等实用的功能，给可视化添色，Python作为一种胶水语言并且具有活跃的社区，将JavaScript可视化库变成Python可视化库也并不复杂，广泛应用的pyecharts就是基于echarts开发的，语法上cutecharts的写法和pyecharts一脉相承，理解了cutecharts的写法，对学习pyecharts也有帮助。<br>和pyecharts支持丰富的图表类型不同，受限于chart.xkcd本身只支持6种图（且连常用的条形图都不包含），cutecharts支持的图表也很少，只能满足常用的图表，组合图绘制也心有余而力不足，另外使用默认字体时中文文本没有漫画/手绘的效果，需要配置对应字体。</p>
<p>参考资料</p>
<ul>
<li><a href="https://github.com/chenjiandongx/cutecharts">https://github.com/chenjiandongx/cutecharts</a></li>
<li><a href="https://github.com/timqian/chart.xkcd">https://github.com/timqian/chart.xkcd</a></li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>viz</tag>
      </tags>
  </entry>
  <entry>
    <title>D3库实践笔记之幻化万千的返璞归真 |可视化系列32</title>
    <url>/2020/10/02/viz-d3-02-viz-back-to-basics.html</url>
    <content><![CDATA[<p>D3是什么？狭义的理解是一个JavaScript可视化库。通过操作HTML的基础元素或SVG元素构建可视化图形，绘制出精美交互性强的可视化图像。D3是Data-Driven Documents的简写，一个基于数据操纵文档的JavaScript库，文档指的是HTML的DOM，即文档对象模型(Document Object Model)，D3提供了各种实用的方法将数据绑定到DOM，根据数据操纵文档，画图只是它的功能之一。</p>
<h3 id="D3第一行代码"><a href="#D3第一行代码" class="headerlink" title="D3第一行代码"></a>D3第一行代码</h3><a id="more"></a>

<p>D3操作的是Web上的文档，可以便捷快速地生成和发布可视化作品，对操作系统和设备的依赖很低。</p>
<p>D3库的功能和特点：</p>
<ul>
<li>将数据和DOM绑定在一起、图形随着数据变化；</li>
<li>数据转换和绘制独立；不是提供Pie()这类函数绘图而是将数据转换成饼图数据，再按需绘图。像面粉可以做出各种糕点而不是直接提供面条；</li>
<li>擅长矢量图形，缩放不损失图形精度，不擅长位图和瓦片，不擅长探索型可视化；</li>
<li>作为HTML文档，不隐藏原始数据，<em>如果不想共享数据，为什么还要将它们可视化呢？</em></li>
</ul>
<p>D3本质上还是JavaScript，这意味着我们可以用原生JavaScript代码实现讲到的所有功能，但D3对各种常用操作进行了很好的封装，大大减轻了做可视化的工作量并应对各种需求。用D3做可视化的代码框架如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>D3可视化代码框架<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./d3/d3.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--直接引入在线的d3库： &lt;script src=&quot;https://d3js.org/d3.v6.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="comment">// D3 代码部分</span></span></span><br><span class="line"><span class="javascript">     d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;p&quot;</span>).text(<span class="string">&quot;hello world！&quot;</span>);</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>来细看这段代码，除<code>d3.select(&quot;body&quot;)...</code>句外，都是通用的HTML代码，D3的第一行代码就只是<code>d3.select(&quot;body&quot;).append(&quot;p&quot;).text(&quot;hello world！&quot;);</code>。HTML标记中，<html><head></head><body></body></html>划分了层次结构，发挥功能的d3代码在<script></script>块里。这段d3脚本代码的作用是在html的body元素里加入一个文本段落(<code>&lt;p&gt;&lt;/p&gt;</code>)，并把文本内容<code>hello world！</code>添加给这个段落。</p>
<p>需要说明的是，本系列笔记都基于v6.x版本，v5之后的版本和网上各种教程用的v3.x差别还挺大的，亲测一些书籍和教程里的写法都不能正常运行了，典型的一些例子后续具体内容里会提到。</p>
<p>总结一下D3可视化的基本步骤如下：</p>
<ul>
<li>创建新元素并绑定数据（html的元素可理解为划定区域和声明类型的闭合标签，如p表示其是一个段落，是段落就可以有段落文本、长宽、id等属性和标识）；</li>
<li>设置相应元素的可视属性，将数据值映射为元素大小、颜色、位置等可视属性；</li>
<li>对元素进行排列和变换，还有响应交互；</li>
</ul>
<p>D3那句链式调用了.select()、append()等，也可以用中间变量承接，写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拆成多个语句的写法：</span></span><br><span class="line"><span class="keyword">var</span> body = d3.select(<span class="string">&quot;body&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> p = body.append(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">p.text(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>原始HTML文档和浏览器中D3代码发挥作用后生成的HTML文档对比效果如下，左边是原始代码，右边的HTML文档中<body>标签里多了一行文本<p>hello world!</p>。</body></p>
<p><img src="/2020/10/02/viz-d3-02-viz-back-to-basics/viz-d3-notes-all/31-01-01-1002-html-to-d3-html.png" alt="从原html到效果html"></p>
<h3 id="幻化万千的返璞归真"><a href="#幻化万千的返璞归真" class="headerlink" title="幻化万千的返璞归真"></a>幻化万千的返璞归真</h3><p>操纵<code>&lt;p&gt;</code>等HTML标签是牛刀小试，绘制可视化图形主流做法是生成和操作<code>&lt;svg&gt;</code>标签生成点线面，再组合成柱图、饼图、地图等可视化图表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> svg=d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">     	  .attr(<span class="string">&quot;width&quot;</span>,<span class="number">600</span>).attr(<span class="string">&#x27;height&#x27;</span>,<span class="number">500</span>);</span><br><span class="line">svg.append(<span class="string">&quot;rect&quot;</span>).style(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>)</span><br><span class="line">		  .attr(<span class="string">&quot;x&quot;</span>,<span class="number">30</span>).attr(<span class="string">&quot;y&quot;</span>,<span class="number">50</span>).attr(<span class="string">&quot;width&quot;</span>,<span class="number">60</span>).attr(<span class="string">&quot;height&quot;</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/02/viz-d3-02-viz-back-to-basics/viz-d3-notes-all/31-01-03-1002-d3code-svg-res.png" alt="d3代码-&gt;svg-&gt;结果图像"></p>
<p>画一个完整的统计图表还需要绘制坐标轴、加文本标签、加标题/图例等图元，这些d3都可以通过操纵<code>&lt;svg&gt;</code>实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>];</span><br><span class="line"><span class="keyword">var</span> h=<span class="number">400</span>,w=<span class="number">500</span>,m=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">var</span> svg=d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;svg&quot;</span>).attr(<span class="string">&quot;class&quot;</span>,<span class="string">&quot;axis&quot;</span>)</span><br><span class="line">		  .attr(<span class="string">&quot;width&quot;</span>,w).attr(<span class="string">&#x27;height&#x27;</span>,h);</span><br><span class="line">renderXAxis();</span><br><span class="line">renderYAxis(); <span class="comment">//部分代码省略</span></span><br><span class="line">svg.selectAll(<span class="string">&quot;rect&quot;</span>).data(dataset).enter().append(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">   .attr(<span class="string">&quot;class&quot;</span>,<span class="string">&quot;bar&quot;</span>).style(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>)</span><br><span class="line">   .attr(<span class="string">&quot;x&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;<span class="keyword">return</span> i*<span class="number">75</span>+<span class="number">75</span> +<span class="string">&quot;px&quot;</span>;&#125;)</span><br><span class="line">   .attr(<span class="string">&quot;y&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> (<span class="number">375</span>-d*<span class="number">3.5</span>) +<span class="string">&quot;px&quot;</span>;&#125;)</span><br><span class="line">   .attr(<span class="string">&quot;width&quot;</span>,<span class="number">50</span>).attr(<span class="string">&quot;height&quot;</span>,<span class="function"><span class="params">d</span> =&gt;</span> d*<span class="number">3.5</span> +<span class="string">&quot;px&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/02/viz-d3-02-viz-back-to-basics/viz-d3-notes-all/31-01-05-1003-d3-bar.png" alt="D3绘制基础柱状图"></p>
<p>数据+坐标系+布局+文本图元，最终幻化万千可视图。</p>
<p><img src="/2020/10/02/viz-d3-02-viz-back-to-basics/viz-d3-notes-all/31-01-06-1003-infinite-d3.png" alt="d3绘制的各种可视化成果"></p>
<h3 id="D3基础技术概念"><a href="#D3基础技术概念" class="headerlink" title="D3基础技术概念"></a>D3基础技术概念</h3><p>为了更方便地理解D3代码和实现原理，本节对d3可视化设计到的一些前端技术概念进行概述，如果对HTML、CSS、JavaScript、SVG很了解可以跳过这部分。</p>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>HTML(Hypertext Markup Language, 超文本标记语言) ，用于向浏览器说明内容的标记结构，例如显示什么文字、用段落显示还是表格显示等。HTML 的核心功能就是让你“标记”内容,进而给出结构。文字还是那些文字,但加上结构之后,可读性就不一样了。HTML每个元素都有一个标记标签(Markup Tag)。之前的代码里就用到了<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>、<code>&lt;p&gt;</code>等标签，都是用一对尖括号包围的。标签有成对出现的，如<code>&lt;p&gt;&lt;/p&gt;</code>;也有不成对出现的,如<code>&lt;br/&gt;</code>。</p>
<p>HTML 有上百个元素，日常使用和d3学习中只需要知道少数几种。拿之前的d3代码框架对照着看：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>D3可视化代码框架<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./d3/d3.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--直接引入在线的d3库： &lt;script src=&quot;https://d3js.org/d3.v6.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment"> 	--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">     	d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;p&quot;</span>).text(<span class="string">&quot;hello world！&quot;</span>);</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p><code>&lt;!DOCTYPE html&gt;</code>：这是标准的文档类型声明，必须在文档的第一行，不是HTML标签，其主要目<br>的是告诉浏览器HTML的版本信息。</p>
</li>
<li><p>html标签：包含文档中的所有 HTML 内容；</p>
</li>
<li><p>head：文档的头部,包含所有文档的元数据。比如标题和对外部样式表、脚本的引用。里面的标签有title、meta、script等；</p>
</li>
<li><p>meta：定义文档的元数据内容，没有结束标签，内容作为属性写在标签里；例如<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>；</p>
</li>
<li><p>title：文档的标题。浏览器会把这个元素的内容显示在窗口标题栏中，并在收藏网页时使用这一标题；典型写法如<code>&lt;title&gt;D3可视化代码框架&lt;/title&gt;</code>；</p>
</li>
<li><p>body：所有不包含在 head 中的内容,都包含在 body 中。这里面的内容是可以在网页中看到的；</p>
</li>
<li><p>h1 、 h2 、 h3 、 h4、h5：用于标记不同级别的标题。 h1 代表顶级标题, h2 代表二级标题,依此类推；</p>
</li>
<li><p>ul 、 ol 、 li：ul 用于标记无序列表,也就是带项目符号的列表， ol 用于标记有序列表，带编号。 ul 和 ol 都包含 li 元素,用于标记列表项；</p>
</li>
<li><p>p：一个段落；</p>
</li>
<li><p>strong：<strong>加粗文本</strong>，表示额外强调，<code>&lt;b&gt;</code>标签也是加粗文本；</p>
</li>
<li><p>em：表示强调，显示<em>斜体文本</em>，<code>&lt;i&gt;</code>标签表示的是一般的斜体文本；</p>
</li>
<li><p>span：任意文本，一般都包含在 p 这样的大容器元素中；</p>
</li>
<li><p>div：任意文本块，常用于分组相关元素和个性化内容；</p>
</li>
<li><p>a：链接，一般显示为带下划线的蓝色文本，例如<code>&lt;a href=&quot;https://d3js.org/&quot;&gt;D3网站&lt;/a&gt;</code>；</p>
</li>
<li><p>link：用于引用外部资源，如引用同一文件夹下的css文件：<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; /&gt;</code>；</p>
</li>
<li><p>style：用于在文档中定义CSS样式；如果内容很多，则建议写在外部文件中,再用<code>&lt;link&gt;</code>标签引用；</p>
</li>
<li><p>script：用于定义客户端脚本,最常见的是JavaScript脚本，我们写的d3代码在<code>&lt;script&gt; &lt;/script&gt;</code>标签里；</p>
</li>
<li><p>注释：html里注释的写法为<code>&lt;!-- 要注释的内容 --&gt;</code>；</p>
</li>
</ul>
<p>DOM，指文档对象模型(Document Object Model)，是针对结构化文档的一个接口，它允许程序和脚本动态地访问和修改文档。使用这套模型即可任意访问和修改HTML元素。D3中的函数大量脱胎于DOM。DOM是以树形结构来描述HTML文档的，其被称为节点树，每个HTML元素都是树上的一个节点。</p>
<p><img src="/2020/10/02/viz-d3-02-viz-back-to-basics/viz-d3-notes-all/31-02-03-1003-dom-note-tree.png" alt="一颗节点树的例子"></p>
<h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>CSS(Cascading Style Sheets,层叠样式表)控制 DOM 元素的视觉外观，用于定义HTML元素的样式,如字体大小、背景颜色、布局等。一个CSS语句例子和效果如下：</p>
<p><img src="/2020/10/02/viz-d3-02-viz-back-to-basics/viz-d3-notes-all/31-02-04-1003-css-demo.png" alt="CSS语句例子"></p>
<p>CSS 样式由选择符和属性组成。选择符后面跟着属性，被一对花括号所包围。属性和值由冒号分隔，每个属性声明以分号结尾。相同的属性可以应用给多个选择符，只要用逗号分隔选择符即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择符 <span class="selector-tag">A</span>,</span><br><span class="line">选择符 <span class="selector-tag">B</span> &#123;</span><br><span class="line">	属性1 : 值 ;</span><br><span class="line">	属性2 : 值 ;</span><br><span class="line">	属性3 : 值 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>JavaScript 是动态脚本语言，通过操作 DOM 动态修改页面。D3是一个JavaScript库，也就是说D3的写法符合JavaScript的语法规范。</p>
<p>JavaScript单行注释用<code>//</code>，多行注释用 <code>/*  */</code>，和C家族的语言一致，css的注释也是用的 <code>/*  */</code>，和JavaScript一样。JavaScript区分大小写，每条语句结尾用分号(;)标识，是弱类型语言，声明变量通常用var，不论是浮点数、字符串或者数组，都可以用var，通过<code>var a=5;</code>给变量a赋值5。也可以写<code>let a=5</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pi=<span class="number">3.14</span>; <span class="comment">//数值</span></span><br><span class="line"><span class="keyword">var</span> d=<span class="string">&quot;蛰虫始航&quot;</span>; <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">var</span> t=<span class="literal">true</span>; <span class="comment">//false 布尔值</span></span><br><span class="line"><span class="keyword">var</span> ds = [<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>]; <span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> apple = &#123;<span class="attr">kind</span>: <span class="string">&quot;fruit&quot;</span>,</span><br><span class="line">		color: <span class="string">&quot;red&quot;</span>, <span class="attr">quantity</span>:<span class="number">10</span>, <span class="attr">tasty</span>: <span class="literal">true</span></span><br><span class="line">	&#125; <span class="comment">//对象，可以认为是一个字典dict</span></span><br></pre></td></tr></table></figure>

<p>数值间的加(+)、减(-)、乘(*)、除(/)、比较运算等都是常规的写法。</p>
<p>分支和循环的写法和C语言家族基本一致，函数通过<code>function(arr)&#123;return arr&#125;</code>定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (t==<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ds.length;i++)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(ds[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count_ds=<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c=<span class="number">0</span>;</span><br><span class="line">    d.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; <span class="comment">//数组可以用forEach循环</span></span><br><span class="line">        c+=e</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c0=ds.forEach(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)) <span class="comment">//函数的简写方法</span></span><br></pre></td></tr></table></figure>

<p>JavaScript脚本除了直接写在HTML的<code>&lt;script&gt;</code>标签里，也可以保存在独立的js文件里，通过<code>&lt;script type=&quot;text/javascript&quot; src=&quot;d3-learning.js&quot;&gt;&lt;/script&gt;</code>引入。</p>
<h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>SVG（Scalable Vector Graphics，可伸缩矢量图形）基于XML标签来表示图形。基于HTML文档的可视化基本都使用canvas或svg元素作为数据到图形的映射容器。D3也可以直接操作div或其他原生HTML元素来绘图，但这就显得笨重不灵活，且容易出现浏览器间不一致的问题。而用 SVG就更可靠，图形效果更一致，且绘图速度更快。</p>
<p>SVG 元素可以理解为能在上面绘制各种形状的画布。一个基础的svg示例如下，描述了一个半径为20像素的圆形，在网页端就可以显示为一个圆形。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;200&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;30&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在SVG的预定义元素里，有6种基本元素rect(矩形)、circle(圆形)、ellipse(椭圆)、line(线段)、polyline(折线)、polygon(多边形)和功能强大的path(路径)，在SVG里也可以添加text(文本)元素。</p>
<p>和一些编程语言的坐标系统一样，基于像素的坐标系统的原点位于画布的<strong>左上角</strong>。这意味着增大 x 的值，图形会向右移动；增大 y 值，图形会向下移动。</p>
<p><img src="/2020/10/02/viz-d3-02-viz-back-to-basics/viz-d3-notes-all/31-01-03-1002-d3code-svg-res.png" alt="d3代码-&gt;svg-&gt;结果图像"></p>
<p>关于于 SVG 元素，最关键是要记住它们的各个方面都是通过属性来设定的。换句话说，就是通过标签中的属性:值对来指定 SVG 元素的各方面特征，比如：<code>&lt;rect x=&quot;30&quot;&gt;&lt;/rect&gt;</code><br>如果熟悉HTML就会觉得很容易上手<code>&lt;p class=&quot;lyndon&quot;&gt;txt&lt;/p&gt;</code>，毕竟都是基于XML进行标记数据。</p>
<h3 id="D3学习资源"><a href="#D3学习资源" class="headerlink" title="D3学习资源"></a>D3学习资源</h3><p>D3库一些实用的文档和资源。<a href="https://d3js.org/">D3官网</a>有最新版本最权威的API列表和各种示例的链接，有个中文版的文档网站<a href="https://d3js.org.cn/">https://d3js.org.cn/</a>；</p>
<ul>
<li>各种d3案例：<a href="https://bl.ocks.org/mbostock">https://bl.ocks.org/mbostock</a> </li>
<li>可以用函数名称等检索bl.ocks的网站：<a href="http://bl.ocksplorer.org/">http://bl.ocksplorer.org/</a> </li>
<li>基于d3的动态可视化封装js库：<a href="https://github.com/NPashaP/Viz">https://github.com/NPashaP/Viz</a></li>
<li>专门为探索大型、多维数据集而进行优化的js库：<a href="http://dc-js.github.io/dc.js/">http://dc-js.github.io/dc.js/</a></li>
<li>基于d3画动态排序条形图：<a href="https://github.com/Jannchie/Historical-ranking-data-visualization-based-on-d3.js">Historical-ranking-data-visualization-based-on-d3</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>D3是一个基于数据操纵文档的JavaScript库，大家普遍用来作为可视化库，可以绘制出丰富的可视化图表，很多JavaScript库基于D3来绘图，很多Python可视化库基于d3封装，例如altair、bokeh、bqplot、mpld3等等，足以见其影响力，而且经过这些年的发展，d3有着丰富的实例库和和生态。深入学d3的好处在于可以体验从点线面到可视化图形的成就感，加深对SVG的了解，更深刻地理解一些可视化库的原理和接口设置，有更底层的视野和感悟。</p>
<p>后续文章继续学习用D3操作svg从0到1绘制包含交互统计图。</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title>D3库实践笔记之元素定位与数据绑定 |可视化系列33</title>
    <url>/2020/10/02/viz-d3-03-select-enter.html</url>
    <content><![CDATA[<p>D3根据数据的内容操纵HTML文档对象，实现把数据变成可视图。要操纵文档对象，例如在<code>&lt;body&gt;</code>里添加一个<code>&lt;svg&gt;</code>、编辑<code>&lt;svg&gt;</code>标签里的一个矩形，要完成这些首先需要能定位到我们需要操作的元素。再结合数据操作这些元素。</p>
<p>本篇具体展开D3用于选择及增删文档对象的方法以及数据绑定的方法。</p>
<a id="more"></a>

<h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> svg=d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">     	  .attr(<span class="string">&quot;width&quot;</span>,<span class="number">600</span>).attr(<span class="string">&#x27;height&#x27;</span>,<span class="number">500</span>);</span><br><span class="line">svg.append(<span class="string">&quot;rect&quot;</span>).style(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>)</span><br><span class="line">		  .attr(<span class="string">&quot;x&quot;</span>,<span class="number">30</span>).attr(<span class="string">&quot;y&quot;</span>,<span class="number">50</span>).attr(<span class="string">&quot;width&quot;</span>,<span class="number">60</span>).attr(<span class="string">&quot;height&quot;</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p>回顾一下前一篇里的D3代码框架，选定HTML里<code>&lt;body&gt;</code>后增加一个<code>&lt;svg&gt;</code>标签并设置长宽分别为600和500像素，对这个新建的<code>&lt;svg&gt;</code>标签进行修改，在[30,50]坐标处添加了一个长宽[60,80]的矩形。这种写法是D3可视化后续内容的基础，需要充分理解。</p>
<p>d3的select()方法用于查询满足条件的<strong>第一个</strong>HTML文档对象，传入一个 CSS 选择符，返回DOM 中匹配的第一个元素的引用。典型用法如下：</p>
<ul>
<li>d3.select(“body”) ;  //选择HTML里的body元素；</li>
<li>d3.select(“#apple”); //选择id为apple的元素；例如会匹配上<code>&lt;p id=&quot;apple&quot;&gt;一段文本&lt;/p&gt;</code>；</li>
<li>d3.select(“.apple”); //选择class为apple的元素；会匹配上<code>&lt;p class=&quot;apple&quot;&gt;一段文本&lt;/p&gt;</code>；</li>
</ul>
<p>如果想获得所有满足条件的元素，用selectAll()方法，写法和上面一致，把select变成selectAll，例如<code>d3.selectAll(&quot;.content&quot;)</code>实现的是选定class为content的所有元素、<code>selectAll(&quot;ul li&quot;)</code>选中ul中所有的li元素。关于select和selectAll的参数，还可以是已经被DOM API选择的元素，例如以下代码结合JavaScript本身API和d3的select选中id为apple的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> apple = <span class="built_in">document</span>.getElementById(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">d3.select(apple);</span><br></pre></td></tr></table></figure>

<p>我们在选择了需要操作的svg元素后，通常需要添加rect(矩形)等图形，用append()方法添加元素，<code>d3.select(&quot;svg&quot;).append(&quot;rect&quot;)</code>便在html文档里的<code>&lt;svg&gt;</code>标签下从无到有地增加了一个<code>&lt;rect&gt;&lt;/rect&gt;</code>元素；insert()方法在所选元素前添加一个元素；remove()方法在DOM中删除满足条件的元素；增删改查的关键词和SQL很像，实现的目标也相同。</p>
<h3 id="设定属性"><a href="#设定属性" class="headerlink" title="设定属性"></a>设定属性</h3><p>选定或添加我们需要操纵的元素后，便可以编辑元素的属性，例如图形位置、填充色、标识等属性。通过<code>.attr(name,value)</code>给所选元素添加属性，name是属性名称,value是属性值。例如svg里有一个矩形rect，</p>
<p><code>&lt;svg&gt;&lt;rect&gt;&lt;/rect&gt;&lt;/svg&gt;</code>，给rect设置id为bar1，class为bar，高度为50，则attr的写法和结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">svg.select(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;bar1&quot;</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;class&quot;</span>,<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;height&quot;</span>,<span class="number">50</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;rect id=&quot;bar1&quot; class=&quot;bar&quot; height=50&gt;&lt;/rect&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>应用attr的效果相当于在元素标签中添加了name=”value”的标记。而要知道某个元素的某个属性值，可以写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar_h=d3.select(<span class="string">&quot;#bar&quot;</span>).attr(<span class="string">&quot;height&quot;</span>);</span><br><span class="line"><span class="comment">//获取选中矩形的高度，从而设置文本标签位置</span></span><br></pre></td></tr></table></figure>

<p><code>.style(&quot;name&quot;,&quot;val&quot;)</code>设置元素的css属性，例如设置选中矩形的填充色为青色，则可以写<code>svg.select(&quot;rect&quot;).style(&quot;fill&quot;,&quot;#1EAFAE&quot;)</code>，对应在生成的HTML文档里是<code>&lt;rect style=&quot;fill: rgb(30, 175, 174);&quot;&gt;&lt;/rect&gt;</code>这种结构。</p>
<p><img src="/2020/10/02/viz-d3-03-select-enter/viz-d3-notes-all/31-02-01-1003-d3-attr-style.png" alt="d3设定矩形属性"></p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>为了实现将数据映射元素的位置和样式属性，d3有方便的接口用于数据和选定元素的绑定。通过<code>datum(val)</code>将数据val绑定到选中的所有元素，<code>d3.selectAll(&quot;rect&quot;).datum(76)</code>给所有的矩形绑定了数据76，用F12调出控制台看看呀看到对应矩形对象内置的<code>__data__</code>的值是76。</p>
<p>通过<code>data(vals[,key])</code>绑定数组vals中的每一项到选中的元素，key是一个用于指定绑定规则的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [ <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span> ];</span><br><span class="line">d3.select(<span class="string">&quot;body&quot;</span>).selectAll(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line"> 	.data(dataset)</span><br><span class="line"> 	.enter()</span><br><span class="line"> 	.append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;class&quot;</span>,<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"> 	.style(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;width&quot;</span>,<span class="number">50</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;height&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> d*<span class="number">10</span> +<span class="string">&quot;px&quot;</span>;&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/02/viz-d3-03-select-enter/viz-d3-notes-all/31-02-01-1002-data-links.png" alt="数据集与矩形绑定"></p>
<p>当有一个数据集时，通常添加元素和数据行数是密切相关的，例如在绘制柱状图时，一般做法是新建一个svg元素，内部有多少个矩形柱预先不需要知道，通过<code>enter()</code>这一神奇的方法便可以根据数据确定元素的个数，于是上面的代码就不难理解了，初始时body标签里并没有svg元素，但可以写<code>d3.select(&quot;body&quot;).selectAll(&quot;svg&quot;)</code>选定对象，因为后面连缀地写了<code>.data(dataset).enter().append(&quot;svg&quot;)</code>，便根据数据dataset的长度生成了对应数量的svg，这样前面的select便有了对应的元素。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>当我们有一系列数据之后，在可视化之前，通常还需要进行一些数据处理，例如排序、统计等。D3根据数据可视化的需求封装了不少数组处理的函数。</p>
<ul>
<li>d3.min(array[, accessor])：返回数组最小值，第一个参数array是数组,第二个参数accessor是可选参数。accessor是一个函数,指定之后,数组各项首先会调用accessor,然后再使用原函数function进行处理。经典用法是：<code>var m=d3.min([76,37,90,60,50])</code>；</li>
<li>d3.max(lst)：获得数组最大值，和min用法一致；</li>
<li>d3.extend(lst)：返回数组最小值和最大值，获得的是两个值。相当于分别调用d3.min()和d3.max(),返回值是一个数组,第一项是最小值,第二<br>项是最大值；</li>
<li>d3.sum(lst)：返回数组的求和，如果数组为空，则返回0；</li>
<li>d3.mean(lst)：获得数组的平均值，如果数组为空，则返回undefined；</li>
<li>d3.median(lst)：获得数组中位数；</li>
<li>d3.quantile(lst, p)：求取p分位点的值,p的范围为[0,1]。数组需先递增排序。</li>
<li>d3.shuffle(array[, lo[, hi]])：随机排列数组；</li>
<li>d3.variance(lst)：求方差，对应的d3.deviation(lst)求标准差；</li>
<li>d3.ascending(a,b)，递增函数。如果a小于b,返回–1;如果a大于b,返回1;如果a等于b,返回0，一般用来进行排序，对应的有d3.descending(a,b)；</li>
</ul>
<p>d3.ascending()需要和JavaScript的排序函数结合使用；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>];</span><br><span class="line">dataset.sort(d3.descending);</span><br><span class="line"><span class="built_in">console</span>.log(dataset);<span class="comment">//[90, 76, 60, 50, 37]</span></span><br></pre></td></tr></table></figure>

<p>sort函数本身不需要传入d3.ascending效果也是顺序的。</p>
<h3 id="本地数据可视化"><a href="#本地数据可视化" class="headerlink" title="本地数据可视化"></a>本地数据可视化</h3><p>我们可以将数据全部复制写到<code>&lt;script&gt;</code>标签里的JavaScript代码中，但数据集和JavaScript代码的独立也是很重要的需求，通过<code>d3.csv(&quot;food.csv&quot;, function(data) &#123;dataset=data;&#125;)</code>可以读取本地的csv文件数据进行使用，这是写JavaScript代码很常用的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">d3.csv(<span class="string">&quot;bar-data.csv&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">dataset</span>) </span>&#123;</span><br><span class="line">      d3.select(<span class="string">&quot;body&quot;</span>).selectAll(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line"> 		.data(dataset)</span><br><span class="line"> 		.enter()</span><br><span class="line"> 		.append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line"> 		.style(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>)</span><br><span class="line"> 		.attr(<span class="string">&quot;width&quot;</span>,<span class="number">50</span>)</span><br><span class="line"> 		.attr(<span class="string">&quot;height&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> d*<span class="number">10</span> +<span class="string">&quot;px&quot;</span>;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>读取json文件的接口也类似，通过<code>d3.json(&quot;bar-data.json&quot;, function(data) &#123;&#125;)</code>来进行json文件的处理。</p>
<p>d3对数据格式的支持是很充分的，除csv和json这两种外，d3有：</p>
<ul>
<li><code>d3.tsv(&quot;bat.tsv&quot;，function(data) &#123;&#125;)</code>用于读取处理TSV表格文件;</li>
<li><code>d3.xml()</code>：读取XML格式文件；</li>
<li><code>d3.html()</code>：读取HTML文件；</li>
<li><code>d3.txt()</code>：读取文本文件；</li>
</ul>
<p>正常情况下我们可以直接在浏览器中查看本地HTML文件，但涉及本地数据文件时，浏览器出于安全考虑，可能会限制JavaScript加载本地文件，这时候我们需要开一个web服务器来响应web请求从而传递文件，基于Python的http.server在特定位置和端口监听网络请求很简单。通过语句<code>python -m http.server 8888 &amp;</code>结合<code>http://localhost:8888/demo1.html</code>就可以方便地加载本地的数据文件了。</p>
<p><img src="vis-topic-pics/viz-d3-notes-all/31-02-09-1002-http-server.png" alt="python hettp server"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>要用数据驱动文档，需要解决的问题有：如何正确选择需要操作的元素？如何增删改标签和属性？如何把数据和元素绑定？如何读本地文件里的数据和元素绑定？本篇讲述了实现以上需求的D3方法和具体代码。通过select(v)和selectAll选定元素；append、insert和remove方法用于增加、插入和删除元素；attr(name,value)给所选元素添加属性；style(“name”,”val”)设置元素的样式属性；datum(val)和data(vals[,key])用于绑定数据到元素上；d3提供了d3.json()读取本地文件、提供了d3.sum()等统计函数进行数据处理。</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title>D3库实践笔记之SVG预定义元素与使用 |可视化系列34</title>
    <url>/2020/10/02/viz-d3-04-svg-mark.html</url>
    <content><![CDATA[<p>在第一篇笔记里简单介绍了SVG，SVG（Scalable Vector Graphics，可伸缩矢量图形）是HTML里的一种标签，也可以独立保存为.svg的文件，SVG 基于 XML 格式定义图像，通常使用SVG作为d3绘图的容器。</p>
<p>个人认为熟悉SVG中各种图形元素的属性对于学习D3是磨刀不误砍柴工。而且svg的应用场景广泛，不止于D3，也方便自己理解其他库或者软件生成的svg图形文档。</p>
<p>SVG元素的基础写法：</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>单纯以上语句只是声明了一个500x400的空白画布，还需要添加形状，</p>
<p>SVG预定义形状有6种基本形状，分别为rect(矩形)、circle(圆形)、ellipse(椭圆)、line(线段)、polyline(折线)、polygon(多边形)以及功能强大的path(路径)，在SVG里也可以添加text(文本)元素。一个包含矩形的SVG标签如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:#1EAFAE;stroke-width:1;stroke:rgb(0,0,0)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以将其保存为后缀为.svg的独立文件，也可以在html文档里使用。</p>
<p>SVG 坐标系统原点位于画布的左上角，也就是说增大 x 的值，图形是向右移动；增大 y 值，图形会向下移动。</p>
<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-01-1003-svg-coord.png" alt="SVG 坐标系统"></p>
<p>以下对SVG预定义形状进行枚举。</p>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>矩形的标签为<code>&lt;rect&gt;</code>。</p>
<p><code>&lt;rect x=&quot;50&quot; y=&quot;10&quot; width=&quot;60&quot; height=&quot;40&quot;/&gt;</code>声明一个矩形。</p>
<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-02-1003-svg-rect.png" alt="svg-rect"></p>
<p>在绘制柱状图、条形图、直方图、堆叠柱状图等统计图时，广泛地用到了<code>&lt;rect&gt;</code>标签。</p>
<p><code>&lt;rect&gt;</code>的属性有：</p>
<ul>
<li>x：矩形<strong>左上角</strong>的x坐标，注意是左上角不是中心点的坐标；</li>
<li>y：矩形左上角的y坐标；</li>
<li>width：矩形宽度；</li>
<li>height：矩形高；</li>
<li>rx：缺省是正常矩形，否则是圆角矩形，圆角处椭圆在x方向的半径；</li>
<li>ry：圆角矩形的圆角在y方向的半径；</li>
</ul>
<p>sytle用于指定矩形的样式，如填充色，透明度，边框；写作<code>&lt;rect style=&quot;fill:#1EAFAE; opacity:0.6&quot;&gt;</code>，这些在svg的其他图形中也适用，就不再重复。</p>
<ul>
<li>fill：表示要填充的颜色，css颜色，常用的是3种，可以是blue这种名称，也可以是16进制颜色值<code>#1EAFAE</code>或者是<code>rgb(30, 175, 174)</code>；</li>
<li>stroke：表示边框的颜色；</li>
<li>stroke-width：边框宽度；</li>
<li>opacity：透明度。数值在[0,1]之间，值越小越透明；</li>
</ul>
<p>一个SVG矩形的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;20&quot;</span> <span class="attr">y</span>=<span class="string">&quot;10&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;30&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;12&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">		  <span class="attr">style</span>=<span class="string">&quot; fill:#BA5C25; stroke:#1EAFAE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>渐变</strong>表示一种颜色平滑过渡到另一种颜色。SVG中有<code>&lt;linearGradient&gt;</code>线性渐变和<code>&lt;radialGradient&gt;</code>放射性渐变。渐变的标签写在<code>&lt;defs&gt;&lt;/defs&gt;</code>标签内，defs用于定义可重复利用的图形元素，在图形中通过id引用defs标签里定义的效果，达到重用的目的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">&quot;grad2&quot;</span> <span class="attr">x1</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stop-color:#FFFAF0;stop-opacity:1&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stop-color:#BA5C25;stop-opacity:1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linearGradient</span> <span class="attr">id</span>=<span class="string">&quot;grad1&quot;</span> <span class="attr">x1</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;0%&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;0%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stop-color:#FFFAF0;stop-opacity:1&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">stop</span> <span class="attr">offset</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stop-color:#1EAFAE;stop-opacity:1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">linearGradient</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;20&quot;</span> <span class="attr">y</span>=<span class="string">&quot;10&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(#grad1)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;100&quot;</span> <span class="attr">y</span>=<span class="string">&quot;145&quot;</span> &gt;</span>水平渐变与垂直方向渐变<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;20&quot;</span> <span class="attr">y</span>=<span class="string">&quot;180&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(#grad2)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-02-1003-svg-filter-linear-gradien.png" alt="svg-filter-linear-gradien"></p>
<p>linearGradient标签里，x1、y1、x2、y2定义渐变的方向，<code>x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;0%&quot;</code>是水平渐变，改为<code>x2=&quot;0%&quot; y2=&quot;100%&quot;</code>则为垂直渐变，offset定义渐变开始的位置，stop-color定义边界位置的颜色。</p>
<p><strong>滤镜</strong><code>&lt;filter&gt;</code>能使图形更具有艺术效果，对源图形使用滤镜能修改其显示结果。滤镜也是写在<code>&lt;defs&gt;&lt;/defs&gt;</code>标签内。例如以下代码定义了一个高斯模糊的滤镜，并应用到矩形rect上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span> <span class="attr">id</span>=<span class="string">&quot;gaussianBlur&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">feGaussianBlur</span> <span class="attr">in</span>=<span class="string">&quot;SourceGraphic&quot;</span> <span class="attr">stdDeviation</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;300&quot;</span> <span class="attr">y</span>=<span class="string">&quot;100&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">filter</span>=<span class="string">&quot;url(#gaussianBlur)&quot;</span> </span></span><br><span class="line"><span class="tag">		  <span class="attr">style</span>=<span class="string">&quot; fill:#BA5C25; stroke:#1EAFAE; stroke-width:4&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-02-1003-svg-filter-gaussian.png" alt="svg-filter-gaussian"></p>
<p>feGaussianBlur标签定义了一个高斯模糊的滤镜，in是使用滤镜的对象，此处是源图形用SourceGraphic表示，<br>stdDeviation是高斯模糊唯一的参数,数值越大，模糊程度越高。在矩形中通过 <code>filter = &quot;url(#gaussianBlur)&quot;</code> 代码使用我们创建的滤镜。</p>
<p>滤镜的种类很多，例如feMorphology、feGaussianBlur、feFlood等等，还有定义光源的滤镜feDistantLight、fePointLight、feSpotLight，都是以fe开头的。feOffset用于生成图形的阴影效果，结合高斯模糊可以构建图形的投射阴影，增强表现力。</p>
<h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p>用<code>&lt;circle&gt;</code>标签绘制圆形，圆形的参数是3个：</p>
<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-03-1003-svg-circle.png" alt="svg-circle"></p>
<ul>
<li>cx：圆心的x坐标，可以记为circle-x；</li>
<li>cy：圆心的y坐标；</li>
<li>r：圆的半径；</li>
</ul>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p><code>ellipse</code>表示椭圆，椭圆的参数与圆形类似，但半径分为了水平半径和垂直半径；</p>
<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-04-1003-svg-circle-el.png" alt="svg-circle-ellipse"></p>
<ul>
<li>cx：椭圆圆心的x坐标；</li>
<li>cy：圆心的y坐标；</li>
<li>rx：椭圆的水平半径；</li>
<li>ry：椭圆的垂直半径；</li>
</ul>
<p>圆和椭圆的示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;120&quot;</span> <span class="attr">y</span>=<span class="string">&quot;80&quot;</span> <span class="attr">r</span>=<span class="string">&quot;70&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;330&quot;</span> <span class="attr">y</span>=<span class="string">&quot;80&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;76&quot;</span></span></span><br><span class="line"><span class="tag">   		<span class="attr">style</span>=<span class="string">&quot; fill:#BA5C25; stroke:#1EAFAE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><code>&lt;svg&gt;</code>标签里有多个形状时，会按照顺序渲染，也就是写在后面的就覆盖到之前的图形上。利用覆盖和叠加可以形成很多有趣实用的效果，例如点的涟漪效果等。</p>
<h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><p>用<code>&lt;line&gt;</code>标签绘制一条线，用D3绘制柱状图时，坐标轴就需要用到line标签，各种统计图表普遍用到了line在坐标轴等元素中；</p>
<p>线段<code>&lt;line&gt;</code>的参数有4个：</p>
<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-05-1003-svg-line.png" alt="svg-line"></p>
<ul>
<li>x1：起点的x坐标；</li>
<li>y1：起点的y坐标；</li>
<li>x2：终点的x坐标；</li>
<li>y2：终点的y坐标；</li>
</ul>
<p>一个线段的例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;30&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;16&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;120&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke:#1EAFAE; stroke-width:3&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="折线和多边形"><a href="#折线和多边形" class="headerlink" title="折线和多边形"></a>折线和多边形</h3><p>折线<code>&lt;polyline&gt;</code>和多边形<code>&lt;polygon&gt;</code>的参数是一样的，因此放一起对比着看，它们都是只有一个points参数，表示一系列的点坐标，效果的不同之处在于多边形会将终点和起点连接起来。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">&quot;130,150 190,85 30,20 50,75 50,150 &quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot; fill:#BA5C25; stroke:#1EAFAE; stroke-width:3; opacity:0.6&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;130,150 190,85 30,20 50,75 50,150 &quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot; fill:#BA5C25; stroke:#1EAFAE; stroke-width:3; opacity:0.6&quot;</span> <span class="attr">transform</span>=<span class="string">&quot;translate(180,0)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-06-1003-svg-poly.png" alt="svg-poly"></p>
<p>折线通常用来绘制折线图，多边形可以用来绘制面积图、区间注释等等。上面代码中<code>transform=&quot;translate(180,0)&quot;</code>将polyline折线的坐标原点移动到svg元素的[180,0]处，效果就是polyline整体向右边平移了180像素。</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p><code>&lt;path&gt;</code>标签的功能最丰富也最强大，表示一段路径，前面列举的图形都可以用路径画出来。与折线类似，path也是通过给定的一系列点坐标来绘制。在D3中绘制地图时，会经常用到此标签，读取geojson数据，然后绘制一段段路径。如果使用过Python里的turtle库，就会对SVG绘制路径的过程感到轻车熟路，当然没用过也不难去理解绘制的过程。<code>&lt;path&gt;</code>的写法是：给出一个坐标点，在坐标点前面添加一个英文字母，用于标识如何运动到此坐标点。英文字母按照功能可分为五类。大写表示绝对坐标，小写表示相对坐标。</p>
<ul>
<li>移动类： M即moveto，表示将画笔移动到指定坐标，不绘制移动的路径；</li>
<li>直线类：L，画直线到指定坐标(lineto)；H，画水平直线到指定坐标(horizontal lineto)；V，画垂直直线到指定坐标(vertical lineto)；</li>
<li>曲线类：C，curveto，画三次贝塞尔曲线经两个指定控制点到达终点坐标；S，smooth curveto，与前一条三次贝塞尔曲线相连,第一个控制点为前一条曲线第二个控制点的对称点,只需输入第二个控制点和终点,即可绘制一个三次贝塞尔曲线；Q，quadratic Bézier curveto，画二次贝塞尔曲线经一个指定控制点到达终点坐标；T，Shorthand/smooth quadratic Bézier curveto，与前一条二次贝塞尔曲线相连,控制点为前一条二次贝塞尔曲线控制点的对称点,只需输入终点,即可绘制一个二次贝塞尔曲线；</li>
<li>弧线类：A，elliptical arc，画椭圆曲线到指定坐标；</li>
<li>闭合类：Z，closepath，绘制一条直线连接终点和起点，用来封闭图形；</li>
</ul>
<p>一个路径的例子如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M 100 350 q 150 -300 300 0&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">style</span>=<span class="string">&quot;fill:#fff; stroke:#1EAFAE; stroke-width:3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-07-1003-svg-path.png" alt="svg-path"></p>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>在SVG中可以使用<code>&lt;text&gt;</code>标签绘制文字，其属性有：</p>
<ul>
<li>x：文字位置的x坐标。</li>
<li>y：文字位置的y坐标。</li>
<li>dx：相对于当前位置在x方向上平移的距离(值为正则往右，负则往左)；</li>
<li>dy：相对于当前位置在y方向上平移的距离(值为正则往下，负则往上)。</li>
<li>textLength：文字的显示长度(不足则拉长,足则压缩)</li>
<li>rotate：旋转角度(顺时针为正,逆时针为负)。</li>
</ul>
<p>因为文本内容是写在标签外的，因此用的是成对显示的标签，不是写<code>&lt;text x=&quot;20&quot; y=&quot;30&quot;/&gt;</code>而是写``<text x="20" y="30">内容</text>`。</p>
<p>用rotate参数的旋转是每个字符都旋转，因此要整体旋转还是用transform里的rotete。两者对比效果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span> <span class="attr">rotate</span>=<span class="string">&quot;40&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:#1EAFAE&quot;</span> &gt;</span>蛰虫始航<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;55&quot;</span> <span class="attr">rotate</span>=<span class="string">&quot;40&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:#1EAFAE&quot;</span> &gt;</span>lynsdata<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;30&quot;</span> <span class="attr">y</span>=<span class="string">&quot;80&quot;</span> <span class="attr">transform</span>=<span class="string">&quot;rotate(40 20,40)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:#1EAFAE&quot;</span>&gt;</span>蛰虫始航<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-08-1003-svg-text-rotate.png" alt="svg-text-rotate"></p>
<p>文本内容可以用到html其他标签，用<code>&lt;tspan&gt;</code>对文本里的某一部分文字单独定义样式，示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;30&quot;</span> <span class="attr">y</span>=<span class="string">&quot;50&quot;</span> <span class="attr">dx</span>=<span class="string">&quot;-5&quot;</span> <span class="attr">dy</span>=<span class="string">&quot;5&quot;</span> <span class="attr">textLength</span>=<span class="string">&quot;100&quot;</span> &gt;</span></span><br><span class="line">    lynsdata <span class="tag">&lt;<span class="name">tspan</span> <span class="attr">fill</span>=<span class="string">&quot;#1EAFAE&quot;</span>&gt;</span>D3-svg<span class="tag">&lt;/<span class="name">tspan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>标记<code>&lt;marker&gt;</code>是SVG中一个重要的概念，增强了svg基本形状的表达力，标记贴附于path、line、polyline、<br>polygon元素上。和滤镜filter一样，标记marker也是定义在<code>&lt;defs&gt;&lt;/defs&gt;</code>中，defs用于定义可重复利用的图形元素。一个典型的应用是基于路径排列文本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">&quot;txtpath&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M70,30 a1,1 0 0,0 120,0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:#1EAFAE&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textPath</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#txtpath&quot;</span>&gt;</span>蛰虫始航 D3-svg-text<span class="tag">&lt;/<span class="name">textPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有就是给线段添加箭头：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">marker</span> <span class="attr">id</span>=<span class="string">&quot;arrow&quot;</span> <span class="attr">markerUnits</span>=<span class="string">&quot;strokeWidth&quot;</span> <span class="attr">markerWidth</span>=<span class="string">&quot;12&quot;</span> <span class="attr">markerHeight</span>=<span class="string">&quot;12&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">viewBox</span>=<span class="string">&quot;0 0 12 12&quot;</span> <span class="attr">refX</span>=<span class="string">&quot;6&quot;</span> <span class="attr">refY</span>=<span class="string">&quot;6&quot;</span> <span class="attr">orient</span>=<span class="string">&quot;auto&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M2,2 L10,6 L2,10 L6,6 L2,2&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill: #000;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">marker</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;60&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;160&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;260&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;80&quot;</span> <span class="attr">marker-end</span>=<span class="string">&quot;url(#arrow)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke:#1EAFAE; stroke-width:2&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M200,210 T160,165 T240,120 T370,100 T420,150&quot;</span></span></span><br><span class="line"><span class="tag">	  <span class="attr">marker-mid</span>=<span class="string">&quot;url(#arrow)&quot;</span> <span class="attr">marker-end</span>=<span class="string">&quot;url(#arrow)&quot;</span> </span></span><br><span class="line"><span class="tag">	  <span class="attr">style</span>=<span class="string">&quot;stroke:#1EAFAE; stroke-width:2; fill:#fff&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下图，在<code>&lt;defs&gt;</code>里定义了id为arrow的标记，在path里通过<code>marker-end=&quot;url(#arrow)&quot; </code>调用。标记的位置属性有marker-start、marker-mid和marker-end。</p>
<p><img src="/2020/10/02/viz-d3-04-svg-mark/viz-d3-notes-all/31-03-09-1003-svg-marker.png" alt="svg-marker"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SVG是HTML里的一种标签，D3的可视化功能大部分通过操纵SVG里的图形元素达成，虽然D3可以直接操作div或其他原生HTML元素来绘图，但操纵SVG更简便，也更可靠，SVG生成的图形效果更一致，对各种浏览器都兼容，而操纵div则不然，可能在某些版本的浏览器里就解析出期待之外的效果。而且SVG很强大，绘图速度更快，因此不难选择。SVG的标签和规范有很多内容，还能深入学习的有各种滤镜、放射性渐变、强大的路径<code>&lt;path&gt;</code>标签等，文中的内容对于D3可视化基本够用，后续再深入。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://book.douban.com/subject/24748670/">数据可视化实战：使用D3设计交互式图表</a></li>
<li><a href="https://www.runoob.com/svg/svg-intro.html">菜鸟教程：SVG</a></li>
<li><a href="https://c.runoob.com/more/svgeditor/">在线SVG编辑器</a></li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title>D3库实践笔记之比例尺与坐标轴 |可视化系列35</title>
    <url>/2020/10/03/viz-d3-05-scale-axis.html</url>
    <content><![CDATA[<p>对数据进行可视化时，我们可以直接把数据值映射为像素值，但是如果数值过小或过大直接用像素得到的图形就很难看甚至无法辨别，例如不能值是10000就绘制1万像素长的矩形，数值全是[0,1]的值不能全部绘制小于1个像素的图，d3提供了<strong>比例尺</strong>(scale)来解决这个问题。从数据到屏幕图形的像素有一个数据变换的过程，在输入值范围（值域）不确定的情况，我们限定输出的范围，这就是比例尺的作用。</p>
<h3 id="比例尺生成器"><a href="#比例尺生成器" class="headerlink" title="比例尺生成器"></a>比例尺生成器</h3><a id="more"></a>

<p>D3 提供了比例尺函数生成器。例如<code>var scale = d3.scaleLinear().domain([100, 500]).range([0, 100]);</code>比例尺scale将输入数据从[100,500]转换在[0,100]之间，并且保持数据的大小关系。</p>
<p>比例尺将“一个区间”的数据映射到“另一个区间”。线性比例尺可以理解为我们熟悉的一次函数f(x)=ax+b。通过<code>d3.scaleLinear()</code>可以初始化一个线性比例尺，在d3的3.x版本及之前版本中使用的是<code>d3.scale.linear()</code>，在v5.x及之后的v6版本中，都用的<code>d3.scaleLinear()</code>，原先的d3.scale已经undefined未定义了。</p>
<p>定义一个比例尺后可以传入数值，会输出转换后的值，就类似于一个映射函数y=f(x)的使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scale = d3.scaleLinear()</span><br><span class="line">              .domain([<span class="number">30</span>, <span class="number">80</span>]) <span class="comment">//设置定义域</span></span><br><span class="line">              .range([<span class="number">0</span>,<span class="number">1000</span>]); <span class="comment">//值域</span></span><br><span class="line"></span><br><span class="line">scale(<span class="number">76</span>); <span class="comment">//输出 920</span></span><br><span class="line">scale(<span class="number">80</span>); <span class="comment">//结果是1000</span></span><br></pre></td></tr></table></figure>

<p>比例尺经常需要和坐标轴结合使用。</p>
<h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><p>通过append()、attr()、style()等接口只是将数据映射为图形，离统计图还有些差距。比如我们需要有标识数据大小的数轴、标题、坐标轴标签等。其中标题通过text来绘制，图形颜色等通过style设置，数轴（坐标轴）可以拆解为线段+文本的组合，可以通过svg的line和text来画，需要注意的是坐标原点的位置以及y轴方向的问题。实际上d3提供了绘制坐标轴的接口，省去了很多工作量。在D3的v5.x及之后的版本中，通过<code>d3.axisBottom(scale)</code>绘制x轴(水平方向)、<code>d3.axisLeft(scale)</code>绘制y坐标轴，其中调用了我们定义的比例尺scale。在v3.x版本使用的是 <code>xAxis = d3.svg.axis().scale(xScale).orient(&quot;bottom&quot;)</code>;</p>
<p>基于比例尺和坐标轴绘制一个柱状图如下：</p>
<p><img src="/2020/10/03/viz-d3-05-scale-axis/viz-d3-notes-all/31-02-05-1002-d3-bar.png" alt="d3绘制柱状图"></p>
<p>将坐标轴的绘制封装为<code>renderXAxis()</code>及<code>renderYAxis()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderXAxis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> axis_len=w-<span class="number">2</span>*m;</span><br><span class="line">	<span class="keyword">var</span> scale=d3.scaleLinear().domain([<span class="number">0</span>,<span class="number">60</span>]).range([<span class="number">0</span>,axis_len]);</span><br><span class="line">	<span class="keyword">var</span> xaxis=d3.axisBottom(scale); <span class="comment">//.tickFormat(function(d)&#123; return d.x;&#125;);</span></span><br><span class="line">	svg.append(<span class="string">&quot;g&quot;</span>).attr(<span class="string">&quot;transform&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">&quot;translate(&quot;</span>+m+<span class="string">&quot;,&quot;</span>+(h-m)+<span class="string">&quot;)&quot;</span>&#125;)</span><br><span class="line">	   .attr(<span class="string">&quot;class&quot;</span>,<span class="string">&#x27;x-axis&#x27;</span>).call(xaxis);</span><br><span class="line">	d3.selectAll(<span class="string">&quot;g.x-axis g.tick&quot;</span>).append(<span class="string">&quot;line&quot;</span>)</span><br><span class="line">	  .classed(<span class="string">&quot;grid-line&quot;</span>,<span class="literal">true</span>).attr(<span class="string">&#x27;x1&#x27;</span>,<span class="number">0</span>).attr(<span class="string">&#x27;y1&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">	  .attr(<span class="string">&#x27;x2&#x27;</span>,<span class="number">0</span>).attr(<span class="string">&#x27;y2&#x27;</span>,-(h-<span class="number">2</span>*m));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderYAxis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> axis_len=h-<span class="number">2</span>*m;</span><br><span class="line">	<span class="keyword">var</span> scale=d3.scaleLinear().domain([<span class="number">100</span>,<span class="number">0</span>]).range([<span class="number">0</span>,axis_len]);</span><br><span class="line">	<span class="keyword">var</span> yaxis=d3.axisLeft(scale);</span><br><span class="line">	svg.append(<span class="string">&quot;g&quot;</span>).attr(<span class="string">&quot;transform&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">&quot;translate(&quot;</span>+m+<span class="string">&quot;,&quot;</span>+m+<span class="string">&quot;)&quot;</span>&#125;)</span><br><span class="line">	   .attr(<span class="string">&quot;class&quot;</span>,<span class="string">&#x27;y-axis&#x27;</span>).call(yaxis);</span><br><span class="line">	d3.selectAll(<span class="string">&quot;g.y-axis g.tick&quot;</span>).append(<span class="string">&quot;line&quot;</span>).classed(<span class="string">&quot;grid-line&quot;</span>,<span class="literal">true</span>).attr(<span class="string">&#x27;x1&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">	  .attr(<span class="string">&#x27;y1&#x27;</span>,<span class="number">0</span>).attr(<span class="string">&#x27;x2&#x27;</span>,axis_len).attr(<span class="string">&#x27;y2&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>具体来看坐标轴的绘制，首先根据数据集的范围(包括最大最小值和数据行数)确定定义域，根据建立的svg长宽确定值域，然后初始化一个线性比例尺，<code>scale=d3.scaleLinear().domain([100,0]).range([0,460])</code>，因为SVG的坐标原点在左上角(具体描述可以参考<a href>SVG篇</a>)，，在建立y轴时生成的比例尺是将[n,0]映射到[0,460]，而x轴用的比例尺是从[0,m]映射到[0,460]。生成比例尺后使用<code>d3.axisBottom(scale)</code>生成x轴对象，再通过<code>d3.selectAll().append(&quot;line&quot;)</code>绘制x坐标轴的具体线段，用<code>d3.axisLeft(scale)</code>生成y轴再绘制y轴的具体线段。</p>
<p><img src="/2020/10/03/viz-d3-05-scale-axis/viz-d3-notes-all/31-04-02-1004-d3-xaxis.png" alt="d3-renderXAxis"></p>
<p>坐标轴在后续的绘图中还会经常用到，写法都是这一套路。</p>
<p>D3不仅提供了线性比例尺可用，还有序数比例尺(实现{1:’r’,2:’b’,3:’g’})、对数比例尺、平方根比例尺等。对于连续值，可以使用的比例尺有线性比例尺、对数(.scaleLog)、指数(.scalePow)、时间序列(.scaleTime)以及弧度(scaleRadial)。</p>
<p>比例尺初始化除了写<code>scale=d3.scaleLinear().domain([100,0]).range([0,460])</code>，还可以简写为<code>d3.scaleLinear([10, 130], [0, 960])</code>，两者效果一致，颜色值也可以和数值建立映射，在填充颜色中经常需要用到，比例尺的一些示例可以看以下代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = d3.scaleLinear()</span><br><span class="line">              .domain([<span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">              .range([<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;steelblue&quot;</span>]);</span><br><span class="line">color(<span class="number">20</span>); <span class="comment">//输出是 &quot;#9a3439&quot;</span></span><br><span class="line"><span class="keyword">var</span> ssqrt=d3.scaleSqrt() <span class="comment">//对数比例尺的具体形式，平方根</span></span><br><span class="line">    .domain([<span class="number">0</span>,<span class="number">800000</span>]).range([<span class="number">0</span>,<span class="number">30</span>]);</span><br><span class="line">ssqrt(<span class="number">100020</span>) <span class="comment">//输出 10.60766</span></span><br><span class="line"><span class="comment">//平方根比例尺在把数据映射为散点图中经常会用到，数据变成半径前经过平方根运算；</span></span><br><span class="line"><span class="keyword">var</span> tscale = d3.scaleTime() <span class="comment">//时间序列和像素值的对应</span></span><br><span class="line">    .domain([<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2010</span>,<span class="number">0</span>,<span class="number">1</span>), <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">4</span>)])</span><br><span class="line">    .range([<span class="number">0</span>,<span class="number">480</span>]);</span><br><span class="line">tscale(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">5</span>,<span class="number">18</span>)) <span class="comment">//得到 418.788</span></span><br><span class="line"><span class="keyword">var</span> color = d3.scaleQuantize() <span class="comment">//分段比例尺</span></span><br><span class="line">    .domain([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    .range([<span class="string">&quot;brown&quot;</span>, <span class="string">&quot;steelblue&quot;</span>]);</span><br><span class="line"></span><br><span class="line">color(<span class="number">0.49</span>); <span class="comment">// &quot;brown&quot;</span></span><br><span class="line">color(<span class="number">0.51</span>); <span class="comment">// &quot;steelblue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> width = d3.scaleQuantize()</span><br><span class="line">    .domain([<span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">    .range([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">width(<span class="number">50</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> color = d3.scaleThreshold() <span class="comment">//阈值比例尺</span></span><br><span class="line">    .domain([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    .range([<span class="string">&quot;red&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;green&quot;</span>]);</span><br><span class="line"></span><br><span class="line">color(-<span class="number">1</span>);   <span class="comment">// 区间外的值映射到边界&quot;red&quot;</span></span><br><span class="line">color(<span class="number">0.5</span>);  <span class="comment">// &quot;white&quot;</span></span><br><span class="line">color(<span class="number">1000</span>); <span class="comment">// &quot;green&quot;</span></span><br><span class="line"></span><br><span class="line">d3.schemeCategory10  </span><br><span class="line"><span class="comment">//输出10个预设颜色的数组 在v3.x版本是写 d3.scale.category10()</span></span><br><span class="line">#[<span class="string">&quot;#1f77b4&quot;</span>, <span class="string">&quot;#ff7f0e&quot;</span>, <span class="string">&quot;#2ca02c&quot;</span>, <span class="string">&quot;#d62728&quot;</span>,…]</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>比例尺解决的是输入数据过大或过小无法直接对应到像素值的问题，比例尺可以将数据从一个区间（定义域）映射到另一个区间（值域），在实际的可视化中线性比例尺和平方根比例尺使用最广泛，通过<code>scale = d3.scaleLinear().domain([1,2]).range([0,10])</code>可以初始化一个线性比例尺。坐标轴的绘制需要依赖比例尺的建立，再通过<code>d3.axisBottom(scale)</code>生成x轴对象，通过<code>d3.axisLeft(scale)</code>绘制y坐标轴。</p>
<p>有了比例尺和svg的各种点线面形状，我们已经可以绘制各种统计图表了，但现在绘制的图表都是静态的，作为一个优秀的前端可视化库，d3对动态交互的支持也非常厉害。下一篇我们实践d3绘制交互可视化图表。</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title>D3库实践笔记之图表交互 |可视化系列36</title>
    <url>/2020/10/03/viz-d3-06-interactive.html</url>
    <content><![CDATA[<p>对于前端可视化库来说，交互效果是其基本功能，需要有优雅的效果和简洁的API才能出彩，而如果一个前端可视化工具只能生成静态图表，绝对会显得格格不入，因为在前端拥有交互功能并不复杂。与图表的交互，是指图表元素能根据用户的键盘鼠标操作做出相应的反应，例如悬停高亮、缩放、漫游、拖动节点、点击涟漪效果等等。</p>
<a id="more"></a>

<p>对于HTML元素来说，要响应用户的行为，可以在图形元素上添加一个或多个事件监听器，当监测到对应行为时，执行某些响应代码。</p>
<h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><p>JavaScript 有一个事件模型，在这个模型中，“事件”由发生的事情来触发，比如用户通过键鼠或触摸屏输入信息。大多数情况下，没人监听事件，事件就自生自灭，我们就无感知。而如果我们添加事件监听器后，触发对应的事件就能调用这个监听器的设置，具体来说就是执行某些代码。</p>
<p>D3的选择集有一个方法<code>on()</code>，用来设定事件的监听器。在可视化绘制时我们普遍用了<code>var svg=d3.select(&quot;body&quot;).append(&quot;svg&quot;)</code>或类似的代码，就可以使用以下代码给元素绑定事件监听器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rect=svg.selectAll(<span class="string">&quot;rect&quot;</span>).data(ds).enter().append(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">            .on(<span class="string">&quot;mouseover&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">//触发事件后执行一些操作</span></span><br><span class="line">                 d3.select(<span class="built_in">this</span>).style(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;#BA5C25&quot;</span>);</span><br><span class="line">	            &#125;)</span><br><span class="line">            .on(<span class="string">&quot;mouseout&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">		         d3.select(<span class="built_in">this</span>).style(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码可以给柱状图添加悬停高亮的交互效果，mouseover是事件名称，function()是监听器函数。当鼠标移动到某个柱子上时，触发一个mouseover事件，调用function()将所d3所选中的柱的填充色修改为设置的颜色。演示如下：</p>
<p>【gif】</p>
<p>为图表赋予交互能力只要两步:</p>
<ul>
<li>给选择集绑定事件监听器；</li>
<li>定义响应行为。</li>
</ul>
<h3 id="键鼠事件"><a href="#键鼠事件" class="headerlink" title="键鼠事件"></a>键鼠事件</h3><p>在交互中最常见的行为当然要属鼠标触发的，经典的鼠标行为有单机、双击、选中拖动等。常用的事件如下：</p>
<ul>
<li>click：单击事件，鼠标单击某个元素触发，相当于mousedown和mouseup组合在一起；</li>
<li>dblclick：鼠标双击事件；</li>
<li>mouseover：鼠标的光标放在某元素上(悬停在元素上)；</li>
<li>mouseout：光标从某元素上移出来时；</li>
<li>mousedown：鼠标按钮被按下；</li>
<li>mouseup：鼠标按钮被松开；</li>
</ul>
<p>以下代码为图表标题添加了一个单击事件的监听器，当点击标题元素，会将标题<strong>加粗</strong>并在控制台输出当前标题文本；而如果当前是加粗的效果，点击后是变成非加粗文本，也就是点击会切换加粗和正常文本两种效果；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var svg=d3.select(&quot;body&quot;).append(&quot;svg&quot;)  等等</span></span><br><span class="line">svg.append(<span class="string">&quot;text&quot;</span>).attr(<span class="string">&quot;x&quot;</span>,<span class="number">200</span>).attr(<span class="string">&quot;y&quot;</span>,<span class="number">20</span>)</span><br><span class="line">.text(<span class="string">&quot;D3绘制柱状图&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (d3.select(<span class="built_in">this</span>).style(<span class="string">&quot;font-weight&quot;</span>)==<span class="string">&quot;bold&quot;</span>)&#123;</span><br><span class="line">		d3.select(<span class="built_in">this</span>).text(<span class="string">&quot;D3绘制柱状图&quot;</span>).style(<span class="string">&quot;font-weight&quot;</span>,<span class="string">&quot;normal&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		d3.select(<span class="built_in">this</span>).text(<span class="string">&quot;D3绘制柱状图-click&quot;</span>).style(<span class="string">&quot;font-weight&quot;</span>,<span class="string">&quot;bold&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(d3.select(<span class="built_in">this</span>).text());<span class="comment">//输出标题文本</span></span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>



<p><img src="/2020/10/03/viz-d3-06-interactive/viz-d3-notes-all/31-05-02-1004-d3-click-title.png" alt="d3-click-title"></p>
<p>键盘事件也很实用，特别是可以结合一些控制鼠标按键的自动化程序。键盘事件有三种：</p>
<ul>
<li>keydown：当用户按下任意键时触发，按住不放会重复触发此事件，这一事件不会区分字母的大小写，例如“A”和“a”被视为一致；</li>
<li>keypress：当用户按下字符键(大小写字母、数字、加号、等号、回车等)时触发，按住不放会重复触发此事件，该事件就会区分字母的大小写；</li>
<li>keyup：当用户松开按键时触发，该事件不区分字母的大小写；</li>
</ul>
<p>keydown和keypress事件的区别在于keydown用于任意键的事件，而keypress用于字符键，如果只需要处理字母数字类的响应,或是要对大小写字母分别处理的时候，使用keypress；如果要处理上下左右(↑→)、Shift、Ctrl等特殊键的输入，使用keydown。</p>
<p>随着各种移动设备的普及，触屏有着广泛的使用场景，无论是我们的手机还是触屏的显示器，触屏离我们很近。常用的触屏事件有以下三种：</p>
<ul>
<li>touchstart：当触摸点被放在触摸屏上时，也就是触摸到某个元素；</li>
<li>touchmove：当触摸点在触摸屏上移动时；</li>
<li>touchend：当触摸点从触摸屏上拿开时；</li>
</ul>
<p>我们可以为触摸事件配置点击事件以及拖动事件，也就是触摸有选中并拖动的效果。</p>
<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>通过<code>d3.zoom().on(&quot;zoom&quot;, zoomed)</code>配置缩放的交互，具体用法如下。需要说明的是在v3.x版本中是使用<code>d3.behavior.zoom()</code>创建缩放行为，而v5.x及之后的版本是<code>d3.zoom()</code>，不再有behavior这一层抽象；</p>
<p>给矩形和坐标轴添加缩放交互响应：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> zoom = d3.zoom()</span><br><span class="line">    .scaleExtent([<span class="number">0.1</span>, <span class="number">90</span>])</span><br><span class="line">    <span class="comment">//.translateExtent([[-100, -100], [60+ 90, 60+ 100]])</span></span><br><span class="line">    .on(<span class="string">&quot;zoom&quot;</span>, zoomed);</span><br><span class="line">    svg.call(zoom);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">zoomed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> rects=svg.selectAll(<span class="string">&quot;rect&quot;</span>);</span><br><span class="line">            rects.attr(<span class="string">&quot;transform&quot;</span>, d3.event.transform);</span><br><span class="line">            tt.attr(<span class="string">&quot;transform&quot;</span>, d3.event.transform);</span><br><span class="line">            gX.call(xAxis.scale(d3.event.transform.rescaleX(x)));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/03/viz-d3-06-interactive/viz-d3-notes-all/31-05-06-d3-zoom-gif.gif" alt="d3-zoom"></p>
<p>绑定<code>d3.zoom()</code>的行为后，就具备了漫游的交互，zoom不仅仅可以放大缩小，还可以拖动元素进行漫游。</p>
<p>漫游是一种拖拽效果，但在力导向图等的交互中，我们希望有更纯粹的拖拽元素效果，因此d3也有<code>d3.drag()</code>用于创建拖拽行为。和zoom一样的，在v5.x版本中是使用<code>d3.drag()</code>而v3.x版本是使用<code>d3.behavior.drag()</code>。drag没有缩放功能。</p>
<p>drag和zoom一般通过call调用，写在<code>svg.append(&quot;rect&quot;)</code>语句中变成<code>svg.append(&quot;rect&quot;).call(zoom)</code>，或者写<code>svg.call(zoom)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">drag = <span class="function"><span class="params">simulation</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dragstarted</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!event.active) simulation.alphaTarget(<span class="number">0.3</span>).restart();</span><br><span class="line">    event.subject.fx = event.subject.x;</span><br><span class="line">    event.subject.fy = event.subject.y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dragged</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.subject.fx = event.x;</span><br><span class="line">    event.subject.fy = event.y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dragended</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!event.active) simulation.alphaTarget(<span class="number">0</span>);</span><br><span class="line">    event.subject.fx = <span class="literal">null</span>;</span><br><span class="line">    event.subject.fy = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> d3.drag()</span><br><span class="line">      .on(<span class="string">&quot;start&quot;</span>, dragstarted)</span><br><span class="line">      .on(<span class="string">&quot;drag&quot;</span>, dragged)</span><br><span class="line">      .on(<span class="string">&quot;end&quot;</span>, dragended);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> node = svg.append(<span class="string">&quot;g&quot;</span>).attr(<span class="string">&quot;stroke&quot;</span>, <span class="string">&quot;#fff&quot;</span>).attr(<span class="string">&quot;stroke-width&quot;</span>, <span class="number">1.5</span>)</span><br><span class="line">      .selectAll(<span class="string">&quot;circle&quot;</span>).data(nodes).join(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;r&quot;</span>, <span class="number">5</span>).attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;#CAE9E0&quot;</span>)</span><br><span class="line">      .call(drag(simulation));</span><br></pre></td></tr></table></figure>



<p>[gif]</p>
<h3 id="悬停文本标签"><a href="#悬停文本标签" class="headerlink" title="悬停文本标签"></a>悬停文本标签</h3><p>要实现鼠标悬停在图形元素上时显示其标签的tooltip效果，仍然使用选择集的on监听mouseover和mouseout事件，只是把响应的代码从修改选定的rect元素变成了增加文本标签元素，具体实现是可以选择加svg的<code>&lt;text&gt;</code>标签或者加HTML的<code>&lt;div&gt;</code>标签，按需使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">svg.selectAll(<span class="string">&quot;rect&quot;</span>).data(dataset).enter().append(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">   .attr(<span class="string">&quot;class&quot;</span>,<span class="string">&quot;bar&quot;</span>).style(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>)</span><br><span class="line">   .attr(<span class="string">&quot;x&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;<span class="keyword">return</span> i*<span class="number">75</span>+<span class="number">75</span> +<span class="string">&quot;px&quot;</span>;&#125;)</span><br><span class="line">   .attr(<span class="string">&quot;y&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> (<span class="number">375</span>-d*<span class="number">3.5</span>) +<span class="string">&quot;px&quot;</span>;&#125;)</span><br><span class="line">   .attr(<span class="string">&quot;width&quot;</span>,<span class="number">50</span>).attr(<span class="string">&quot;height&quot;</span>,<span class="function"><span class="params">d</span>=&gt;</span>d*<span class="number">3.5</span> +<span class="string">&quot;px&quot;</span>)</span><br><span class="line">   .on(<span class="string">&quot;mouseover&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      d3.select(<span class="built_in">this</span>).append(<span class="string">&quot;title&quot;</span>).attr(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;tooltip&quot;</span>)</span><br><span class="line">        .text(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Value of this bar: &quot;</span> + d;</span><br><span class="line">         &#125;);</span><br><span class="line">	&#125;)</span><br><span class="line">   .on(<span class="string">&quot;mouseout&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">   	    d3.select(<span class="string">&quot;#tooltip&quot;</span>).remove();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<p>[gif]</p>
<h3 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h3><p>过渡动画同样通过事件监听和缓动实现过渡效果和数据更新，实现友好的交互；还有便是用好<code>.transition()</code>，在方法链上，要把transition的调用插到选择元素之后，改变任何属性之前。transition()默认情况延迟(delay)为0ms，持续时长(duration)为250ms，可以自行设置这两个参数。</p>
<p>例如对一个矩形的变换应用过渡效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">svg.append(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">.attr(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;steelblue&quot;</span>)</span><br><span class="line">.attr(<span class="string">&quot;x&quot;</span>,<span class="number">30</span>)</span><br><span class="line">.attr(<span class="string">&quot;y&quot;</span>,<span class="number">30</span>)</span><br><span class="line">.attr(<span class="string">&quot;width&quot;</span>,<span class="number">100</span>)</span><br><span class="line">.attr(<span class="string">&quot;height&quot;</span>,<span class="number">30</span>)</span><br><span class="line">.transition() <span class="comment">//在更新width之前调用</span></span><br><span class="line">.attr(<span class="string">&quot;width&quot;</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure>



<h3 id="和HTML元素交互"><a href="#和HTML元素交互" class="headerlink" title="和HTML元素交互"></a>和HTML元素交互</h3><p>D3作为一个JavaScript库，自然可以和原生的HTML元素进行交互，例如响应按钮的点击事件，在html中配置了按钮和点击监测，<code>&lt;button type=&quot;button&quot; onclick=&quot;update()&quot;&gt; 更新 &lt;/button&gt;</code>，点击按钮触发事件，在函数update里面调用d3的绘制代码，实现交互。</p>
<p>状态条是很实用的元素，通过状态条调节d3图表的参数，例如下面通过状态条调节绘制矩形的填充颜色，给状态条添加了onchange的事件监听器，有变化时更新矩形的颜色。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//html中需要额外引入 &lt;script src=&quot;https://unpkg.com/d3-simple-slider&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="keyword">var</span> num2hex = <span class="function"><span class="params">rgb</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rgb.map(<span class="function"><span class="params">color</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s = color.toString(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (s.length === <span class="number">1</span>) &#123;</span><br><span class="line">          s= <span class="string">&#x27;0&#x27;</span> + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;).join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rgb = [<span class="number">0</span>,<span class="number">175</span>,<span class="number">174</span>];</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">&#x27;div#d3-slider&#x27;</span>).append(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;width&#x27;</span>, <span class="number">600</span>).attr(<span class="string">&#x27;height&#x27;</span>, <span class="number">400</span>).append(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;transform&#x27;</span>, <span class="string">&#x27;translate(30,30)&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> box = svg</span><br><span class="line">    .append(<span class="string">&#x27;rect&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;width&#x27;</span>, <span class="number">160</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;height&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;transform&#x27;</span>, <span class="string">&#x27;translate(400,30)&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;fill&#x27;</span>, <span class="string">`#<span class="subst">$&#123;num2hex(rgb)&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">rgb.forEach(<span class="function">(<span class="params">color, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> slider = d3</span><br><span class="line">      .sliderBottom()</span><br><span class="line">      .min(<span class="number">0</span>)</span><br><span class="line">      .max(<span class="number">255</span>)</span><br><span class="line">      .step(<span class="number">1</span>)</span><br><span class="line">      .width(<span class="number">300</span>)</span><br><span class="line">      .default(rgb[i])</span><br><span class="line">      .displayValue(<span class="literal">false</span>)</span><br><span class="line">      .fill(colors[i])</span><br><span class="line">      .on(<span class="string">&#x27;onchange&#x27;</span>, <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        rgb[i] = num;</span><br><span class="line">        box.attr(<span class="string">&#x27;fill&#x27;</span>, <span class="string">`#<span class="subst">$&#123;num2hex(rgb)&#125;</span>`</span>);</span><br><span class="line">        d3.select(<span class="string">&#x27;p#value-color&#x27;</span>).text(<span class="string">`#<span class="subst">$&#123;num2hex(rgb)&#125;</span>`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    svg.append(<span class="string">&#x27;g&#x27;</span>).attr(<span class="string">&#x27;transform&#x27;</span>, <span class="string">`translate(30,<span class="subst">$&#123;<span class="number">60</span> * i&#125;</span>)`</span>).call(slider);</span><br><span class="line">&#125;);</span><br><span class="line">d3.select(<span class="string">&#x27;p#value-color&#x27;</span>).text(<span class="string">`#<span class="subst">$&#123;num2hex(rgb)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>



<h3 id="可视化结果输出"><a href="#可视化结果输出" class="headerlink" title="可视化结果输出"></a>可视化结果输出</h3><p>d3绘制的图像是svg或canvas对象，要将生成的可视化结果导出可以选择直接复制svg节点数据，从DOM里直接复制 SVG 代码，然后粘贴到文本文件里，命名为chart.svg，如果觉得麻烦可以用其他工具，导出的需求挺普遍，当然有大佬造了轮子，<a href="https://github.com/likr/d3-downloadable">d3-downloadable</a>是一个JavaScript库，用于下载绘制的svg图形，在html里引入后，在JavaScript代码里加入<code>svg.call(d3.downloadable(&#123;width:w,height:h,filename: &quot;filename&quot;&#125;));</code>就可以下载svg文件了。而如果只需要图片，就可以直接用截图工具截图保存，例如在写这些笔记时，自己大部分图片都是直接截图的，部分svg图形在DOM里直接复制出来粘到文本文件里。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>交互是JavaScript可视化库的基本功能，一些封装的基于前端的Python库也都实现了缩放漫游、悬停文本标签等交互功能。d3实现交互效果并不复杂，只需要对选择集使用<code>on()</code>，设定事件的监听器，在监听器里写交互的代码，定义响应的行为。基础可视化实现挺简单，而深度交互的内容很多，如更优雅的过渡和渐变效果、更深入的适应触摸设备交互、迷你图加入悬停框等等，在之后的具体实践中深入学习。</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title>D3库实践笔记之几类特定图表与布局 |可视化系列37</title>
    <url>/2020/10/03/viz-d3-07-layout.html</url>
    <content><![CDATA[<p>布局(Layout)可以看成是D3对图形元素的一种排布方式，在绘制柱状图时，是在横平竖直的直角坐标系下，确定矩形的左上角坐标，就可以画出随着高度变化的一系列柱子，以体现数据值的差异，而如果要画饼图呢，有一列数据[30,10,6]，映射到饼图的不同楔形里，是一个个手动计算角度和初始位置么？根据图形语法，只需要将坐标系变成极坐标，一系列数据很容易对应为角度。布局和比例尺一样，也属于一种映射，能够将我们提供的数据重新映射/变换成新格式，以便于在某些更特定的图表中的使用。</p>
<h3 id="饼图布局"><a href="#饼图布局" class="headerlink" title="饼图布局"></a>饼图布局</h3><a id="more"></a>

<p>在v3.x版本中，d3的布局在d3.layout接口下，通过<code>d3.layout.pie()</code>创建一个饼状图布局，而到v5x及最新的v6之后，是<code>d3.pie()</code>，不再使用d3.layout系列，在控制台输入<code>d3.layout</code> 是undefined。在使用饼图布局后，不需要把SVG整个画布的坐标系转成极坐标系，而是将系列数据做转换。</p>
<p>对于一个数组<code>dataset = [76,37,90,60,50]</code>，通过<code>arcs=d3.pie()(dataset)</code>转换成适合生成饼图的格式，在套上前几篇都用过的生成svg和添加形状的框架，一个饼图就诞生了。传入arcs绘制每个楔形用的是SVG的<code>&lt;path&gt;</code>标签。</p>
<p><img src="/2020/10/03/viz-d3-07-layout/viz-d3-notes-all/31-06-02-1004-d3-pie.png" alt="d3-pie"></p>
<p>绘制饼图的具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>]; <span class="comment">//要绘制的数据</span></span><br><span class="line"><span class="keyword">var</span> cls=[<span class="string">&quot;#F3D2AC&quot;</span>,<span class="string">&quot;#F3B8B1&quot;</span>,<span class="string">&quot;#CC99CC&quot;</span>,<span class="string">&quot;#7DC8CA&quot;</span>,<span class="string">&quot;#CAE9E0&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> outerRadius = <span class="number">500</span>/<span class="number">2</span>, innerRadius = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);</span><br><span class="line"><span class="comment">//var arcs=d3.pie()(dataset);</span></span><br><span class="line"><span class="keyword">var</span> pie = d3.pie().sort(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">var</span> arcs=pie(dataset); <span class="comment">//不使用排序</span></span><br><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">&quot;body&quot;</span>)</span><br><span class="line">   			.append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">   			.attr(<span class="string">&quot;width&quot;</span>,<span class="string">&#x27;600&#x27;</span>)</span><br><span class="line">   			.attr(<span class="string">&quot;height&quot;</span>,<span class="string">&#x27;500&#x27;</span>)</span><br><span class="line"><span class="comment">//为每个要绘制的扇形创建新的分组( g ), 并进行数据绑定</span></span><br><span class="line"><span class="keyword">var</span> a= svg.selectAll(<span class="string">&quot;g.arc&quot;</span>)</span><br><span class="line">		  .data(arcs)</span><br><span class="line">		  .enter()</span><br><span class="line">		  .append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">		  .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;arc&quot;</span>)</span><br><span class="line">		  .attr(<span class="string">&quot;transform&quot;</span>, <span class="string">&quot;translate(&quot;</span> + outerRadius + <span class="string">&quot;, &quot;</span> + outerRadius</span><br><span class="line">											+ <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    a.append(<span class="string">&quot;path&quot;</span>)  <span class="comment">//绘制每个楔形</span></span><br><span class="line">     .attr(<span class="string">&quot;fill&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d, i</span>) </span>&#123;<span class="keyword">return</span> cls[i];&#125;)</span><br><span class="line">     .attr(<span class="string">&quot;d&quot;</span>, arc);</span><br><span class="line">	a.append(<span class="string">&quot;text&quot;</span>)  <span class="comment">//添加文本标签</span></span><br><span class="line">     .attr(<span class="string">&quot;transform&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;translate(&quot;</span> + arc.centroid(d) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">			&#125;)</span><br><span class="line">	 .attr(<span class="string">&quot;text-anchor&quot;</span>, <span class="string">&quot;middle&quot;</span>)</span><br><span class="line">	 .text(<span class="function"><span class="params">d</span> =&gt;</span> d.value);</span><br></pre></td></tr></table></figure>



<p>直接使用<code>d3.pie()(dataset)</code>得到的数据序列arcs绘制的饼图是经过排序的，饼图效果是从12点钟开始第一个楔形，顺时针从大到小排列，从上图也可看出，数据的索引没变，<code>arcs[0]</code>还是76，但起始角度为0的数据是90，因此可以重写一下pie函数<code>pie = d3.pie().sort(null)</code>，会按照数据的顺序排列饼图的每个楔形。实际中使用排序还是没排序的效果根据需求选择。innerRadius设置为0是饼图，当其大于0可以得到环状图。outerRadius可以理解为整个图表的半径，因为生成的SVG是[600,500]像素，因此把outerRadius设置为高度的一半，绘制的饼图效果较好。</p>
<p>饼图还有两个实用的参数是cornerRadius和padAngle，</p>
<ul>
<li>cornerRadius：应用在<code>d3.arc()</code>上，设置每个楔形弧段边缘的圆角效果，类似于<code>&lt;rect&gt;</code>标签的rx属性，rx用来绘制圆角矩形；</li>
<li>padAngle：应用在<code>d3.pie()</code>上，设置每个楔形排列的间隔；</li>
</ul>
<p>调整这三个参数生成的<em>“饼图”</em>效果如下：</p>
<p><img src="/2020/10/03/viz-d3-07-layout/viz-d3-notes-all/31-06-03-1004-d3-pie-innerradius.png" alt="d3-pie-innerradius"></p>
<h3 id="堆叠布局"><a href="#堆叠布局" class="headerlink" title="堆叠布局"></a>堆叠布局</h3><p>用<code>d3.stack()</code>将数据变成适合堆叠图的数据格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始数据</span></span><br><span class="line"><span class="keyword">var</span> data=[&#123;<span class="string">&quot;y&quot;</span>:<span class="number">76</span>,<span class="string">&quot;z&quot;</span>:<span class="number">37</span>&#125;,&#123;<span class="string">&quot;y&quot;</span>:<span class="number">37</span>,<span class="string">&quot;z&quot;</span>:<span class="number">46</span>&#125;,</span><br><span class="line">		  &#123;<span class="string">&quot;y&quot;</span>:<span class="number">90</span>,<span class="string">&quot;z&quot;</span>:<span class="number">53</span>&#125;,&#123;<span class="string">&quot;y&quot;</span>:<span class="number">60</span>,<span class="string">&quot;z&quot;</span>:<span class="number">81</span>&#125;,&#123;<span class="string">&quot;y&quot;</span>:<span class="number">50</span>,<span class="string">&quot;z&quot;</span>:<span class="number">60</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> stack= d3.stack()</span><br><span class="line">		   .keys([<span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]);</span><br><span class="line"><span class="keyword">var</span> ds=stack(data);</span><br><span class="line"><span class="comment">//输出的ds：</span></span><br><span class="line"><span class="comment">// [[[0,76],[0,37],[0,90],[0,60],[0,50]],</span></span><br><span class="line"><span class="comment">//  [[76,113],[37,83],[90,143],[60,141],[50,110]] ]</span></span><br></pre></td></tr></table></figure>

<p>基于这一格式的数据就可以绘制堆叠柱状图以及垂直的堆叠条形图。</p>
<p><img src="/2020/10/03/viz-d3-07-layout/viz-d3-notes-all/31-06-04-1004-d3-stack-bar.png" alt="d3-stack-bar"></p>
<h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>将序列数据处理为适合直方图的形式用<code>d3.bin()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data=[<span class="number">5.1</span>, <span class="number">4.9</span>, <span class="number">8.6</span>, <span class="number">6.2</span>, <span class="number">5.1</span>, <span class="number">7.1</span>, <span class="number">6.7</span>, <span class="number">6.1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5.2</span>, <span class="number">7.9</span>, <span class="number">10.5</span>, <span class="number">5.9</span>, <span class="number">5.5</span>, <span class="number">5.6</span>, <span class="number">6.5</span>, <span class="number">7.7</span>, <span class="number">5.7</span>, <span class="number">6.5</span>, <span class="number">6.1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5.2</span>, <span class="number">7.9</span>,<span class="number">6.7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bins= d3.bin().thresholds(<span class="number">10</span>)(data);</span><br><span class="line"><span class="keyword">var</span> margin = (&#123;<span class="attr">top</span>: <span class="number">20</span>, <span class="attr">right</span>: <span class="number">20</span>, <span class="attr">bottom</span>: <span class="number">30</span>, <span class="attr">left</span>: <span class="number">40</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> x = d3.scaleLinear()</span><br><span class="line">    .domain([bins[<span class="number">0</span>].x0, bins[bins.length - <span class="number">1</span>].x1])</span><br><span class="line">    .range([<span class="number">40</span>, <span class="number">400</span>]);</span><br><span class="line"><span class="keyword">var</span> y = d3.scaleLinear()</span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(bins, <span class="function"><span class="params">d</span> =&gt;</span> d.length)]).nice()</span><br><span class="line">    .range([<span class="number">470</span>,<span class="number">20</span>]);</span><br><span class="line">xAxis = <span class="function"><span class="params">g</span> =&gt;</span> g</span><br><span class="line">    .attr(<span class="string">&quot;transform&quot;</span>, <span class="string">`translate(0,<span class="subst">$&#123;<span class="number">470</span>&#125;</span>)`</span>)</span><br><span class="line">    .call(d3.axisBottom(x).ticks(<span class="number">500</span> / <span class="number">80</span> ).tickSizeOuter(<span class="number">0</span>))</span><br><span class="line">    .call(<span class="function"><span class="params">g</span> =&gt;</span> g.append(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;x&quot;</span>, <span class="number">450</span>).attr(<span class="string">&quot;y&quot;</span>, -<span class="number">4</span>)</span><br><span class="line">        .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;currentColor&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;font-weight&quot;</span>, <span class="string">&quot;bold&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;text-anchor&quot;</span>, <span class="string">&quot;end&quot;</span>)</span><br><span class="line">        .text(data.x));</span><br><span class="line">yAxis = <span class="function"><span class="params">g</span> =&gt;</span> g</span><br><span class="line">    .attr(<span class="string">&quot;transform&quot;</span>, <span class="string">`translate(<span class="subst">$&#123;<span class="number">40</span>&#125;</span>,0)`</span>)</span><br><span class="line">    .call(d3.axisLeft(y).ticks(<span class="number">500</span>/ <span class="number">80</span>))</span><br><span class="line">    .call(<span class="function"><span class="params">g</span> =&gt;</span> g.select(<span class="string">&quot;.domain&quot;</span>).remove())</span><br><span class="line">    .call(<span class="function"><span class="params">g</span> =&gt;</span> g.select(<span class="string">&quot;.tick:last-of-type text&quot;</span>).clone()</span><br><span class="line">        .attr(<span class="string">&quot;x&quot;</span>, <span class="number">4</span>).attr(<span class="string">&quot;text-anchor&quot;</span>, <span class="string">&quot;start&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;font-weight&quot;</span>, <span class="string">&quot;bold&quot;</span>).text(data.y));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">   			.attr(<span class="string">&quot;width&quot;</span>,<span class="string">&#x27;600&#x27;</span>).attr(<span class="string">&quot;height&quot;</span>,<span class="string">&#x27;500&#x27;</span>);</span><br><span class="line">	svg.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">       .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;steelblue&quot;</span>)</span><br><span class="line">       .selectAll(<span class="string">&quot;rect&quot;</span>).data(bins).join(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">       .attr(<span class="string">&quot;x&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> x(d.x0) + <span class="number">1</span>)</span><br><span class="line">       .attr(<span class="string">&quot;width&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="built_in">Math</span>.max(<span class="number">0</span>, x(d.x1) - x(d.x0) - <span class="number">1</span>))</span><br><span class="line">       .attr(<span class="string">&quot;y&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> y(d.length)).style(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>)</span><br><span class="line">       .attr(<span class="string">&quot;height&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> y(<span class="number">0</span>) - y(d.length));</span><br><span class="line"></span><br><span class="line">  svg.append(<span class="string">&quot;g&quot;</span>).call(xAxis);</span><br><span class="line">  svg.append(<span class="string">&quot;g&quot;</span>).call(yAxis);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/03/viz-d3-07-layout/viz-d3-notes-all/31-06-05-1004-d3-hist-bins.png" alt="d3-hist"></p>
<h3 id="力导向图"><a href="#力导向图" class="headerlink" title="力导向图"></a>力导向图</h3><p>力导向(force-directed)图布局效果通过<code>d3.forceSimulation(nodes).force()</code>实现，将输入的节点表和关系表转换为带坐标点方便SVG里绘制<code>circle</code>和<code>line</code>的数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data=&#123;<span class="string">&quot;nodes&quot;</span>:[&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">1</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;b&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">1</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;c&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">2</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;d&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">1</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;e&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">2</span>&#125;],</span><br><span class="line">          <span class="string">&quot;links&quot;</span>:[&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;e&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;e&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">5</span>&#125;]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> links = data.links.map(<span class="function"><span class="params">d</span> =&gt;</span> <span class="built_in">Object</span>.create(d));</span><br><span class="line"><span class="keyword">var</span> nodes = data.nodes.map(<span class="function"><span class="params">d</span> =&gt;</span> <span class="built_in">Object</span>.create(d));</span><br><span class="line"><span class="keyword">var</span> simulation = d3.forceSimulation(nodes)</span><br><span class="line">      .force(<span class="string">&quot;link&quot;</span>, d3.forceLink(links).id(<span class="function"><span class="params">d</span> =&gt;</span> d.id))</span><br><span class="line">      .force(<span class="string">&quot;charge&quot;</span>, d3.forceManyBody())</span><br><span class="line">      .force(<span class="string">&quot;center&quot;</span>, d3.forceCenter(<span class="number">400</span> / <span class="number">2</span>,<span class="number">400</span>/ <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">            .attr(<span class="string">&quot;width&quot;</span>,<span class="string">&#x27;600&#x27;</span>).attr(<span class="string">&quot;height&quot;</span>,<span class="string">&#x27;500&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> link = svg.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;stroke&quot;</span>, <span class="string">&quot;#ba5c25&quot;</span>).attr(<span class="string">&quot;stroke-opacity&quot;</span>, <span class="number">0.6</span>)</span><br><span class="line">      .selectAll(<span class="string">&quot;line&quot;</span>).data(links).join(<span class="string">&quot;line&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;stroke-width&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="built_in">Math</span>.sqrt(d.value));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> node = svg.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;stroke&quot;</span>, <span class="string">&quot;#fff&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;stroke-width&quot;</span>, <span class="number">1.5</span>)</span><br><span class="line">    .selectAll(<span class="string">&quot;circle&quot;</span>).data(nodes)</span><br><span class="line">    .append(<span class="string">&quot;circle&quot;</span>).attr(<span class="string">&quot;r&quot;</span>, <span class="number">5</span>).attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;#CAE9E0&quot;</span>);</span><br><span class="line">  node.append(<span class="string">&quot;title&quot;</span>).text(<span class="function"><span class="params">d</span> =&gt;</span> d.id);</span><br><span class="line">  simulation.on(<span class="string">&quot;tick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    link</span><br><span class="line">        .attr(<span class="string">&quot;x1&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.source.x)</span><br><span class="line">        .attr(<span class="string">&quot;y1&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.source.y)</span><br><span class="line">        .attr(<span class="string">&quot;x2&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.target.x)</span><br><span class="line">        .attr(<span class="string">&quot;y2&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.target.y);</span><br><span class="line">    node</span><br><span class="line">        .attr(<span class="string">&quot;cx&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.x)</span><br><span class="line">        .attr(<span class="string">&quot;cy&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.y);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>



<h3 id="弦图"><a href="#弦图" class="headerlink" title="弦图"></a>弦图</h3><p>弦图(Chord Diagram)用于表示一组元素之间的联系。输入的数据仍然是节点表nodes和节点间关系表links，弦图将数据节点环状分布，内部通过弦连接，弦的宽度反应连接的强度(values)。数据需要转换为一个NxN的矩阵，矩阵中的a、b、c等在弦图的外圆上用相互分隔的几段弧来表示，对应节点。节点的长度为该元素所在行的总和。</p>
<p>在d3中通过<code>d3.chordDirected()(matrix)</code>得到需要的数据，具体代码如下，因为还需要绘制节点的排布效果，因此会调用<code>d3.arc()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data=&#123;<span class="string">&quot;nodes&quot;</span>:[&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">1</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;b&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">1</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;c&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">2</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;d&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">1</span>&#125;,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;e&quot;</span>,<span class="string">&quot;group&quot;</span>:<span class="number">2</span>&#125;],</span><br><span class="line">          <span class="string">&quot;links&quot;</span>:[&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">5</span>&#125;,&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;d&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">1</span>&#125;,&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;e&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">6</span>&#125;,&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;e&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">2</span>&#125;,&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;target&quot;</span>: <span class="string">&quot;e&quot;</span>, <span class="string">&quot;value&quot;</span>: <span class="number">5</span>&#125;]&#125;;</span><br><span class="line"><span class="keyword">var</span> links = data.links;</span><br><span class="line"><span class="keyword">var</span> nodes = data.nodes;</span><br><span class="line"><span class="keyword">var</span> names= <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(links.flatMap(<span class="function"><span class="params">d</span> =&gt;</span> [d.source, d.target])));</span><br><span class="line"><span class="keyword">var</span> index = <span class="keyword">new</span> <span class="built_in">Map</span>(names.map(<span class="function">(<span class="params">name, i</span>) =&gt;</span> [name, i]));</span><br><span class="line"><span class="keyword">var</span> matrix = <span class="built_in">Array</span>.from(index, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(names.length).fill(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> &#123;source, target, value&#125; <span class="keyword">of</span> links) matrix[index.get(source)][index.get(target)]+= value;</span><br><span class="line"><span class="keyword">var</span> innerRadius = <span class="number">200</span>,outerRadius = <span class="number">206</span>;</span><br><span class="line"><span class="keyword">var</span> width = <span class="number">440</span>,height = <span class="number">440</span>;</span><br><span class="line"><span class="keyword">var</span> ribbon = d3.ribbonArrow().radius(innerRadius - <span class="number">0.5</span>).padAngle(<span class="number">1</span> / innerRadius);</span><br><span class="line"><span class="keyword">var</span> color = d3.scaleOrdinal(names, d3.schemeCategory10)</span><br><span class="line"><span class="keyword">var</span> chord = d3.chordDirected().padAngle(<span class="number">12</span> / innerRadius)</span><br><span class="line">    .sortSubgroups(d3.descending).sortChords(d3.descending);</span><br><span class="line"><span class="keyword">var</span> chords = chord(matrix);</span><br><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;svg&quot;</span>).attr(<span class="string">&quot;viewBox&quot;</span>, [-<span class="number">600</span> / <span class="number">2</span>, -<span class="number">600</span> / <span class="number">2</span>, <span class="number">600</span>, <span class="number">600</span>]);</span><br><span class="line"><span class="keyword">var</span> formatValue = <span class="function"><span class="params">x</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;x.toFixed(<span class="number">0</span>)&#125;</span>B`</span>;</span><br><span class="line"><span class="keyword">var</span> arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);</span><br><span class="line">	svg.append(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;none&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;d&quot;</span>, d3.arc()(&#123;outerRadius, <span class="attr">startAngle</span>: <span class="number">0</span>, <span class="attr">endAngle</span>: <span class="number">2</span> * <span class="built_in">Math</span>.PI&#125;));</span><br><span class="line"></span><br><span class="line">	svg.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;fill-opacity&quot;</span>, <span class="number">0.75</span>)</span><br><span class="line">      .selectAll(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .data(chords)</span><br><span class="line">      .join(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;d&quot;</span>, ribbon)</span><br><span class="line">      .attr(<span class="string">&quot;fill&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> color(names[d.target.index]))</span><br><span class="line">      .style(<span class="string">&quot;mix-blend-mode&quot;</span>, <span class="string">&quot;multiply&quot;</span>);</span><br><span class="line">    svg.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .selectAll(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .data(chords.groups)</span><br><span class="line">      .join(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .call(<span class="function"><span class="params">g</span> =&gt;</span> g.append(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;d&quot;</span>, arc)</span><br><span class="line">        .attr(<span class="string">&quot;fill&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> color(names[d.index]))</span><br><span class="line">        .attr(<span class="string">&quot;stroke&quot;</span>, <span class="string">&quot;#fff&quot;</span>))</span><br><span class="line">      .call(<span class="function"><span class="params">g</span> =&gt;</span> g.append(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;dy&quot;</span>, -<span class="number">3</span>)</span><br><span class="line">      .append(<span class="string">&quot;textPath&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;startOffset&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.startAngle * outerRadius)</span><br><span class="line">        .text(<span class="function"><span class="params">d</span> =&gt;</span> names[d.index]));</span><br></pre></td></tr></table></figure>



<p><img src="/2020/10/03/viz-d3-07-layout/viz-d3-notes-all/31-06-07-1004-d3-chord.png" alt="d3-chord"></p>
<h3 id="分层树图"><a href="#分层树图" class="headerlink" title="分层树图"></a>分层树图</h3><p>要绘制思维导图等分层的树图，在d3中使用的是<code>d3.hierarchy(data)</code>转换为层级数据，再通过<code>d3.tree()(data)</code>建立树的节点，用svg里的<code>&lt;circle&gt;</code>绘制节点，用<code>&lt;path&gt;</code>绘制边，从而有流线的效果。一个绘制示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;a&quot;</span>,<span class="string">&quot;children&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;b&quot;</span>,<span class="string">&quot;children&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;c&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="number">710</span>&#125;]&#125;,</span><br><span class="line">                      &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;d&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="number">250</span>&#125;,</span><br><span class="line">                      &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;e&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="number">863</span>&#125;]&#125;;</span><br><span class="line"><span class="keyword">var</span> width = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">var</span> root = d3.hierarchy(data);</span><br><span class="line">    root.dx = <span class="number">30</span>;</span><br><span class="line">    root.dy = width / (root.height*<span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">    root= d3.tree().nodeSize([root.dx, root.dy])(root);</span><br><span class="line"><span class="keyword">var</span> svg = d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;viewBox&quot;</span>, [-<span class="number">20</span>, -<span class="number">100</span>,<span class="number">350</span>,<span class="number">300</span>]);;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> link = svg.append(<span class="string">&quot;g&quot;</span>).attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;none&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;stroke&quot;</span>, <span class="string">&quot;#555&quot;</span>).attr(<span class="string">&quot;stroke-opacity&quot;</span>, <span class="number">0.4</span>)</span><br><span class="line">    .attr(<span class="string">&quot;stroke-width&quot;</span>, <span class="number">1.5</span>).selectAll(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">    .data(root.links()).join(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;d&quot;</span>, d3.linkHorizontal().x(<span class="function"><span class="params">d</span> =&gt;</span> d.y).y(<span class="function"><span class="params">d</span> =&gt;</span> d.x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> node = svg.append(<span class="string">&quot;g&quot;</span>).attr(<span class="string">&quot;stroke-linejoin&quot;</span>, <span class="string">&quot;round&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;stroke-width&quot;</span>, <span class="number">3</span>).selectAll(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .data(root.descendants()).join(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">      .attr(<span class="string">&quot;transform&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="string">`translate(<span class="subst">$&#123;d.y&#125;</span>,<span class="subst">$&#123;d.x&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">    node.append(<span class="string">&quot;circle&quot;</span>).attr(<span class="string">&quot;fill&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.children ? <span class="string">&quot;#555&quot;</span> : <span class="string">&quot;#999&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;r&quot;</span>, <span class="number">2.5</span>).attr(<span class="string">&quot;fill&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    node.append(<span class="string">&quot;text&quot;</span>) <span class="comment">//文本标签</span></span><br><span class="line">        .attr(<span class="string">&quot;dy&quot;</span>, <span class="string">&quot;0.31em&quot;</span>).attr(<span class="string">&quot;x&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.children ? -<span class="number">6</span> : <span class="number">6</span>)</span><br><span class="line">        .attr(<span class="string">&quot;text-anchor&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d.children ? <span class="string">&quot;end&quot;</span> : <span class="string">&quot;start&quot;</span>)</span><br><span class="line">        .text(<span class="function"><span class="params">d</span> =&gt;</span> d.data.name).clone(<span class="literal">true</span>).attr(<span class="string">&quot;stroke&quot;</span>, <span class="string">&quot;white&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/03/viz-d3-07-layout/viz-d3-notes-all/31-06-08-1004-d3-tree.png" alt="d3-tree"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>布局实现的是数据的变换，从序列数据或二维数据变换为方便绘制一些主题图的数据，例如变成饼图的每个楔形、变成直方图的分箱统计、力导向图的坐标点和连接线等。在d3的v3.x版本里，饼图、直方图等数据转换函数汇总在layout下。通过<code>d3.layout.pie()</code>使用，而v5.x之后的版本没有了layout的集合，而是使用<code>d3.pie()(data)</code>。本篇笔记学习和实践了饼图、堆叠柱图、直方图、力导向图、弦图及层级树图的绘制。还可以深入学习的有树状图(<code>d3.treemap()</code>)、径向堆叠柱状图、汇聚气泡图(<code>d3.pack()</code>)、桑吉图(<code> d3.sankey()</code>)等等。</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title>D3的地理可视化模块</title>
    <url>/2020/12/18/viz-d3-08-geojson-to-path.html</url>
    <content><![CDATA[<p>地图<br>    GeoJSON<br>    路径<br>        var path = d3.geo.path();</p>
<a id="more"></a>


<pre><code>投影
等值区域
解析SHP</code></pre>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
        <tag>d3</tag>
        <tag>geo-viz</tag>
      </tags>
  </entry>
  <entry>
    <title>《使用D3设计交互式图表》简读笔记|可视化系列31</title>
    <url>/2020/04/27/viz-d3-zero-to-one-00-overview.html</url>
    <content><![CDATA[<p>本文是《数据可视化实战：使用D3设计交互式图表》【1】的简要版读书笔记，通过约4000字概览如何用D3做可视化、实践从数据到图形的过程。D3是一个<a href="https://d3js.org/">根据数据操纵文档的JavaScript库</a>【2】，其全称Data-Driven Documents强调了这一点。D3的功能不止于做可视化，Documents代表可以在浏览器中展现的一切，包括HTML、SVG，根据数据操纵DOM(Document Object Model)可实现非常多的效果，但通常大家通常用D3来将数据映射为可视图形。</p>
<a id="more"></a>

<p>作为<em>O‘REILLY动物书</em>系列之一，《数据可视化实战》这本书语言简练逻辑性强、例子通俗易懂，200多页较全面地教了D3可视化的各种用法，由浅入深讲了使用D3的基本技术、数据绑定、比例尺、数轴及过渡等关键内容，本书很好地从数据角度切入绘图的框架和细节，不过值得说的是书标题写了交互(Interactive)但正文关于交互的篇幅并不长，只占一章。</p>
<p>31-01 本书思维导图简要版（后面会慢慢拆解）</p>
<h2 id="D3技术基础"><a href="#D3技术基础" class="headerlink" title="D3技术基础"></a>D3技术基础</h2><p>D3操作的是Web上的文档，可以便捷快速地向全世界发布可视化作品，对操作系统和设备的依赖很低。</p>
<p>D3库的功能和特点：</p>
<ul>
<li>将数据和DOM绑定在一起、图形随着数据变化；</li>
<li>数据转换和绘制独立；不是提供Pie()这类函数绘图而是将数据转换成饼图数据，再按需绘图。像面粉可以做出各种糕点而不是直接提供面条；</li>
<li>擅长矢量图形，缩放不损失图形精度，不擅长位图和瓦片，不擅长探索型可视化；</li>
<li>作为HTML文档，不隐藏原始数据，<em>如果不想共享数据，为什么还要将它们可视化呢？</em></li>
</ul>
<p>D3本质上还是JavaScript，这意味着我们可以用原生JavaScript代码实现讲到的所有功能，但D3对作了很好的封装，大大减轻了做可视化的工作量并应对各种需求。用D3做可视化的代码框架如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>d3可视化代码框架<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./d3/d3.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--直接引入在线的d3库： &lt;script src=&quot;https://d3js.org/d3.v5.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="comment">// D3 代码部分</span></span></span><br><span class="line"><span class="javascript">     d3.select(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;p&quot;</span>).text(<span class="string">&quot;hello world！&quot;</span>);</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>来细看这段代码，除<code>d3.select(&quot;body&quot;)...</code>句外，都是通用的HTML代码，<html><head></head><body></body></html>划分了层次结构，发挥功能的d3代码在<script></script>块里。这段d3脚本代码的作用是在html的body元素里加入一个文本段落(<code>&lt;p&gt;&lt;/p&gt;</code>)，并把文本内容<code>hello world！</code>添加给这个段落。可以总结下D3可视化的基本步骤如下：</p>
<ul>
<li>创建新元素并绑定数据（html的元素可理解为划定区域和声明类型的闭合标签，如p表示其是一个段落，是段落就可以有段落文本、长宽、id等属性和标识）</li>
<li>设置相应元素的可视属性，将数据值映射为元素大小、颜色、位置等可视属性；</li>
<li>对元素进行排列和变换，还有响应交互；</li>
</ul>
<p>D3那句链式调用了.select()、append()等，也可以用中间变量承接，写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拆成多个语句的写法：</span></span><br><span class="line"><span class="keyword">var</span> body = d3.select(<span class="string">&quot;body&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> p = body.append(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">p.text(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>【31-02-从原html到效果html】</p>
<h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>基于HTML文档的可视化基本都使用canvas或svg元素作为数据到图形的映射容器。D3也可以直接操作div或其他原生HTML元素来绘图，但总是略显笨重，且容易出现浏览器间不一致的问题。而用 SVG就更可靠，图形效果更一致，且绘图速度更快。SVG（Scalable Vector Graphics，可伸缩矢量图形）是一种基于XML标签来表示图形的文本。SVG 元素可以理解为能在上面绘制各种形状的画布。一个基础的svg示例如下，表示一个半径为20像素的圆形。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;200&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;30&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在SVG的预定义元素里，有6种基本元素rect(矩形)、circle(圆形)、ellipse(椭圆)、line(线段)、polyline(折线)、polygon(多边形)和功能强大的path(路径)，在SVG里也可以添加text(文本)元素。</p>
<p>和一些编程语言的坐标系统一样，基于像素的坐标系统的原点位于画布的左上角。增大 x 的值，图形会向右移动；增大 y 值，图形会向下移动。</p>
<p>【图31-03，d3代码-&gt;svg-&gt;结果图像】</p>
<h3 id="元素添加与数据绑定"><a href="#元素添加与数据绑定" class="headerlink" title="元素添加与数据绑定"></a>元素添加与数据绑定</h3><p>从前面的代码框架及D3可视化基本步骤可以看出，用D3将数据变成图形首先需要选定元素并添加SVG元素（如果html代码已经有了需要的<svg>元素则只需选定该SVG元素。d3的select()方法传入一个 CSS 选择符，返回DOM 中匹配的<strong>第一个</strong>元素的引用。典型用法如下：</svg></p>
<ul>
<li>d3.select(“body”) ;  //选择body元素；</li>
<li>d3.select(“#apple”); //选择id为apple的元素；例如会匹配上<p id="apple">p01</p></li>
<li>d3.select(“.apple”); //选择class为apple的元素；会匹配上<p class="apple">p02</p></li>
</ul>
<p>如果想获得所有满足条件的元素，用selectAll()方法，典型写法同上。</p>
<p>我们在选择了需要操作的svg元素后，需要添加rect(矩形)等图形，用append()方法添加元素，insert()方法在所选元素前添加一个元素。用remove()方法在DOM中删除元素。通过attr()给所选元素添加属性。</p>
<p>通过datum(val)将数据val绑定到选中的所有元素。通过data(vals[,key])绑定数组vals中的每一项到选中的元素，key是一个用于指定绑定规则的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataset = [ <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span> ];</span><br><span class="line">d3.select(<span class="string">&quot;body&quot;</span>).selectAll(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line"> 	.data(dataset)</span><br><span class="line"> 	.enter()</span><br><span class="line"> 	.append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;class&quot;</span>,<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"> 	.style(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;#1EAFAE&quot;</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;width&quot;</span>,<span class="number">50</span>)</span><br><span class="line"> 	.attr(<span class="string">&quot;height&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;<span class="keyword">return</span> d*<span class="number">10</span> +<span class="string">&quot;px&quot;</span>;&#125;);</span><br></pre></td></tr></table></figure>

<p>【31-04 图】</p>
<p>通过<code>d3.csv(&quot;food.csv&quot;, function(data) &#123;dataset=data;&#125;)</code>可以读取本地的csv文件数据进行使用，这是写JavaScript代码很常用的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d3.csv(&quot;bar-data.csv&quot;, function(data) &#123;</span><br><span class="line">      d3.select(&quot;body&quot;).selectAll(&quot;svg&quot;)</span><br><span class="line"> 		.data(data)</span><br><span class="line"> 		.enter()</span><br><span class="line"> 		.append(&quot;svg&quot;)</span><br><span class="line"> 		.style(&quot;background-color&quot;,&quot;#1EAFAE&quot;)</span><br><span class="line"> 		.attr(&quot;width&quot;,50)</span><br><span class="line"> 		.attr(&quot;height&quot;,function(d)&#123;return d*10 +&quot;px&quot;;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>读取json文件的接口也类似，通过<code>d3.json(&quot;food.json&quot;, function(data) &#123;&#125;)</code>来进行json文件的处理。</p>
<p>前面通过append()、attr()、style()等接口只是将数据映射为图形，离可视化图像还有些差距。比如我们需要有标识数据大小的数轴、标题、坐标轴标签等。标题通过text来绘制，图形颜色等通过style设置，数轴（坐标轴）可以拆解为线段+文本的组合，可以通过svg的line和text来画，需要注意的是坐标原点的位置以及y轴方向的问题。实际上d3提供了绘制坐标轴的接口，省去了很多工作量。在D3的v5版本中，通过<code>d3.axisBottom(scale)</code>绘制x轴(水平方向)、<code>d3.axisLeft(scale)</code>绘制y坐标轴。书中的v3版本使用的是 <code>xAxis = d3.svg.axis().scale(xScale).orient(&quot;bottom&quot;)</code>;</p>
<p>基于以上方法绘制一个柱状图如下：</p>
<p>【31-05 条形图结果】</p>
<h2 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h2><p>对数据进行可视化时，我们可以直接把数据值映射为像素值，但是如果数值过小或过大直接用像素得到的图形就很难看。例如不能值是10000就绘制1万像素长的矩形。我们用比例尺(scale)来解决这个问题。从数据到屏幕图形的像素有一个数据变换的过程，在输入值范围（值域）不确定的情况，我们限定输出的范围，这就是比例尺的作用。</p>
<p>D3 提供了比例尺函数生成器。<code>var scale = d3.scale.linear().domain([100, 500]).range([0, 100]);</code>比例尺scale将输入数据从[100,500]输出的时候限制在[0,100]之间。D3不仅提供了线性比例尺可用，还有序数比例尺(实现{1:’r’,2:’b’,3:’g’})、对数比例尺、平方根比例尺等。上面绘制数轴的时候也直接用到了线性比例尺。</p>
<p>关于D3，可以继续深入学习内容参考如下：</p>
<ul>
<li><strong>交互</strong>：通过绑定事件监听器和定义行为实现图形和键鼠的交互；</li>
<li><strong>过渡动画</strong>：同样通过事件监听和缓动实现过渡效果和数据更新；</li>
<li><strong>各种布局</strong>：通过饼图布局实现柱状图变旭日图、力导向布局绘制人物关系图谱；</li>
</ul>
<p>【 31-6 交互动图的gif】</p>
<p>【31-07 静态的绘制的桑吉图、地图等截图】</p>
<p>D3官网<a href="https://d3js.org/%E4%B8%8A%E6%9C%89%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%9C%80%E6%96%B0%E7%9A%84API%EF%BC%8C%E6%9C%AC%E4%B9%A6%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E5%9F%BA%E4%BA%8Ed3.v3.js%E7%9A%84API%EF%BC%8C%E7%9B%AE%E5%89%8D2020%E5%B9%B4d3%E7%9A%84%E7%89%88%E6%9C%AC%E5%B7%B2%E7%BB%8F%E6%9B%B4%E6%96%B0%E5%88%B0v5%E4%BA%86%EF%BC%8C%E6%9C%89%E9%83%A8%E5%88%86API%E6%9C%89%E5%8F%98%E5%8A%A8%EF%BC%8C%E4%B9%A6%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E5%9B%A0%E6%AD%A4%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E5%85%88%E5%9C%A8%E5%AE%98%E7%BD%91%E6%90%9C%E7%B4%A2%E6%98%AF%E5%BE%88%E5%A5%BD%E7%9A%84%E4%B9%A0%E6%83%AF%E3%80%82">https://d3js.org/上有丰富的图形实例和最新的API，本书中的代码是基于d3.v3.js的API，目前2020年d3的版本已经更新到v5了，有部分API有变动，书中的部分代码直接运行会报错，因此遇到问题先在官网搜索是很好的习惯。</a></p>
<p>后续会基于这本书用6篇文章详细介绍和实践D3可视化，希望能写得容易实践且有深度。希望与你一同进步。</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title>大家很喜欢用的可视化神器——Pyecharts|可视化系列08</title>
    <url>/2020/09/26/viz-pyecharts-a-popular-pick-pylib.html</url>
    <content><![CDATA[<h3 id="pyecharts简介"><a href="#pyecharts简介" class="headerlink" title="pyecharts简介"></a>pyecharts简介</h3><p>pyecharts是基于前端可视化框架echarts的Python可视化库。该库让我们在Python里也可以充分体验到快速出图和丰富交互的数据可视化体验。<br>echarts主要开发者御术曾说过，和d3相比，d3是面粉而echarts相当于面条。</p>
<a id="more"></a>

<p>这是个很形象的比喻，和面粉相比，面条可以快速煮出各种美食，很贴合echarts的特点。echarts开箱即用，文档详细、可以配置的参数多，且有很多改改配置就能用的例子。pyecharts也具备这一优点。</p>
<h4 id="代码框架与配置项"><a href="#代码框架与配置项" class="headerlink" title="代码框架与配置项"></a>代码框架与配置项</h4><p>pyecharts的可视化基本代码框架如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyecharts</span><br><span class="line">bar=pyecharts.charts.Bar() <span class="comment">#初始化一个柱状图</span></span><br><span class="line">bar.add_xaxis([<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>]) <span class="comment">#设置x轴</span></span><br><span class="line">bar.add_yaxis(<span class="string">&quot;y&quot;</span>, [<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>],color=<span class="string">&#x27;#1eafae&#x27;</span>) <span class="comment">#y轴</span></span><br><span class="line">bar.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;主标题&quot;</span>,pos_left=<span class="string">&#x27;center&#x27;</span>))</span><br><span class="line">bar.render_notebook()  <span class="comment">#在jupyter notebook中出图</span></span><br><span class="line"><span class="comment">#bar.render(&#x27;bar_charts_01.html&#x27;)  #保存为文件</span></span><br></pre></td></tr></table></figure>

<p>可以看到的是，pyecharts遵循了大部分Python可视化库的写法，初始化图对象，明确是什么类型的图，设置x，y轴数据及属性，设置图元属性，出图。</p>
<p>pyecharts本质做的是把Python语句向echarts的JavaScript语句的映射，因此更强调配置，语句上使用<code>add_</code>、<code>set_</code>频率高。pyecharts囊括了30+常用的图表类型，而且对于表格展示、图像显示也有对应接口，除了输出html外，支持主流notebook环境的图表显示，还能很方便地和Flask、Django等Python前端框架集成。</p>
<p>在语句组织上，也可以用链式调用写法，思路和上面一致，初始化，设置X/Y，设置图元属性，出图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar = (</span><br><span class="line">    Bar().add_xaxis(x).add_yaxis(<span class="string">&quot;y&quot;</span>,y)</span><br><span class="line">)</span><br><span class="line">bar.render()</span><br></pre></td></tr></table></figure>

<p>在图元属性上，图形颜色、文本标签通过向<code>add_yaxis</code>传参设置。也能通过<code>set_colors</code>设置全局配色。</p>
<p>标题、图例等设置通过 <code>set_global_opts </code>设置，从语句名字可以看出其可以设置各种全局的属性。实例语句如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line">bar.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;主标题&quot;</span>,</span><br><span class="line">                                              subtitle=<span class="string">&quot;副标题&quot;</span>,pos_left=<span class="string">&#x27;center&#x27;</span>),</span><br><span class="line">                   legend_opts=opts.LegendOpts(pos_left=<span class="string">&#x27;5px&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-02-pyecharts.png" alt="pyecharts set_global_opts"></p>
<p><code>set_global_opts </code>设置的图元包括：</p>
<ul>
<li><p>title_opts：标题设置，封装为*pyecharts.options.TitleOpts()*，属性有title，title_link，subtitle(副标题),pos_left,pos_top,title_textstyle_opts等实用配置。所以写法为：</p>
<p><code>title_opts=opts.TitleOpts(title=&quot;主标题&quot;)</code>；</p>
</li>
<li><p>legend_opts：图例配置项，可以控制是否显示图例、图例相对位置、图例每项之间的间隔等属性，对应封装为<code>LegendOpts()</code>；</p>
</li>
<li><p>tooltip_opts：提示框配置项，包括是否显示，触发条件等；</p>
</li>
<li><p>toolbox_opts：工具箱配置项；</p>
</li>
<li><p>brush_opts：区域选择组件配置项；</p>
</li>
<li><p>xaxis_opts：x坐标轴配置项，对应的封装是在<code>AxisOpts()</code>里，可以设置坐标轴类型(数值类型、离散类型，对数坐标轴、时间轴)、坐标轴名称、是否显示、值域、各种相对位置等属性；</p>
</li>
<li><p>yaxis_opts：y坐标轴配置项，对应封装也在<code>AxisOpts()</code>；</p>
</li>
<li><p>visualmap_opts：视觉映射配置项；</p>
</li>
<li><p>datazoom_opts：区域缩放配置项；</p>
</li>
</ul>
<p>等等，以上具体属性使用时可以随时查阅<a href="https://pyecharts.org/#/zh-cn/global_options">官方文档</a>。图形画布的宽度、背景色、使用主题等会在初始化图表时配置，称作<code>InitOpts</code>，也就是写在<code>Bar()</code>里，而不是传进<code>set_global_opts</code>。配置属性的时候需要注意的是type、min、max是Python的关键字，因此都用的type_、min_、max_这种形式。转为JavaScript会转回type，min，max。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar=pyecharts.charts.Bar(init_opts=opts.InitOpts(width=<span class="string">&quot;400px&quot;</span>,height=<span class="string">&quot;400px&quot;</span>,page_title=<span class="string">&quot;pyecharts-demo&quot;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="翻转XY轴"><a href="#翻转XY轴" class="headerlink" title="翻转XY轴"></a>翻转XY轴</h4><p>通过翻转柱状图的xy轴绘制条形图。也就是不需要改柱状图本身属性的代码，只需要加上<code>bar.reversal_axis() </code>就可以把柱状图变成条形图（在文本标签的调节上，为了适应条形图的布局，也需要设置一下<em>label_opts</em>）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar.reversal_axis()  <span class="comment">#翻转柱状图的xy轴</span></span><br><span class="line">bar.render_notebook() </span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-03.png" alt="柱状图转条形图 pyecharts"></p>
<p>对数据进行统计后调整category_gap参数可以绘制出直方图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar=pyecharts.charts.Bar()</span><br><span class="line">bar.add_xaxis(<span class="built_in">list</span>(df[<span class="string">&#x27;x&#x27;</span>]))</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;y&quot;</span>,<span class="built_in">list</span>(df[<span class="string">&#x27;y&#x27;</span>]),color=<span class="string">&#x27;#1eafae&#x27;</span>,category_gap=<span class="number">0</span>)</span><br><span class="line">bar.render_notebook()  <span class="comment">#直方图</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-07.png" alt="直方图"></p>
<p>绘制堆叠柱状图，只需要给bar对象添加两个<code>.add_yaxis()</code>再设置stack属性，实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#堆叠柱</span></span><br><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>:[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;y&#x27;</span>:[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>],</span><br><span class="line">                 <span class="string">&#x27;z&#x27;</span>:[<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>]&#125;)</span><br><span class="line">bar=pyecharts.charts.Bar()</span><br><span class="line">bar.add_xaxis(<span class="built_in">list</span>(df[<span class="string">&#x27;x&#x27;</span>]))</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;y&quot;</span>,<span class="built_in">list</span>(df[<span class="string">&#x27;y&#x27;</span>]),color=<span class="string">&#x27;#ba5c25&#x27;</span>,stack=<span class="string">&#x27;s1&#x27;</span>,label_opts=opts.LabelOpts(position=<span class="string">&#x27;inside&#x27;</span>))</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;z&quot;</span>,<span class="built_in">list</span>(df[<span class="string">&#x27;z&#x27;</span>]),color=<span class="string">&#x27;#1eafae&#x27;</span>,stack=<span class="string">&#x27;s1&#x27;</span>,label_opts=opts.LabelOpts(position=<span class="string">&#x27;inside&#x27;</span>))</span><br><span class="line">bar.render_notebook() </span><br></pre></td></tr></table></figure>

<p>绘制折线图的多条折线也是用<code>add_yaxis()</code>。</p>
<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-05.png" alt="堆叠柱状图-两个add_yaxis"></p>
<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-04.png" alt="簇状柱图"></p>
<p>通过<code>Boxplot()</code>绘制箱线图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ybox=[<span class="number">59</span>, <span class="number">81</span>, <span class="number">80</span>, <span class="number">82</span>, <span class="number">50</span>, <span class="number">67</span>, <span class="number">66</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">91</span>, <span class="number">72</span>]</span><br><span class="line">zbox=[<span class="number">59</span>, <span class="number">41</span>, <span class="number">80</span>, <span class="number">62</span>, <span class="number">70</span>, <span class="number">61</span>, <span class="number">46</span>, <span class="number">54</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">85</span>, <span class="number">42</span>]</span><br><span class="line">b=pyecharts.charts.Boxplot() <span class="comment">#箱线图</span></span><br><span class="line">b.add_xaxis([<span class="string">&#x27;boxplot-x-axis&#x27;</span>])</span><br><span class="line">b.add_yaxis(<span class="string">&quot;y&quot;</span>,[<span class="built_in">sorted</span>(ybox)])  </span><br><span class="line">b.add_yaxis(<span class="string">&quot;z&quot;</span>,[<span class="built_in">sorted</span>(zbox)])</span><br><span class="line"></span><br><span class="line">b.render_notebook() </span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-07-boxplot.png" alt="0-906-12-07-boxplot"></p>
<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>直角坐标系基本都是.add_xaxis(x).add_yaxis(“y”,y)配置X/Y轴的数据（包括箱线图），而饼图、雷达图等，是用<code>add()</code>配置数据。饼图的每块楔形对应的数为*(标签,数值)<em>，因此传入add的数据不是</em>[[x1,x2, …], [y1,y2, …]]<em>这一的x的列表和y的列表，而是需要</em>[(key1,val1),(k2,v2)]*这样的组织形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=pyecharts.charts.Pie()  <span class="comment">#pyecharts绘制饼图</span></span><br><span class="line">c.add(<span class="string">&quot;y&quot;</span>,[[v[<span class="string">&#x27;x&#x27;</span>],v[<span class="string">&#x27;y&#x27;</span>]] <span class="keyword">for</span> i,v <span class="keyword">in</span> df.iterrows()])<span class="comment">#不是add_yaxis了;[(key1,val1),(k2,v2)]</span></span><br><span class="line">c.set_colors([<span class="string">&#x27;#1eafae&#x27;</span>,<span class="string">&#x27;#69ffff&#x27;</span>, <span class="string">&#x27;#ba5c25&#x27;</span>, <span class="string">&#x27;#ffa069&#x27;</span>, <span class="string">&#x27;#a3ffff&#x27;</span>,<span class="string">&#x27;#d7ce88&#x27;</span>])</span><br><span class="line">c.render_notebook()  </span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-08-1-pie.png" alt="pyecharts绘制饼图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c=pyecharts.charts.Radar()  <span class="comment">#雷达图</span></span><br><span class="line">sch=[opts.RadarIndicatorItem(name=i,max_=<span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(df[<span class="string">&#x27;x&#x27;</span>])]</span><br><span class="line">c.add_schema(sch,shape=<span class="string">&#x27;polygon&#x27;</span>) <span class="comment">#shape可选 &#x27;polygon&#x27; 和 &#x27;circle&#x27;,默认polygon</span></span><br><span class="line">c.add(<span class="string">&quot;y&quot;</span>,[<span class="built_in">list</span>(df[<span class="string">&#x27;y&#x27;</span>])],linestyle_opts=opts.LineStyleOpts(color=<span class="string">&quot;#1eafae&quot;</span>))  </span><br><span class="line">c.add(<span class="string">&quot;z&quot;</span>,[<span class="built_in">list</span>(df[<span class="string">&#x27;z&#x27;</span>])],linestyle_opts=opts.LineStyleOpts(color=<span class="string">&quot;#ba5c25&quot;</span>)) </span><br><span class="line">c.render_notebook()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-08-2-radar.png" alt="雷达图"></p>
<p>雷达图的每条折线通过add()添加序列数据，基本上我们绘制雷达图各类别是分类变量(例如上图中的Mon.、Tue.等类别)，配置进去需要用参数详解<code>RadarIndicatorItem(name)</code>，雷达图绘制时最好显性声明没类的最大值，否则默认用的序列最大值。</p>
<h3 id="关系图及数据特点"><a href="#关系图及数据特点" class="headerlink" title="关系图及数据特点"></a>关系图及数据特点</h3><p>要绘制节点关系图等关系图，需要准备两份数据，一个节点表，一个边表。</p>
<h4 id="节点表与边表"><a href="#节点表与边表" class="headerlink" title="节点表与边表"></a>节点表与边表</h4><p>直接用代码和图来说明更形象，更容易理解。节点表nodes说明有哪些节点，点的半径大小，每个节点是一个字典类型的数据，边表links说明谁连接谁，从节点A指向点B。必须要声明的是source和target，还可以有value、lineStyle等属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nodes = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;symbolSize&quot;</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;B&quot;</span>, <span class="string">&quot;symbolSize&quot;</span>: <span class="number">40</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;C&quot;</span>, <span class="string">&quot;symbolSize&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;D&quot;</span>, <span class="string">&quot;symbolSize&quot;</span>: <span class="number">10</span>&#125;</span><br><span class="line">]</span><br><span class="line">links=[</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;target&quot;</span>:<span class="string">&#x27;B&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>:<span class="string">&#x27;B&#x27;</span>, <span class="string">&quot;target&quot;</span>:<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;value&#x27;</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>:<span class="string">&#x27;C&#x27;</span>, <span class="string">&quot;target&quot;</span>:<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;lineStyle&#x27;</span>:&#123;<span class="string">&#x27;normal&#x27;</span>:&#123;<span class="string">&#x27;show&#x27;</span>:<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;width&#x27;</span>: <span class="number">2</span>&#125;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>:<span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;target&quot;</span>:<span class="string">&#x27;B&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line">g=pyecharts.charts.Graph()</span><br><span class="line">g.add(<span class="string">&#x27;&#x27;</span>,nodes,links,edge_length=<span class="number">100</span>,repulsion=<span class="number">1500</span>)  <span class="comment">#repulsion:节点之间的斥力因子;  gravity:节点受到的引力因子;</span></span><br><span class="line">g.render_notebook()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-08-3-graph.png" alt="用Graph可视化节点间关系"></p>
<h4 id="桑吉图"><a href="#桑吉图" class="headerlink" title="桑吉图"></a>桑吉图</h4><p>Sankey图也是节点和边两个数据输入，数据的写法和节点关系图输入一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nodes = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;symbolSize&quot;</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;B&quot;</span>, <span class="string">&quot;symbolSize&quot;</span>: <span class="number">40</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;C&quot;</span>, <span class="string">&quot;symbolSize&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;D&quot;</span>, <span class="string">&quot;symbolSize&quot;</span>: <span class="number">10</span>&#125;</span><br><span class="line">]</span><br><span class="line">links=[</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>:<span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;target&quot;</span>:<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;value&#x27;</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>:<span class="string">&#x27;B&#x27;</span>, <span class="string">&quot;target&quot;</span>:<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;value&#x27;</span>: <span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>:<span class="string">&#x27;C&#x27;</span>, <span class="string">&quot;target&quot;</span>:<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;value&#x27;</span>: <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>:<span class="string">&#x27;B&#x27;</span>, <span class="string">&quot;target&quot;</span>:<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;value&#x27;</span>: <span class="number">10</span>&#125;,</span><br><span class="line">]</span><br><span class="line">g=pyecharts.charts.Sankey()</span><br><span class="line">g.add(<span class="string">&#x27;&#x27;</span>,nodes,links,</span><br><span class="line">      label_opts=opts.LabelOpts(position=<span class="string">&quot;inside&quot;</span>),</span><br><span class="line">      linestyle_opt=opts.LineStyleOpts(opacity=<span class="number">0.3</span>, curve=<span class="number">0.2</span>))</span><br><span class="line">g.render_notebook()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-08-4-sankey.png" alt="sankey"></p>
<h3 id="复合图表"><a href="#复合图表" class="headerlink" title="复合图表"></a>复合图表</h3><p>层叠不同类型的图、一行多图等排版对于pyecharts是基本操作。</p>
<p>通过<code>b.overlap(a)</code>将图a叠加到b类型的图上，且他们会共用一套坐标系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在同一坐标系里叠加多种图</span></span><br><span class="line">bar=pyecharts.charts.Bar()</span><br><span class="line">bar.add_xaxis(<span class="built_in">list</span>(df[<span class="string">&#x27;x&#x27;</span>]))</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;y&quot;</span>,<span class="built_in">list</span>(df[<span class="string">&#x27;y&#x27;</span>]),color=<span class="string">&#x27;#1eafae&#x27;</span>)</span><br><span class="line">line = pyecharts.charts.Line().add_xaxis(<span class="built_in">list</span>(df[<span class="string">&#x27;x&#x27;</span>])) \</span><br><span class="line">                .add_yaxis(<span class="string">&quot;z&quot;</span>,<span class="built_in">list</span>(df[<span class="string">&#x27;z&#x27;</span>]),color=<span class="string">&#x27;#ba5c25&#x27;</span>,z_level=<span class="number">2</span>)</span><br><span class="line">bar.overlap(line)</span><br><span class="line">bar.render_notebook() </span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-06.png" alt="在柱图上叠加折线图"></p>
<p>多个图进行排列而不是叠加到同一个坐标系里用grid和page，同一行多个图是<strong>grid</strong>，一页多图从上往下用的是<strong>page</strong>。通过选项卡点击切换多个图用<strong>tab</strong>，时间线轮播图用*<strong>timeline</strong>。综合以上的用法可以搭建仪表盘。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar=pyecharts.charts.Bar()</span><br><span class="line">bar.add_xaxis(<span class="built_in">list</span>(<span class="string">&#x27;abcdef&#x27;</span>))</span><br><span class="line">bar.add_yaxis(<span class="string">&#x27;y&#x27;</span>,a,color=<span class="string">&#x27;#1eafae&#x27;</span>)</span><br><span class="line">bar.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;帕累托图1&quot;</span>, subtitle=<span class="string">&quot;双轴直角坐标图&quot;</span>,pos_left=<span class="string">&#x27;center&#x27;</span>),</span><br><span class="line">                    legend_opts=opts.LegendOpts(pos_left=<span class="string">&#x27;60px&#x27;</span>))</span><br><span class="line"></span><br><span class="line">line=pyecharts.charts.Line()</span><br><span class="line">line.add_xaxis(<span class="built_in">list</span>(<span class="string">&#x27;abcdef&#x27;</span>))</span><br><span class="line">line.add_yaxis(<span class="string">&#x27;d&#x27;</span>,b,z_level=<span class="number">2</span>)</span><br><span class="line">line.extend_axis(</span><br><span class="line">        yaxis=opts.AxisOpts(</span><br><span class="line">            name=<span class="string">&quot;累积比例&quot;</span>,</span><br><span class="line">            type_=<span class="string">&quot;value&quot;</span>,</span><br><span class="line">            min_=<span class="number">0</span>,</span><br><span class="line">            max_=<span class="number">1</span>,</span><br><span class="line">            position=<span class="string">&quot;right&quot;</span>,</span><br><span class="line">            axisline_opts=opts.AxisLineOpts(</span><br><span class="line">                linestyle_opts=opts.LineStyleOpts(color=<span class="string">&quot;#ba5c25&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">line.set_global_opts(yaxis_opts=opts.AxisOpts(position=<span class="string">&quot;right&quot;</span>),legend_opts=opts.LegendOpts(pos_left=<span class="string">&#x27;120px&#x27;</span>))</span><br><span class="line">grid=pyecharts.charts.Grid()</span><br><span class="line">grid.add(bar,grid_opts=opts.GridOpts(pos_right=<span class="string">&quot;18%&quot;</span>))</span><br><span class="line">grid.add(line,grid_opts=opts.GridOpts(pos_right=<span class="string">&quot;18%&quot;</span>))</span><br><span class="line">grid.render_notebook()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-09-1-paleiduo.png" alt="pyecharts绘制帕累托图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tab = pyecharts.charts.Tab()</span><br><span class="line">bar1=pyecharts.charts.Bar()</span><br><span class="line">bar1.add_xaxis(<span class="built_in">list</span>(df[<span class="string">&#x27;x&#x27;</span>]))</span><br><span class="line">bar1.add_yaxis(<span class="string">&#x27;y&#x27;</span>,<span class="built_in">list</span>(df[<span class="string">&#x27;y&#x27;</span>]),color=<span class="string">&#x27;#1eafae&#x27;</span>)</span><br><span class="line">bar2=pyecharts.charts.Bar()</span><br><span class="line">bar2.add_xaxis(<span class="built_in">list</span>(df[<span class="string">&#x27;x&#x27;</span>]))</span><br><span class="line">bar2.add_yaxis(<span class="string">&#x27;z&#x27;</span>,<span class="built_in">list</span>(df[<span class="string">&#x27;z&#x27;</span>]),color=<span class="string">&#x27;#ba5c25&#x27;</span>)        </span><br><span class="line">tab.add(bar1, <span class="string">&quot;bar-example1&quot;</span>)</span><br><span class="line">tab.add(bar2, <span class="string">&quot;bar2&quot;</span>)</span><br><span class="line">tab.render_notebook()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-09-2.png" alt="0-906-12-09-2"></p>
<p><img src="/2020/09/26/viz-pyecharts-a-popular-pick-pylib/0-906-12-09-4.png" alt="用Tab进行页面切换"></p>
<p>在展示及结果导出方面，把图渲染在jupyter notebook中使用<code>c.render_notebook()</code>，这个文中用到了很多次，也不难理解，在jupyterLab中出图需要额外配置些东西，涉及语句：<code>from pyecharts.globals import CurrentConfig, NotebookType; CurrentConfig.NOTEBOOK_TYPE = NotebookType.JUPYTER_LAB</code>。</p>
<p>可视化图还可以输出为html文件，用到的语句是<code>c.render(&#39;pye_charts_01.html&#39;) </code>，要生成png图片，pyecharts 提供了 selenium, phantomjs 和 pyppeteer 三种方式去实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无论是从图表丰富性还是学习曲线角度看，pyecharts都是排名前列的可视化库。pyecharts上手很简单，文档很详细，有各种个性化需求时，通过查阅pyecharts的文档和echarts的文档基本都能得到解决，因此大家喜欢用也就不足为奇。pyecharts做的是从Python对象向JavaScript的转换，echarts支持的图表太丰富了，不一定需要一个个图表类型去看参数，有具体需求时边查文档边实现是更好的选择。</p>
<p>有问题欢迎留言交流，本文的代码和xmind思维导图文件在公众号后台回复 <strong>pye</strong> 获取。</p>
<p>参考资料</p>
<ul>
<li><a href="https://pyecharts.org/">https://pyecharts.org</a></li>
</ul>
<hr>
<p>做个仪表盘</p>
<p>要有动图；</p>
<p>xmind效果图；</p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>viz</tag>
      </tags>
  </entry>
  <entry>
    <title>一个小巧而有特色的Python矢量可视化库：pygal</title>
    <url>/2020/04/28/viz-pygal.html</url>
    <content><![CDATA[<p><a href="http://www.pygal.org/">pygal</a> 是一个基于SVG的动态可视化Python库，该库枚举了各种常用不常用的图表类型，满足基本的可视化需求，可以画简单的地图。其特点是接口易用，有很多简化的写法，方便得绘制出统计图表，可以生成迷你图，有基本交互，不需要额外的语句，鼠标移动到图表上有文本标签强化效果。但图表不能直接渲染到notebook里，不能合并多个图，例如柱+折线形成复合图，因此使用范围还是比较有限。</p>
<h3 id="绘图框架"><a href="#绘图框架" class="headerlink" title="绘图框架"></a>绘图框架</h3><p>一个很sexy的写法：</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line">pygal.Bar()(<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>)(<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>).render_in_browser()</span><br></pre></td></tr></table></figure>

<p>链式写法，各种配置浓缩到一个语句里。</p>
<p><img src="/2020/04/28/viz-pygal/0-907-13-01-1-pygal-bar.png" alt="pygal基础绘制示例"></p>
<p>为了更容易理解，一个个对象的赋值写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line">bar= pygal.Bar() <span class="comment">#初始化一个柱状图</span></span><br><span class="line">bar.add(<span class="string">&#x27;A&#x27;</span>, [<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>]) <span class="comment">#给柱图添加数据 </span></span><br><span class="line">bar.render_to_file(<span class="string">&#x27;bar_chart.svg&#x27;</span>)  <span class="comment">#渲染出图</span></span><br></pre></td></tr></table></figure>

<p>也是新建对象后用add()添加数据的做法，和pyecharts等前端封装库的接口很相似。</p>
<h3 id="基础统计图"><a href="#基础统计图" class="headerlink" title="基础统计图"></a>基础统计图</h3><p>除了柱状图的<code>Bar()</code>之外，其他类型的图有XY、Line、Pie、Box、Histogram等，挺常规。</p>
<p>在个性化配置方面，初始化bar对象时可设置颜色、设置标题、设置x轴，再加y轴数据，最后渲染出图。</p>
<p>细化的属性包括控制柱的形状，如获得圆角矩形柱。print_values控制是否显示图上的文本标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> Style</span><br><span class="line">bar= pygal.Bar(style=Style(colors=[<span class="string">&#x27;#1eafae&#x27;</span>,<span class="string">&#x27;#ba5c25&#x27;</span>]), print_values=<span class="literal">True</span>, print_values_position=<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">bar.title = <span class="string">&#x27;柱状图01&#x27;</span>  <span class="comment">#设置标题和x轴标签</span></span><br><span class="line">bar.x_labels =[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>]</span><br><span class="line">bar.add(<span class="string">&#x27;Y&#x27;</span>,[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>])</span><br><span class="line">bar.add(<span class="string">&#x27;Z&#x27;</span>,[<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>]) <span class="comment">#簇状柱图</span></span><br><span class="line"></span><br><span class="line">bar.render_in_browser()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar= pygal.Bar(rounded_bars=<span class="number">20</span>)  <span class="comment">#控制柱的形状，圆角矩形柱</span></span><br><span class="line">bar.x_labels =[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>]</span><br><span class="line">bar.add(<span class="string">&#x27;Y&#x27;</span>,[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>])</span><br><span class="line">bar.render_in_browser()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-pygal/0-907-13-01-2-pygal-bar.png" alt="簇状柱图绘制效果"></p>
<p>多个add是簇状柱图，会自动处理x轴上排列的细节，不需要手动配置。从柱状图变成堆叠柱状图用StackedBar，示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bar= pygal.StackedBar(style=Style(colors=[<span class="string">&#x27;#1eafae&#x27;</span>,<span class="string">&#x27;#ba5c25&#x27;</span>]),print_values=<span class="literal">True</span>)</span><br><span class="line">bar.title = <span class="string">&#x27;堆叠柱状图&#x27;</span></span><br><span class="line">bar.x_labels =[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>]</span><br><span class="line">bar.add(<span class="string">&#x27;Y&#x27;</span>,[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>])</span><br><span class="line">bar.add(<span class="string">&#x27;Z&#x27;</span>,[<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>])</span><br><span class="line">bar.render_in_browser()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-pygal/0-907-13-01-3-pygal-stackbar.png" alt="堆叠柱状图绘制示例"></p>
<p>XY表示散点图，其他库可能更喜欢用Scatter。Line绘制折线图，在初始化<code>pygal.Line()</code>时设置参数fill=True，则绘制的是填充的面积图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chart= pygal.Line(interpolate=<span class="string">&#x27;cubic&#x27;</span>,fill=<span class="literal">True</span>,style=Style(colors=[<span class="string">&#x27;#1eafae&#x27;</span>,<span class="string">&#x27;#ba5c25&#x27;</span>]),print_values=<span class="literal">True</span>,print_values_position=<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">chart.title = <span class="string">&#x27;平滑曲线图（填充）&#x27;</span>  </span><br><span class="line">chart.x_labels =[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>]</span><br><span class="line">chart.add(<span class="string">&#x27;Y&#x27;</span>,[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>])</span><br><span class="line">chart.add(<span class="string">&#x27;Z&#x27;</span>,[<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>])</span><br><span class="line">chart.render_in_browser()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-pygal/0-907-13-01-4-pygal-line.png" alt="pygal绘制折线图"></p>
<p><img src="/2020/04/28/viz-pygal/0-907-13-01-5-pygal.png" alt="填充面积图示例"></p>
<p>pygal绘制一些实用特色图表很方便，因为都封装好了，并且可调节的参数不少，这是该库的优势之一。</p>
<h3 id="特色图表"><a href="#特色图表" class="headerlink" title="特色图表"></a>特色图表</h3><p>通过Radar可以初始化一个雷达图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rdr= pygal.Radar(style=Style(colors=[<span class="string">&#x27;#1eafae&#x27;</span>,<span class="string">&#x27;#ba5c25&#x27;</span>]),print_values=<span class="literal">True</span>,print_values_position=<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">rdr.title = <span class="string">&#x27;雷达图&#x27;</span> </span><br><span class="line">rdr.x_labels =[<span class="string">&#x27;Mon.&#x27;</span>,<span class="string">&#x27;Tue.&#x27;</span>,<span class="string">&#x27;Wed.&#x27;</span>,<span class="string">&#x27;Thu.&#x27;</span>,<span class="string">&#x27;Fri.&#x27;</span>]</span><br><span class="line">rdr.add(<span class="string">&#x27;Y&#x27;</span>,[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>])</span><br><span class="line">rdr.add(<span class="string">&#x27;Z&#x27;</span>,[<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>])</span><br><span class="line"></span><br><span class="line">rdr.render_in_browser()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-pygal/0-907-13-02-1-pygal-rader.png" alt="pygal绘制雷达图"></p>
<p>在pygal源码中，Rader继承自Line，符合图形语法的理念， Line()则是直接继承Graph。</p>
<p>能快速绘制出仪表盘图的Python库并不多，仪表盘图在pygal里是SolidGauge，可以设置是半饼或360度的仪表盘范围，仪表盘是各种可视图表的规律排列，而仪表盘图在实际应用中可以形象地表示任务KPI的完成进度，和温度计图功能相似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#仪表盘图</span></span><br><span class="line">gauge = pygal.SolidGauge(half_pie=<span class="literal">True</span>, inner_radius=<span class="number">0.70</span>,print_values=<span class="literal">True</span>)</span><br><span class="line">gauge.title = <span class="string">&#x27;当前完成度&#x27;</span> </span><br><span class="line">gauge.value_formatter =<span class="keyword">lambda</span> x: <span class="string">&#x27;&#123;:.1f&#125;%&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line">gauge.add(<span class="string">&#x27;cur&#x27;</span>,<span class="number">80</span>)</span><br><span class="line">gauge.render_in_browser()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-pygal/0-907-13-02-2-pygal-gauge.png" alt="仪表盘图绘制示例"></p>
<p>Pyramid表示金字塔图，也称为蝴蝶图，可以方便地对比两组数据的分布结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Pyramid</span></span><br><span class="line">chart = pygal.Pyramid(style=Style(colors=[<span class="string">&#x27;#1eafae&#x27;</span>,<span class="string">&#x27;#ba5c25&#x27;</span>]))</span><br><span class="line">chart.title = <span class="string">&#x27;金字塔图(Y和Z同组对比)&#x27;</span> </span><br><span class="line">chart.add(<span class="string">&#x27;Y&#x27;</span>,[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>])</span><br><span class="line">chart.add(<span class="string">&#x27;Z&#x27;</span>,[<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>])</span><br><span class="line"></span><br><span class="line">chart.render_in_browser()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-pygal/0-907-13-05-2-pygal.png" alt="pygal绘制金字塔图"></p>
<p>pygal绘制树状图使用Treemap，电脑磁盘文件的归属关系和文件大小比较可以形象地用树状图表示出来，输入的数据结构不需要很复杂，一些细节的调节和排列pygal都处理好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Treemap</span></span><br><span class="line">treemap = pygal.Treemap()</span><br><span class="line">treemap.title = <span class="string">&#x27;树状图&#x27;</span></span><br><span class="line">treemap.add(<span class="string">&#x27;X&#x27;</span>, [<span class="number">9</span>,<span class="number">7</span>,<span class="number">81</span>,<span class="number">40</span>])</span><br><span class="line">treemap.add(<span class="string">&#x27;Y&#x27;</span>, [<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>])</span><br><span class="line">treemap.add(<span class="string">&#x27;Z&#x27;</span>, [<span class="number">37</span>,<span class="number">46</span>,<span class="number">53</span>,<span class="number">81</span>,<span class="number">60</span>])</span><br><span class="line">treemap.add(<span class="string">&#x27;K&#x27;</span>, [<span class="number">52</span>, <span class="number">71</span>])</span><br><span class="line"></span><br><span class="line">treemap.render_in_browser()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-pygal/0-907-13-05-3-pygal.png" alt="树状图绘制示例"></p>
<p>pygal还可以绘制分层设色的地图，但有依赖库，绘制地图需要额外安装三个库。<br>pygal_maps_world用于绘制全球各个国家投影地图，通过国家名称缩写索引到对应的国家，也可以索引到各大洲，可以对国家进行分层设色，是面状要素，没有点、线的个性化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chart=pygal.maps.world.world.World(style=Style(colors=[<span class="string">&#x27;#1eafae&#x27;</span>,<span class="string">&#x27;#69ffff&#x27;</span>, <span class="string">&#x27;#ba5c25&#x27;</span>, <span class="string">&#x27;#ffa069&#x27;</span>, <span class="string">&#x27;#a3ffff&#x27;</span>,<span class="string">&#x27;#d7ce88&#x27;</span>]))</span><br><span class="line">chart.title = <span class="string">&#x27;分层设色地图 pygal&#x27;</span></span><br><span class="line">chart.add(<span class="string">&#x27;2020&#x27;</span>, &#123;</span><br><span class="line">  <span class="string">&#x27;af&#x27;</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="string">&#x27;cn&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="string">&#x27;in&#x27;</span>: <span class="number">95</span>,</span><br><span class="line">  <span class="string">&#x27;ir&#x27;</span>: <span class="number">74</span>,</span><br><span class="line">  <span class="string">&#x27;sa&#x27;</span>: <span class="number">39</span>,</span><br><span class="line">  <span class="string">&#x27;us&#x27;</span>: <span class="number">49</span>,</span><br><span class="line">  <span class="string">&#x27;pk&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line">chart.render_in_browser()</span><br></pre></td></tr></table></figure>

<p>世界地图的地图图元用的是worldmap.svg。<br>pygal_maps_fr库用于法式地图，pygal_maps_ch绘制瑞士地图，具体使用时调用方式和上面的pygal_maps_world一致，都是可以根据缩写索引进行分层设色。</p>
<h3 id="迷你图"><a href="#迷你图" class="headerlink" title="迷你图"></a>迷你图</h3><p>pygal另外一大特色是单独支持生成数据的迷你图。对应的接口有<code>.render_sparkline()</code>和<code>.render_sparktext()</code><br>迷你图作为添色，可以用于快速概览数据的大小对比。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chart = pygal.Line()</span><br><span class="line">chart.add(<span class="string">&#x27;Y&#x27;</span>,[<span class="number">76</span>,<span class="number">37</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">50</span>])</span><br><span class="line">chart.render_sparktext()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-pygal/0-907-13-05-1-pygal.png" alt="pygal的特色之迷你图"></p>
<p>在实际使用中，chart初始化可以不是Line ，写其他也行，但成图就是无间隔柱状图，还是Line。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>pygal在Python可视化库中是很有特色的，很好地平衡了基础的统计图表类型和几个特色图表，接口使用方便，对使用者友好，是一个小巧且性感的库，值得了解和使用。其优点有接口容易使用、轻量化、能方便地绘制带交互效果的仪表盘图、仪表盘图、金字塔图和简单地图，SVG方便前端使用，也方便编辑，能够和d3等可视化库协同。目前该库在Github上有2.3k的star，说明认可和使用pygal的人挺多的。</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="http://www.pygal.org/en/stable/documentation/index.html">pygal文档</a></li>
<li><a href="https://github.com/Kozea/pygal">pygal Github页面</a></li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>viz</tag>
      </tags>
  </entry>
  <entry>
    <title>百川归海，四类图统揽统计图:Seaborn|可视化系列03</title>
    <url>/2020/04/28/viz-seborn.html</url>
    <content><![CDATA[<h3 id="Seaborn简介"><a href="#Seaborn简介" class="headerlink" title="Seaborn简介"></a>Seaborn简介</h3><p>Matplotlib虽然提供了丰富而强大的接口用于数据的可视化，但在展现多类数据关系时，需要较多数据处理过程，语句就变得繁琐，因此seaborn针对这类需求，基于matplotlib提供了更高层的接口，<strong>擅长统计数据的可视化</strong>。seaborn可视化的写法和matplotlib基本相同。其代码框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns  <span class="comment">#导入seabron库</span></span><br><span class="line">tips = pd.read_excel(<span class="string">&#x27;tips.xlsx&#x27;</span>)  <span class="comment">#dataframe数据</span></span><br><span class="line">sns.relplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, col=<span class="string">&quot;time&quot;</span>,</span><br><span class="line">            hue=<span class="string">&quot;smoker&quot;</span>, style=<span class="string">&quot;smoker&quot;</span>, size=<span class="string">&quot;size&quot;</span>,</span><br><span class="line">            data=tips)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><img src="/2020/04/28/viz-seborn/03-01-428-01.PNG" alt="效果图"></p>
<p>seaborn对pandas数据结构的支持非常好，能充分利用DataFrame的特点而不需要做格式转换。别期待着只用seaborn绘制出各种常用图表，它更专注于展示统计数据里的信息，因此，我们换个角度，从数据本身的分布和数据列之间的关系来看可视化。<a href="http://seaborn.pydata.org/">seaborn</a>没有直接枚举各种图的接口，而是抽象为了四种relplot、regplot、catplot及distplot，分别对应：数据关联、回归、分类变量和数据分布。</p>
<h3 id="关联-relplot"><a href="#关联-relplot" class="headerlink" title="关联 relplot"></a>关联 relplot</h3><p>seaborn对于数据间的关联关系，相关可视图封装为<code>sns.relplot()</code>。rel指的是Relational，擅长处理两个变量或多个变量之间的关联关系可视化。</p>
<p>relplot(x,y,data)默认是画出两个变量x,y的散点图以体现data中x列和y列的数据关系。</p>
<p>relplot的参数如下：</p>
<ul>
<li>data、x、y：分别是数据集、x轴对应值(data里的某一列的列名)、y轴对应值；</li>
<li>hue：色调，对数据的一种分类，通过颜色进行区分；如何指定颜色映射的规则呢？如Q1对应黄色，Q2对应青色？可通过palette及hue_norm/hue_order等参数进行定义；</li>
<li>kind：绘制图表的类型，relplot有两种选择，分别为<code>&quot;scatter&quot;</code>和<code>&quot;line&quot;</code>，默认是散点图，也即scatter；</li>
<li>style：映射不同的散点形状，圆形、三角形、十字等，容易想到ax.plot()里的标记字符fmt；</li>
<li>palette：调色板，指定hue的颜色映射用；</li>
<li>size：映射散点的大小；</li>
<li>sizes：控制散点大小的范围，和size搭配着用，如sizes=(10,100)就把size对应列的值标准化到[10,100]；</li>
<li>col、row：根据col和row参数决定分面后图的个数；</li>
</ul>
<p>总结如图：</p>
<p><img src="/2020/04/28/viz-seborn/03-02-relplot-428-01.PNG" alt="relplot参数卡片"></p>
<p>绘制最基础散点图以直观展现x和y的关系，只需要写<code>relplot(x,y,data)</code>，而要用颜色做分类、设置不同数据点形状及大小时，不需要像matplotlib一样先自己对数据做筛选，再调用多个<code>ax.plot(x1,y1)</code>来绘制。而是写sns.relplot(x=”total_bill”, y=”tip”, hue=”smoker”, size=”size”,data=tips)。</p>
<p>从本文的示例代码能看到的是，seaborn大部分都只需要调用一个函数，传参出图不墨迹，不需要自己写细节的数据处理代码。这就是高层次封装的意义。</p>
<p>relplot默认绘制的是散点图，设置参数<code>kind=&quot;line&quot;</code>可以将点连成线，也就是绘制折线图表示x和y的关系。</p>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>:<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>)),</span><br><span class="line">                 <span class="string">&#x27;y&#x27;</span>:[i**<span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>)]&#125;)</span><br><span class="line">sns.relplot(x=<span class="string">&#x27;x&#x27;</span>,y=<span class="string">&#x27;y&#x27;</span>,data=df,kind=<span class="string">&#x27;line&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="回归-regplot"><a href="#回归-regplot" class="headerlink" title="回归 regplot"></a>回归 regplot</h3><p>x和y之间的关系除了靠我们直观地看出来之外，我们需要有更量化的数据证据，统计数据少不了用统计的手段处理，回归曲线就是很好地表达数据关系的一种手段。sns.regplot(x,y,data)用于绘制散点+回归曲线图，默认包含置信区间，主要还是线性回归。reg表示的是Regression，regplot()绘图效果及主要参数如下：</p>
<p><img src="/2020/04/28/viz-seborn/03-02-regplot-428-01.png" alt="regplot"></p>
<p>regplot()主要参数和relplot()挺类似，多了关于统计回归的个性化参数，且没有kind参数，</p>
<ul>
<li>data、x、y：分别对应数据集、x轴对应值、y轴对应值；</li>
<li>x_estimator：是否显示x的估计量；</li>
<li>ci：回归的置信区间范围，在 0～100之间；</li>
<li>x_ci：可选”ci”或”sd”；</li>
<li>order：如果大于1，会使用numpy.polyfit来绘制高阶回归；</li>
<li>logx：如果是True，就变成了计算 y~log(x)的回归关系；</li>
<li>robust：如果是true，会使用统计模型考虑回归的鲁棒性，忽略异常值；</li>
<li>logistic：是否使用逻辑回归；</li>
<li>marker：散点的标记字符；</li>
<li>color：控制散点和回归线的颜色；</li>
</ul>
<p>regplot()进行非线性回归的代码如下，主要是改了order参数，示例数据建的是一个y=x^3的数据集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;x&#x27;</span>:<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>)),<span class="string">&#x27;y&#x27;</span>:[i**<span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>)]&#125;)</span><br><span class="line">sns.regplot(x=<span class="string">&quot;x&quot;</span>, y=<span class="string">&quot;y&quot;</span>, data=df,order=<span class="number">2</span>, ci=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-seborn/03-07-0-1-2.PNG" alt="03-07-0-1-2"></p>
<p>Regression部分的接口还有<code>.lmplot()</code>和 <code>residplot()</code>可以用，lmplot扩展了regplot的分面绘图功能，关于分面后续再展开，residplot用于绘制线性回归的残差(residuals)。对数据分类绘制多条回归线的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.lmplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, </span><br><span class="line">           hue=<span class="string">&quot;smoker&quot;</span>, data=tips,markers=[<span class="string">&quot;o&quot;</span>, <span class="string">&quot;x&quot;</span>])</span><br></pre></td></tr></table></figure>



<p>和Altair、plotnine、ggplot等可视化库一样，seaborn提供了好多个数据集，涵盖了各种数据关系和数据特征，方便教学使用，其中就包括久负盛名的iris(鸢尾花数据集)、titanic(泰坦尼克号船员数据集)等。通过<code>iris=sns.load_dataset(&#39;iris&#39;)</code>载入为标准的DataFrame格式，上一段绘制回归曲线就用到了seaborn提供的tips数据集。通过<code>sns.get_dataset_names()</code>可参看seaborn库所有的数据集名称。</p>
<h3 id="分布-distplot"><a href="#分布-distplot" class="headerlink" title="分布 distplot"></a>分布 distplot</h3><p>数据列与列之间隐藏着某种关系，我们很关注。我们也关心数据列内部的分布，是平均分布、随机分布还是聚集分布?？是每天花钱一样多还是某天就花了预算的80%？</p>
<p>数据的分布情况seaborn的绘制接口是<code>sns.distplot(a,bins)</code>，其主要参数和示例效果如下：</p>
<p><img src="/2020/04/28/viz-seborn/03-02-distplot-428-01.png" alt="03-02-distplot-428-01"></p>
<p>distplot()参数：</p>
<ul>
<li>a：一个一维的数组，没有data参数了，需要写df[‘a’]传入一个Series，不支持<code>sns.distplot(a=&#39;x&#39;,data=df)</code>  写法是一种遗憾，至少本文发出时这么写seaborn会报错：got an unexpected keyword argument ‘data’；</li>
<li>bins：分箱数，对应matplotlib的hist()的bins参数；</li>
<li>hist：默认distplot会画直方图和密度曲线，hist=False则只画密度曲线；</li>
<li>kde：核密度估计(kernel density estimate)，如果要只显示直方图呢？靠的就是kde参数，设置kde=False则只画分布直方图，没有密度曲线了；</li>
<li>rug：在直方图基础上再绘制地毯图效果，可以用sns.kdeplot(a)只画地毯图；</li>
<li>vertical：是否画垂直的直方图，类似条形图对应柱状图，vertial=True则绘制转了90度的直方图，分面的时候用得到；</li>
</ul>
<p>两个维度上的数据分布情况我们也很关心，seaborn也提供了相应的接口，用到的就是kdeplot，示例效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(tips[<span class="string">&#x27;total_bill&#x27;</span>],tips[<span class="string">&#x27;tip&#x27;</span>])</span><br></pre></td></tr></table></figure>


<p><img src="/2020/04/28/viz-seborn/03-07-0-1-6.PNG" alt="kdeplot"></p>
<h3 id="分类变量-catplot"><a href="#分类变量-catplot" class="headerlink" title="分类变量 catplot"></a>分类变量 catplot</h3><p>统计数据也不总是数值类型的，也会包含分类类型的数据(Categorical)，例如餐饮消费数据可以分早餐、午餐、晚餐。分类数据的特点是两个类别间不一定等间隔划分，周一到周二间隔是24小时，但早餐到午餐的间隔和午餐到晚餐的间隔就不一致，又如地震四级到五级的间隔与五到六级间隔的区别。</p>
<p>对于单一变量，我们可以统计出其在列中的出现次数，绘制柱状图、饼图等，用Matplotlib绘制需要自己做数据透视或value_counts()操作。seaborn将分类变量相关的可视图表封装在<code>sns.catplot()</code>里。</p>
<p><img src="/2020/04/28/viz-seborn/03-02-catplot-428-01.png" alt="catplot"></p>
<p>catplot参数：</p>
<ul>
<li>data、x、y：分别对应数据集、x轴对应值、y轴对应值，x会默认是一个分类变量，不是连续的数值；</li>
<li>hue：色调，将数据列映射到颜色；</li>
<li>orient：水平方向还是垂直方向上的分类；类似于柱状图vs条形图，可选{‘v’,’h’},对应vertical，horizontal；</li>
<li>kind：绘制图表类型，目前有{“point”, “bar”, “strip”, “swarm”, “box”, “violin”, “boxen”} 8种可选，是目前四大接口里支持最多的，可分为三类：分类散点图、分类变量分布图和分类变量估计图；各种有对应的plot一级接口，例如 .catplot(x,y,data,kind=’point’) 也可以写 .pointplot(x,y,data)，其他的也类似；</li>
</ul>
<p>统计tips数据集晚餐和午餐的出现次数，变成柱状图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">&#x27;time&#x27;</span>,y=<span class="string">&#x27;total_bill&#x27;</span>,data=tips,kind=<span class="string">&#x27;bar&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-seborn/03-07-0-0-9.PNG" alt="03-07-0-0-9"></p>
<p>countplot和barplot有些许不同，countplot不展示统计值的置信区间，countplot如果省略x而给y传参，得到的是条形图效果。</p>
<p><img src="/2020/04/28/viz-seborn/03-07-0-0-8.PNG" alt="03-07-0-0-8"></p>
<p>箱线图是在数据分析中高频出现的图，总览数据分布的时候又不失细节，绘制变量的箱线图也只需要一行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">&#x27;time&#x27;</span>,y=<span class="string">&#x27;tip&#x27;</span>,data=tips,kind=<span class="string">&#x27;box&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-seborn/03-07-0-0-4.PNG" alt="03-07-0-0-4"></p>
<p>可以看出晚餐在tips上数值范围更广，中位数也更高。</p>
<p>小提琴图比起箱线图，更好地利用宽度的变化来展现在同一个y处数据点的分布，绘制的形状像一个小提琴因此叫小提琴图(violin)。同样的数据列，绘制为小提琴图效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">&#x27;time&#x27;</span>,y=<span class="string">&#x27;tip&#x27;</span>,data=tips,kind=<span class="string">&#x27;violin&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-seborn/03-07-0-0-5.PNG" alt="03-07-0-0-5"></p>
<p><code>kind=&#39;point&#39;</code>绘制包含置信区间的点+折线图，端点有置信区间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">&quot;time&quot;</span>, y=<span class="string">&quot;total_bill&quot;</span>,hue=<span class="string">&quot;smoker&quot;</span>,kind=<span class="string">&quot;point&quot;</span>,data=tips, dodge=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2020/04/28/viz-seborn/03-07-0-1-7.PNG" alt="03-07-0-1-7"></p>
<h3 id="分面与子图"><a href="#分面与子图" class="headerlink" title="分面与子图"></a>分面与子图</h3><p>为了更好地展现数据间的关系，我们会需要将多张图排列展现多指标的情况，需要结合大小图突出信息。Facet提供了相应的接口。最常用的是<code>pairplot</code>和<code>jointplot</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, col=<span class="string">&quot;time&quot;</span>)</span><br><span class="line">g.<span class="built_in">map</span>(plt.hist, <span class="string">&quot;tip&quot;</span>);</span><br><span class="line">sns.pairplot(tips, hue=<span class="string">&quot;time&quot;</span>, diag_kind=<span class="string">&quot;kde&quot;</span>, height=<span class="number">2.5</span>)</span><br></pre></td></tr></table></figure>

<p>通过<code>g = sns.FacetGrid(tips, col=&quot;time&quot;)</code>可根据tips数据集的time列构建出多张图，每个time的取值（一般是分类变量）对应一张图，col参数在relplot的实践中提到过，通过<code>g.map(plt.hist, &quot;tip&quot;)</code>应用直方图，效果如下：</p>
<p><img src="/2020/04/28/viz-seborn/03-07-0-1-1.PNG" alt="03-07-0-1-1"></p>
<p>结合回归曲线图和直方图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.jointplot(x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>, data=tips,kind=<span class="string">&quot;reg&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2020/04/28/viz-seborn/03-07-0-1-4-jointplot.PNG" alt="03-07-0-1-4-jointplot"></p>
<p>热力图可以展现一个矩阵类型的数据，用来展现x和y可能存在的某种模式，除了地理上的分布模式外，日历图是热力图的一个经典例子，基于tips数据的热力图绘制效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.heatmap(tips.loc[:,[<span class="string">&#x27;total_bill&#x27;</span>,<span class="string">&#x27;tip&#x27;</span>,<span class="string">&#x27;size&#x27;</span>]].head(<span class="number">10</span>), cmap=<span class="string">&quot;YlGnBu&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/viz-seborn/03-07-0-1-5.PNG" alt="03-07-0-1-5"></p>
<p>可视化时除了图表类型的挑选外，为了更好看及主题一致性等目的，颜色和样式的个性化配置也是很重要的，可视化库自然不能忽略相关的接口，seaborn有个总览的<code>sns.set()</code>接口，也有<code>sns.set_palette(&quot;husl&quot;)</code>和<code>sns.set_style(&quot;darkgrid&quot;,&#123;&quot;axes.facecolor&quot;: &quot;.9&quot;&#125;)</code>和<code>sns.set_context(&quot;paper&quot;)</code>可以用，seaborn内置了挺多色盘，可以通过<code>sns.dark_palette()</code>类似的语句获取色盘，通过<code>sns.set_palette(sns.color_palette([&quot;#9b59b6&quot;, &quot;#3498db&quot;, &quot;#95a5a6&quot;]))</code>设置个性化色盘。</p>
<p>seaborn的数据集挂在<a href="https://github.com/mwaskom/seaborn-data">https://github.com/mwaskom/seaborn-data</a>下，在使用sns.load_dataset(‘iris’)如果遇到<br>报错（timeout error、URLError、OSError或其他），可以从这个github地址直接下载数据再通过pd.read_csv()导入使用，整个数据集合一共4.5MB，占资源并不大。<br>根据数据的类型选择可视化类型可以参考<a href="https://www.data-to-viz.com/">data-to-viz.com</a>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可视化图表类型众多，echarts的案例菜单栏就分了27种有效图表、antv的案例菜单目前分了14种可视图，百川归海，seaborn将统计数据的可视化分为了四类，简化了绘图语句，并提供了多套配色和主题效果可以选择，让我们节约在绘图上的时间，更好地探索数据中的信息。因为seaborn是基于matplotlib的，两者可以很好地协作，通过调用不同层级的接口来实现更精细的需求。</p>
<p>seaborn目前是0.10.1版本，例子和API文档都还不够丰富，如很多绘图的API只有一段文字说明，没有绘制效果的例子；又如catplot的文档在最上面列出了hue，而详细解释部分没有hue。期待其后续更强大的功能和更详细的文档。</p>
<p><img src="/2020/04/28/viz-seborn/03-12-Seaborn-viz.png" alt="seaborn库API思维导图"></p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="http://seaborn.pydata.org/">官网</a></li>
<li><a href="https://www.data-to-viz.com/">https://www.data-to-viz.com</a></li>
</ul>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>viz</tag>
      </tags>
  </entry>
  <entry>
    <title>一个基于canvas的简洁的Python可视化库:toyplot</title>
    <url>/2020/03/29/viz-toyplot.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>toyplot是一个基于canvas的简洁的Python可视化库，还在发展中，目前是0.19版；<br>打印标准图，有一定交互性，底层是canvas，易于在前端使用分享；<br>在notebook中的渲染，在其他环境中的内嵌做得挺好；qt等GUI环境支持好；<br>用css的写法配置样式，目前这个库在gtihub上有400余个star。</p>
<p>绘图框架：</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> toyplot</span><br><span class="line">canvas = toyplot.Canvas()  <span class="comment">#不写前面canvas不出图</span></span><br><span class="line">axes = canvas.cartesian()</span><br><span class="line">mark = axes.plot(df[<span class="string">&#x27;y&#x27;</span>], style=&#123;<span class="string">&quot;stroke&quot;</span>:<span class="string">&quot;#1EAFAE&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;stroke-dasharray&quot;</span>:<span class="string">&quot;2, 2&quot;</span>&#125;) <span class="comment">#支持css的style</span></span><br></pre></td></tr></table></figure>



<p><img src="/2020/03/29/viz-toyplot/0-908-13-01-1-toyplot-fwk.PNG" alt="0-908-13-01-1-toyplot-fwk"></p>
<p>画布+坐标系统+映射类型</p>
<p>With Toyplot, a figure always consists of three parts:</p>
<ul>
<li>A canvas</li>
<li>One or more sets of coordinate systems added to the canvas.</li>
<li>One or more marks added to the axes.</li>
</ul>
<p>详解：<br>建<br>cartesian  笛卡尔坐标系<br>只传y的数，x会默认使用range(0,len(y))</p>
<p>以上语句也可以用连缀写法写为：<br>···toyplot.Canvas().cartesian().plot(y)</p>
<p>axes.plot(x, series)  传x，传y，设置样式；<br>图形默认更好地展示，y轴不默认从0开始<br>css样式写法，在plot对象里用<br>多条线就在axes多调用</p>
<p><img src="/2020/03/29/viz-toyplot/lyndonlcf/LCFONEFOR/2019%E6%98%A5/%E6%96%87%E7%AB%A0%E7%B4%A0%E6%9D%90%E6%95%B4%E5%90%88/17-%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%93%E9%A2%98/_posts-202009/viz-toyplot/0-908-13-01-2-toyplot.PNG" alt="多条线并设置样式 toyplot"></p>
<p>多条曲线也可以写 mark = axes.plot(x, series) #series = numpy.column_stack((y1, y2, y3))</p>
<p>bars  不是bar</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">canvas = toyplot.Canvas()</span><br><span class="line">axes = canvas.cartesian()</span><br><span class="line">mark = axes.bars(df[<span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>





<p>【bar+line】 （图层顺序，语句顺序对应图层顺序，举例，在前在后）</p>
<p><img src="/2020/03/29/viz-toyplot/0-908-13-01-3-toyplot-bar+line.PNG" alt="0-908-13-01-3-toyplot-bar+line"></p>
<p>bar并且设置文本标签（会讲坐标映射，分类变量的处理）<br>（ValueError: could not convert string to float: ‘Mon.’）</p>
<p>设置文本角度 和上面的图对比一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">canvas = toyplot.Canvas()</span><br><span class="line">axes = canvas.cartesian()</span><br><span class="line">yz=[(i,j) <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(y,z)]</span><br><span class="line">mark1 = axes.bars(yz)  <span class="comment">#注意格式，是[(y1,z1),] 不是[y,z]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/29/viz-toyplot/0-908-13-01-5-toyplot-stackbar.PNG" alt="堆叠柱 stackbar"></p>
<p>设置标题及文本标签，双轴</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">canvas = toyplot.Canvas()</span><br><span class="line">axes = canvas.cartesian(label=<span class="string">&quot;双轴demo&quot;</span>,xlabel=<span class="string">&quot;Weekday&quot;</span>,ylabel=<span class="string">&quot;Y&quot;</span>,ymin=<span class="number">0</span>)</span><br><span class="line">axes.x.ticks.locator = toyplot.locator.Explicit(labels=df[<span class="string">&#x27;x&#x27;</span>]) <span class="comment">#横轴文本标签</span></span><br><span class="line">mark1 = axes.bars(y)</span><br><span class="line">axes2 = axes.share(<span class="string">&quot;x&quot;</span>,ylabel=<span class="string">&quot;H&quot;</span>) <span class="comment">#共享一套x轴开双轴</span></span><br><span class="line">mark2=axes2.plot(h, style=&#123;<span class="string">&quot;stroke&quot;</span>:<span class="string">&quot;#1EAFAE&quot;</span>&#125;)</span><br><span class="line">axes2.y.spine.style = &#123;<span class="string">&quot;stroke&quot;</span>:<span class="string">&quot;#1EAFAE&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/29/viz-toyplot/0-908-13-01-6-toyplot-share-axes.PNG" alt="双轴 share-axes"></p>
<p>分面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">canvas = toyplot.Canvas(<span class="number">600</span>, <span class="number">300</span>)</span><br><span class="line">axes = canvas.cartesian(grid=(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">mark = axes.plot(y)</span><br><span class="line">axes = canvas.cartesian(grid=(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">mark = axes.plot(z)</span><br></pre></td></tr></table></figure>



<p><img src="/2020/03/29/viz-toyplot/lyndonlcf/LCFONEFOR/2019%E6%98%A5/%E6%96%87%E7%AB%A0%E7%B4%A0%E6%9D%90%E6%95%B4%E5%90%88/17-%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%93%E9%A2%98/_posts-202009/viz-toyplot/0-908-13-01-7-toyplot-grid.PNG" alt="分面 toyplot-grid"></p>
<p>grid</p>
<p>支持的图形目前挺有限，fill</p>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>作用：散点+椭圆边形成密度效果</p>
<p>toyplot.plot(y)  在matixe里说到<br>输入矩阵</p>
<p>两种写法；<br>但matrix就是属于toyplot的，目前写axes.matrix(mtx) 会报错说<code>&#39;Cartesian&#39; object has no attribute &#39;matrix&#39;</code>，所以mat只有一种写法，其他有两种；</p>
<p>交互及sav csv  方便数据交换<br>【矩阵图 动图，效果不是特别好，需要剪一下再说】<br>【目前mp4在d3的PPT里】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#椭圆</span></span><br><span class="line">canvas = toyplot.Canvas()</span><br><span class="line"></span><br><span class="line">axes = canvas.cartesian(aspect=<span class="string">&quot;fit-range&quot;</span>)</span><br><span class="line">axes.ellipse(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">45</span>); <span class="comment"># [x,y] 半长轴，半短轴，旋转角度</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">canvas = toyplot.Canvas(width=<span class="number">800</span>, height=<span class="number">400</span>)</span><br><span class="line">axes = canvas.cartesian(grid=(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>),label=<span class="string">&quot;正常椭圆&quot;</span>)</span><br><span class="line">axes.ellipse(<span class="number">20</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">30</span>,style=&#123;<span class="string">&quot;stroke&quot;</span>: <span class="string">&quot;black&quot;</span></span><br><span class="line">                                      ,<span class="string">&quot;fill&quot;</span>:<span class="string">&quot;#1EAFAE&quot;</span>,<span class="string">&quot;opacity&quot;</span>:<span class="number">0.7</span>&#125;)</span><br><span class="line">axes = canvas.cartesian(yscale=<span class="string">&quot;log&quot;</span>,grid=(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>), label=<span class="string">&quot;对数坐标轴椭圆效果&quot;</span>)</span><br><span class="line">axes.ellipse(<span class="number">20</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">30</span>) <span class="comment">#把y做对数变换</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/29/viz-toyplot/0-908-13-02-1-toyplot-ellipse.PNG" alt="toyplot ellipse"></p>
<h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p>toyplot.graph(s,t)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sources = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line">targets = [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]</span><br><span class="line">toyplot.graph(sources, targets)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">layout = toyplot.layout.FruchtermanReingold(edges=toyplot.layout.CurvedEdges())</span><br><span class="line">toyplot.graph(edges, layout=layout, width=<span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/29/viz-toyplot/0-908-13-02-3-toyplot-graph.PNG" alt="toyplot graph"></p>
<p>设置节点的形状（如变成矩形）、颜色、边的样式（如虚线）、边的文本标签、指向 都能做到<br>节点颜色根据数值大小染色</p>
<p>目前没有pie<br>图片 toyplot.image(image, width=300)  结合PIL.Image</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PIL.Image</span><br><span class="line"><span class="keyword">import</span> toyplot</span><br><span class="line"></span><br><span class="line">image = PIL.Image.<span class="built_in">open</span>(<span class="string">&quot;../artwork/toyplot.png&quot;</span>)</span><br><span class="line">canvas, mark = toyplot.image(image, width=<span class="number">300</span>)</span><br></pre></td></tr></table></figure>





<p>动画 canvas.frames 逐帧动画</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">canvas = toyplot.Canvas(<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">axes = canvas.cartesian()</span><br><span class="line">mark = axes.scatterplot(y, size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> frame <span class="keyword">in</span> canvas.frames(<span class="built_in">len</span>(y) + <span class="number">1</span>): <span class="comment">#动画帧</span></span><br><span class="line">    <span class="keyword">if</span> frame.number == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y)):</span><br><span class="line">            frame.set_datum_style(mark, <span class="number">0</span>, i, style=&#123;<span class="string">&quot;opacity&quot;</span>:<span class="number">0.1</span>&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        frame.set_datum_style(mark, <span class="number">0</span>, frame.number - <span class="number">1</span>, style=&#123;<span class="string">&quot;opacity&quot;</span>:<span class="number">1.0</span>&#125;)</span><br></pre></td></tr></table></figure>





<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> toyplot.pdf</span><br><span class="line">toyplot.pdf.render(canvas, <span class="string">&quot;figure1.pdf&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>类似的有：</p>
<ul>
<li>toyplot.png.render(canvas, “figure1.png”)</li>
<li>toyplot.html.render(canvas, “figure1.html”)</li>
</ul>
<p>svg就复杂一些了，毕竟是需要canvas转svg存储。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">svg = toyplot.svg.render(canvas)</span><br><span class="line">svg.attrib[<span class="string">&quot;class&quot;</span>] = <span class="string">&quot;MyCustomClass&quot;</span></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> xml</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;figure1.svg&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(xml.tostring(svg))</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>把简介再重复一下</p>
<p>toyplot是一个基于canvas的简洁的Python可视化库，还在发展中，目前是0.19版；<br>可能因为还不够完善，中文教程和介绍文章很少，几乎找不到详细的介绍文章；</p>
<p>参考资料</p>
<ul>
<li>官方文档：<a href="https://toyplot.readthedocs.io/en/stable/">https://toyplot.readthedocs.io/en/stable/</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>viz</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾Windows to Go小记</title>
    <url>/2020/09/20/win-to-go-deploy.html</url>
    <content><![CDATA[<h3 id="为什么需要配Windows-to-go"><a href="#为什么需要配Windows-to-go" class="headerlink" title="为什么需要配Windows to go"></a>为什么需要配Windows to go</h3><blockquote>
<p>Windows To Go 是 Windows 10 企业版和 Windows 10 教育版中的一项功能，支持创建可从电脑上 USB 连接的外部驱动器启动的 <a href="https://docs.microsoft.com/zh-cn/windows/deployment/planning/windows-to-go-overview">Windows To Go 工作区</a>。 </p>
</blockquote>
<p>说得通俗一点就是把 Windows 系统集成到U盘等便携设备上，且能在不同的电脑硬件上直接运行。无论走到天涯海角，都可以在任何一台符合基本条件的电脑上，使用U盘里安装的系统。这个系统是包含了安装的各种软件和个性化设置的Windows系统。大家配置Windows to go（简称WTG）的原因主要有：电脑是Mac，想有Windows打游戏；经常出差需要用其他地方的电脑，不习惯用那些电脑的Win 7甚至XP；配某些开发环境，换一个环境只需要再拿这个U盘做一次Windows to go。</p>
<a id="more"></a>

<p>对于我来说，目前主力机不是Windows系统，但因处理数据经常用Excel、Power BI等需要有Windows 10系统，用了半年虚拟机，感觉性能不够（电脑是中端机型），考虑了双系统、surface、WTG等解决方案后，选择配一个Windows to go系统，只需带个U盘，在其他地方也能用这个包含了特定软件的Windows系统。</p>
<p>确定了要做，那就动手吧。</p>
<p>主要准备好两样东西：</p>
<ul>
<li>16G以上的U盘</li>
<li>Windows系统iso文件</li>
</ul>
<p>一个装载好的Windows 10系统占10多G的空间，因此U盘最好32G以上，为了读取速度，最好是USB 3.0或3.1，USB 2.0就捉襟见肘了，我买的是128G的闪迪cz880，U盘的选择当然越大越好，速度越快体验越好，价格也越高，根据自己的需求取舍，一些IT论坛会列出推荐的U盘型号。<br>在电商网站下单后，等快递的同时下载Windows 10的系统，系统下载完而U盘也备好之后，开始正式制作。</p>
<h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>在Windows 10<strong>企业版和教育版</strong>中内置了Windows to go的制作工具，在系统搜索栏可搜索到，如果没有就选择用第三方工具制作，我是用的第三方工具制作的（需在Windows系统电脑下配置，如果手头是Mac电脑就去找一台Windows电脑&lt;如借朋友同学的&gt;去制作）。相关教程采用的工具有：Rufus、WTG Free、WTGA等，自己用的是WTGA<a href="https://bbs.luobotou.org/thread-761-1-1.html">WTG辅助工具</a>，下载辅助工具后，插入u盘后运行工具软件，选择Windows ios镜像，自己是选择VHD模式去做的，然后点<strong>部署</strong>，等待10多分钟安装好。</p>
<p>安装之后就是启动WTG中的系统了，Mac在第一次启动WTG之前，需要下载WindowsSupport 软件，具体过程可参考<a href="https://sspai.com/post/44699">少数派的教程</a>，自己并没有Mac去实践。</p>
<p>非Mac电脑就比较容易，将电脑关机，按开机键后按F12进入bios（大部分牌子的电脑是F12键进入，少部分是F2或F7，可搜索<em>电脑品牌+bios</em> 找到快捷键），选择从移动设备启动，然后开机进入的就是WTG上的Windows 10系统了，首次进入需要配一些基础的内容，和买电脑时进入系统的配置一致。</p>
<p><img src="/2020/09/20/win-to-go-deploy/301365770.jpg" alt="进入系统启动后"></p>
<p>进入后首先下载各种必备软件，包括输入法、chrome、云笔记及office（或WPS）等，还有Python也是必备的。之前为了方便重装系统、换手机等的初始化，一直在维护一个个人装机软件列表，我自己是按照列表中的提示去安软件的。下载安装过程中做一些基础的个性化，换桌面背景图、设置账户头像、删除回收站的图标等。</p>
<p><img src="/2020/09/20/win-to-go-deploy/python-in-cmd-16.PNG" alt="安装Python并启动"></p>
<h3 id="Windows个性化"><a href="#Windows个性化" class="headerlink" title="Windows个性化"></a>Windows个性化</h3><p>拥有自己各种常用设置和排布的系统才是有灵魂的。因此还需要做一些进一步的设置。</p>
<p><strong>删减“此电脑”下的显示</strong>：每次看文件管理右边的视频、文档、图片等占了很大文字，大部分数据自己还是更习惯存在D盘，因此视频这些基本用不到，因此选择把这个快捷链接删掉（不是删掉原始的文件夹，原始的文件夹位于C:\Users\XXX（用户名））。通过编辑注册表解决；首先是按Win+R之后输入Regedit进入注册表编辑器，定位到<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace</code>（可通过复制路径在编辑器里输入直接跳转，就像文件管理下输入文件路径跳转一样），在NameSpace下删除想删的注册表项之后那几个按钮就没了（如果觉得日后又需要显示这些可以先把NameSpace导出）。</p>
<p><img src="/2020/09/20/win-to-go-deploy/namespace-setting.PNG" alt="mycomputer-namespace-setting"></p>
<p>六个按钮对应的路径如下：</p>
<ul>
<li><p><strong>“下载”文件夹：</strong>{088e3905-0323-4b02-9826-5d99428e115f}</p>
</li>
<li><p><strong>“图片”文件夹：</strong>{24ad3ad4-a569-4530-98e1-ab02f9417aa8}</p>
</li>
<li><p><strong>“音乐”文件夹：</strong>{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}</p>
</li>
<li><p><strong>“文档”文件夹：</strong>{d3162b92-9365-467a-956b-92703aca08af}</p>
</li>
<li><p><strong>“视频”文件夹：</strong>{f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a}</p>
</li>
<li><p><strong>“桌面”文件夹：</strong>{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}</p>
</li>
</ul>
<p>自己保留图片和下载文件夹链接，其余的链接删掉。</p>
<p><strong>清理桌面右键菜单</strong>：同样是打开注册表，定位到<code>HKEY_CLASSES_ROOT\Directory\Background\shellex\ContextMenuHandlers </code>文件夹下面自己不需要的菜单项删除掉。</p>
<p><strong>设置登录时的文本显示</strong>：同样是通过注册表编辑实现，在注册表编辑器中定位到<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</code> ，在右侧查找名为“LegalNoticeCaption”和“LegalNoticeText”的两个文件。只要我们把想要显示在用户登录（或电脑锁定界面）的文字依次填写在这两个文件的数值数据中就OK了。“LegalNoticeCaption”中填写的内容为正常字体显示，而“LegalNoticeText”显示的字体较小，类似注释。登录时的效果如下（据说给别人修电脑时使用有奇效）：</p>
<p><img src="/2020/09/20/win-to-go-deploy/winlogon-setting.jpg" alt="Winlogon-setting"></p>
<p>设置这个的不好之处是每次开机还要额外点一下确定才能进入登录界面（好处是每次开机可以被上面的话激励，适合用来设置打鸡血的文字），如果不需要这一功能就把LegalNoticeCaption和LegalNoticeText的文本清空就OK。</p>
<p><strong>设置Adobe产品启动图</strong>：将PS的启动图设置为自己喜欢的图，通过ResHacker软件修改PS安装目录下的PSArt.dll文件修改PNGF/SPLASHBACKGROUND.PNG的资源文件为相应图片，之后再启动PS时就是个性化的酷炫效果了，另外将PSArt.dll文件复制到资料文件里，以后重装系统只需要用这个PSArt.dll替代就可以，不需要每次重头做。<a href="https://mp.weixin.qq.com/s/xV--3K3QBUhgYbgSgDIGyQ">具体过程可参考</a></p>
<p><strong>删除移动操作系统标识</strong>：有时候可能会遇到WTG系统在使用时出现：当前为windows go to 分区，无法执行本操作，需要在注册表中定位到<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control</code>，然后找到PortableOperatingSystem，右键单击删除。这个注册表项是WinToGo专有的，在正常安装的Windows里不存在，因此删除不影响正常功能。</p>
<p>设置完毕后，就是享受这个系统的便利性。</p>
<p><img src="/2020/09/20/win-to-go-deploy/using-at-ots.png" alt="在其他电脑启动的效果图"></p>
<h3 id="个人使用体验"><a href="#个人使用体验" class="headerlink" title="个人使用体验"></a>个人使用体验</h3><p>自己已经体验WTG有5天了，也尝试了各种日常需求场景的使用。之前用VMware跑虚拟机的时候，电脑风扇总是声音挺大的，跑不动编程集成环境，带不动Pr（于是就卸载了），用Excel打开15MB以上的excel经常会卡。而目前用WTG开类似的Excel使用正常，在Idea及Pycharm上运行代码也不卡。 </p>
<p>与虚拟机及双系统相比相比，WTG不占用原有的磁盘空间，和使用它的设备相互独立。WTG的缺点是同一时间只能用一个系统了，同一时间两个系统都要用的场景不多，都可以通过相应软件及云笔记在同一个系统实现需求。anyway，这次配置的WTG是自己之后近3年的Windows主力。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows/deployment/planning/windows-to-go-overview">微软官网文档</a></li>
<li><a href="https://bbs.luobotou.org/thread-2427-1-1.html">将Windows 8/10 系统装进优盘</a></li>
<li><a href="https://sspai.com/post/44699">说走就走的「Windows」—— Windows To Go 制作详解</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python形象地解决酒缸分酒问题</title>
    <url>/2019/09/09/wine-jar-solution-using-py-gui.html</url>
    <content><![CDATA[<p>最近遇到一个有意思的题目，看上去不相关的两个事物有着同样的转移状态，并且设定规则后过程可以用程序模拟出来，遂记之。</p>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><blockquote>
<p>你有一个8升的酒坛，里面装满了酒，另外还有两个分别是5升和3升的空酒坛，3个酒坛都没有刻度，现在需要倒出正好4升的酒，需要怎么操作？</p>
</blockquote>
<a id="more"></a>

<p>从题目来看，我们需要把3个缸的酒倒来倒去，直到某个酒缸里面是4升酒。这个问题的解法很有趣，我们假设能装5升酒的坛子叫A，3升的坛子是B，8升的坛子是C，<strong>开始的时候</strong>我们可以先在A坛子里装满酒也可以先在B坛子装满酒（只装一部分我们是没办法知道是多少升的，没有用）。<br>假设先给A装满酒，那么A,B坛子的状态就是(5,0)，表示这时候是A有5升酒，B有0升，这时候可以的做法是把A中的酒倒到B里，变成(2,3)，也可以从C倒3升到B，变成(5,3)，但这种情况下一步只能把A或B中的酒倒回C，回到开始状态了；第三种情况是把A中的酒倒进C里，变成(0,0)，更加没意义了。</p>
<p>一个3种倒酒情况的图</p>
<h3 id="台球解法"><a href="#台球解法" class="headerlink" title="台球解法"></a>台球解法</h3><p>于是有效做法是从(5,0)状态变成(2,3)状态，我们可以想象一个菱形的台球桌，从一个地方发球，球经过和桌子边缘的碰撞有一个弹射的路径。来看一下一个从(5,0)出发的球，在一个5 x 3的台球桌上，沿三角形边线方向撞击台球，其路径会是(2,3)   (2,0) (0,2)   (5,2)  (4,3)<br>如下图</p>
<p><img src="/2019/09/09/wine-jar-solution-using-py-gui/wine-jar-su-01-pic01.PNG" alt="台球弹射路径"></p>
<p>我们之前把(5,0)理解为A坛有5升酒，B坛有0升，那么从(5,0)到(2,3)到(2,0)就可以理解为这两个酒坛里面液体的量的变化，也就是酒坛里的状态转移路径。</p>
<p><img src="/2019/09/09/wine-jar-solution-using-py-gui/iowt9-ep92n-01.gif" alt="动图效果"></p>
<p>具体就是从A倒酒进B里，直到B满了（变成(2,3)），再把B里的酒倒到C里，变成(2,0)，把B中剩余的2升倒到C里，变成(0,2),这时候把B倒满，变成(5,2)，B可以装3升，目前是2升，所以从A倒酒进B里，B原来是2升，倒满就是从A倒出了1升，所以A是4升，也就是(4,3)，达到要求，</p>
<p>实际中解这类题我们可以画x*y的菱形手动画路径，但我们可以用程序模拟这一过程，下面用Python实现一下。</p>
<h3 id="python-模拟"><a href="#python-模拟" class="headerlink" title="python 模拟"></a>python 模拟</h3><p>可以通过计算方向和用反射定律去模拟球的轨迹，也可以取巧只通过路径去模拟轨迹。<br>首先这个台球桌是菱形的，出发点在(5,0)或(0,3) （都能得到结果），我们从路径上看，(5,0)只有一个路径可以走，而(2,3)有两条路可以走，分别到达(2,0)或者(5,0)，在(0,0)以及(5,3)这两个点是没有路径的，</p>
<p><img src="/2019/09/09/wine-jar-solution-using-py-gui/wine-jar-su-03-001.PNG" alt="3种路径的示意图"></p>
<p>我们再分析路径的规律，x横坐标的最大值，y是纵坐标最大值，设n球在横坐标的位置，m为在纵坐标上的位置，对于点设n球在横坐标的位置，m为在纵坐标上的位置，对于点(n,0)，n不等于0和不等于x时，都有两条路，且从一条路过来必然下一步要走另一条路，这两条路的规律是(n,y)以及(0,n)，当n大于y时，到不了(0,n)，只能到(n-y,y)；根据这些规律模拟出边界上各个顶点对应的路，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=<span class="number">8</span></span><br><span class="line">e=<span class="number">4</span></span><br><span class="line">x,y=<span class="number">5</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> y&gt;x:</span><br><span class="line">    x,y=y,x <span class="comment">#保证x&gt;y</span></span><br><span class="line"><span class="comment">#从路径来看，一个点要么没有路径，要么有1条路径，要么2条，没有其他情况；</span></span><br><span class="line"><span class="comment">#0条对应：(0,0) &amp; (x,y)</span></span><br><span class="line"><span class="comment">#1条：(x,0) &amp; (0,y)</span></span><br><span class="line"><span class="comment">#2条：(n,m) 0&lt;n&lt;x   0&lt;m&lt;y</span></span><br><span class="line">r=&#123;&#125;</span><br><span class="line">r[(<span class="number">0</span>,<span class="number">0</span>)]=[]</span><br><span class="line">r[(x,y)]=[]</span><br><span class="line">r[(x,<span class="number">0</span>)]=[(x-y,y)]</span><br><span class="line">r[(<span class="number">0</span>,y)]=[(y,<span class="number">0</span>)]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,x):</span><br><span class="line">    <span class="keyword">if</span> n&lt;y:</span><br><span class="line">        r[(n,<span class="number">0</span>)]=[(<span class="number">0</span>,n),(n,y)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r[(n,<span class="number">0</span>)]=[(n-y,y),(n,y)]</span><br><span class="line">    k=n+y</span><br><span class="line">    <span class="keyword">if</span> k&gt;x:</span><br><span class="line">        r[(n,y)]=[(n,<span class="number">0</span>),(x,n+y-x)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r[(n,y)]=[(n,<span class="number">0</span>),(n+y,<span class="number">0</span>)]</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,y):</span><br><span class="line">    <span class="comment">#m必然要小于x if m&lt;x:  不需要</span></span><br><span class="line">    r[(<span class="number">0</span>,m)]=[(m,<span class="number">0</span>),(x,m)]</span><br><span class="line">    r[(x,m)]=[(<span class="number">0</span>,m),(x+m-y,y)]</span><br></pre></td></tr></table></figure>



<p>我们就可以从一个点(5,0)出发，看具体的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w=[x,<span class="number">0</span>]  <span class="comment">#上一个点</span></span><br><span class="line">s=[x,<span class="number">0</span>]</span><br><span class="line">plst=[s] <span class="comment">#开始</span></span><br><span class="line"><span class="keyword">while</span> s[<span class="number">0</span>]!=e <span class="keyword">and</span> s[<span class="number">1</span>]!=e:</span><br><span class="line">    ss=(s[<span class="number">0</span>],s[<span class="number">1</span>])</span><br><span class="line">    sw=r[ss]</span><br><span class="line">    slen=<span class="built_in">len</span>(sw)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> slen==<span class="number">1</span>:</span><br><span class="line">        w=s.copy()</span><br><span class="line">        s[<span class="number">0</span>]=sw[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        s[<span class="number">1</span>]=sw[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> slen==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> sw[<span class="number">0</span>][<span class="number">0</span>]==w[<span class="number">0</span>] <span class="keyword">and</span> sw[<span class="number">0</span>][<span class="number">1</span>]==w[<span class="number">1</span>]:</span><br><span class="line">            w=s.copy()</span><br><span class="line">            s[<span class="number">0</span>]=sw[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">            s[<span class="number">1</span>]=sw[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> sw[<span class="number">1</span>][<span class="number">0</span>]==w[<span class="number">0</span>] <span class="keyword">and</span> sw[<span class="number">1</span>][<span class="number">1</span>]==w[<span class="number">1</span>]:</span><br><span class="line">            w=s.copy()</span><br><span class="line">            s[<span class="number">0</span>]=sw[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            s[<span class="number">1</span>]=sw[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(s,sw,slen)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(s,sw,slen)</span><br><span class="line">    plst.append(s)</span><br><span class="line"></span><br><span class="line">print(plst)</span><br></pre></td></tr></table></figure>

<p>当x=5，y=3时，以上代码输出<code>[[5,0], [2,3], [2,0], [0,2], [5,2], [4,3]]</code>，代表A，B两个酒缸之内各有多少酒。</p>
<h3 id="利用turtle可视化"><a href="#利用turtle可视化" class="headerlink" title="利用turtle可视化"></a>利用turtle可视化</h3><p>路径我们可以通过上面的代码算出来，从而得到这题的结果，但不够形象，我们通过Python的turtle库把这一过程画出来，turtle是Python内置的一个画图库，通过goto、left、right等命令控制一个小海龟（turtle）在画布（canvas）上爬行，从而得到各种图案，可以拿来绘制分形图案、小猪佩奇等。这次的模拟路径可视化也可以用pygame库。</p>
<p>正常的画布是一个直角坐标系，我们这里需要一个纵轴和横轴之间是60度的斜坐标系，因此通过以下函数转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawToXY</span>(<span class="params">x,y,turtle=turtle,sin=sin,pc=<span class="number">50</span></span>):</span> <span class="comment">#sin=sin(60°)=sqrt(3)/2; pc转换因子</span></span><br><span class="line">	turtle.goto(x*pc+<span class="number">0.5</span>*y*pc,pc*sin*y) <span class="comment">#直角坐标转斜坐标</span></span><br></pre></td></tr></table></figure>

<p>通过<code>drawToXY()</code>我们可以很方便地绘制出台球桌的外框：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawDiamond</span>(<span class="params">x,y,turtle=turtle,pc=pc,sin=sin</span>):</span>  <span class="comment">#画边界</span></span><br><span class="line">	turtle.pensize(<span class="number">3</span>) <span class="comment">#占3个像素的笔宽</span></span><br><span class="line">	drawToXY(x,<span class="number">0</span>,turtle,sin)</span><br><span class="line">	drawToXY(x,y,turtle,sin)</span><br><span class="line">	drawToXY(<span class="number">0</span>,y,turtle,sin)</span><br><span class="line">	drawToXY(<span class="number">0</span>,<span class="number">0</span>,turtle,sin)  <span class="comment">#外框</span></span><br><span class="line">	turtle.pensize(<span class="number">1</span>) <span class="comment">#默认笔宽</span></span><br></pre></td></tr></table></figure>

<p>绘制一个5 x 3的外框效果如下：</p>
<p><img src="/2019/09/09/wine-jar-solution-using-py-gui/wine-jar-su-04-001.png" alt="Screenshot from 2019-09-07 09-36-28"></p>
<p>绘制外框之后再加上内部点的连接，就像把一个(X,Y)的方格变形为菱形，并加上边界坐标，在turtle上写文本通过语句<code>turtle.write(txt, font=( &quot;微软雅黑&quot;, size, &quot;normal&quot;))</code>实现。</p>
<p><img src="/2019/09/09/wine-jar-solution-using-py-gui/wine-jar-su-05-0001.png" alt="添加可达路径和文本"></p>
<p>之后便可以绘制从(5,0)出发的球的路径了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawPlst</span>(<span class="params">plst,turtle=turtle,t2=t2</span>):</span></span><br><span class="line">	dt=<span class="number">25</span></span><br><span class="line">	dy=<span class="number">200</span></span><br><span class="line">	k=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> p <span class="keyword">in</span> plst:</span><br><span class="line">		drawText(-<span class="number">180</span>,dy-k*dt,<span class="built_in">str</span>(p),t2,size=<span class="number">14</span>) <span class="comment">#在另一侧写下经过的边界点</span></span><br><span class="line">		drawToXY(p[<span class="number">0</span>],p[<span class="number">1</span>],t1)</span><br><span class="line">		k+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawText</span>(<span class="params">x,y,txt,turtle=turtle,size=<span class="number">14</span></span>):</span></span><br><span class="line">	turtle.penup()</span><br><span class="line">	turtle.goto(x,y)</span><br><span class="line">	turtle.pendown()</span><br><span class="line">	turtle.write(txt, font=(<span class="string">&quot;微软雅黑&quot;</span>, size, <span class="string">&quot;normal&quot;</span>))</span><br><span class="line">plst=plst=[(<span class="number">5</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">3</span>)]</span><br><span class="line">t1.color(<span class="string">&quot;red&quot;</span>)</span><br><span class="line"><span class="comment">#t1.speed(2) #绘制速度，[0,10] 数值越大速度越快</span></span><br><span class="line">drawPlst(plst,t1,t2)</span><br></pre></td></tr></table></figure>

<p><img src="/2019/09/09/wine-jar-solution-using-py-gui/iowt9-ep92n-01.gif" alt="从(5,0)出发的球的路径"></p>
<p>从(0,3)出发的效果：</p>
<p><img src="/2019/09/09/wine-jar-solution-using-py-gui/iowt9-ep92n-02.gif" alt="从(0,3)出发的效果"></p>
<p>一个类似的题</p>
<blockquote>
<p>我们在河边分别有一个7升的水桶和5升的水桶，都没有刻度，如何用最少的次数装6升的水出来</p>
</blockquote>
<p>分析一下我们知道，最少次数的方式就是我们台球路径的做法，之前我们对酒缸C的处理和一条容量无限的河本质是一样的。</p>
<p>所以这题的解法用程序模拟效果如下图：</p>
<p><img src="/2019/09/09/wine-jar-solution-using-py-gui/wine-jar-su-08-001.PNG" alt="7x5升倒出6升"></p>
]]></content>
      <categories>
        <category>解题</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gui</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python时间处理模块的常用选择：八大模块，万字长文</title>
    <url>/2020/12/14/timeproc-pymodule-using.html</url>
    <content><![CDATA[<h2 id="时间数据"><a href="#时间数据" class="headerlink" title="时间数据"></a>时间数据</h2><p>时间格式是数据类型中基础也不容忽视的一类。不像整数那样大道至简也不像字符串那样包罗万象，却独有魅力，时间数据本身除了加减、比较运算外，也有下周、去年、时区等更专项的时间切换。在各类编程语言里都提供时间对象的支持，在MySQL里也有DATETIME类型。商业里的DAU、GMV、LTV也少不了时间限定和时间属性，因此数据分析时少不了对时间数据类型的处理与转换。<br>Python通过套件time、datetime、timeit处理时间类型数据，但面对一些情况时会不够灵活和易用，在时间序列生成和截断方面捉襟见肘，于是诞生了Arrow、Pendulum、Maya等库增强了Python的时间处理能力。本篇对4个标准库和6大第三方模块进行介绍，在面对需求时能拿到最趁手的工具。</p>
<p><img src="/2020/12/14/timeproc-pymodule-using/time-1209-1-overview-fishbonemap.PNG" alt="本文概览鱼骨图"></p>
<a id="more"></a>

<h2 id="模块概览"><a href="#模块概览" class="headerlink" title="模块概览"></a>模块概览</h2><p>在Python中进行时间类型数据处理能用到的模块有：</p>
<ul>
<li>time：Python内置时间库，通过时间戳或元组表示时间；</li>
<li>datetime：内置日期库，处理日期时间对象和属性；</li>
<li>dateutil：基于datetime库的实用拓展，增强了对时间间隔和时间序列的处理；</li>
<li>pd.Timestamp：pandas库用于时间处理的类；</li>
<li>Arrow：优秀的Python时间库，简化了时间类型数据的解析和输出；</li>
<li>Pendulum：可以和Arrow对标的时间处理库，pendulum意为钟摆；</li>
<li>Delorean：在dateutil基础上进一步拓展的时间库，以《回到未来》中的时间旅行车命名；</li>
<li>moment：灵感来源于Moment.js，目前相对原始；</li>
<li>Maya：和Arrow等库对标，增强了对时区的处理，有调用pendulum的部分功能；</li>
</ul>
<p>在深入这些库的使用之前，先补充一些先验知识：<br>epoch：时间基准点至特定时间的总秒数，一般用一个浮点数值记录，这个基准点在Unix及类Unix系统中是格林威治时间1970年01月01日00时0分0秒，因此也称为Unix时间戳(Timestamp)。因为地球是一个椭球体，当英国是中午时中国北京已经在吃晚饭了，不同经度地区的0点相对于格林威治的0点有一个时差，也就有时区(timezone)的区分，以UTC(世界协调时)作为基准，中国采用的东八区就可表示为UTC+8，对应北京时间减8个小时就是UTC时间。<br>基于以上需要考虑的问题，在时间类中，表示一个时间有两种基本选择：<br>一是用浮点数记录一个时间戳epoch，时间小于1970年则是负数，二是用元组或字典记录年月日时分秒时区等，在Python的time模块就是记录了epoch和一个元组叫struct_time，这两者之间可以互相转换。</p>
<h2 id="模块特性与实践"><a href="#模块特性与实践" class="headerlink" title="模块特性与实践"></a>模块特性与实践</h2><h3 id="time-amp-datetime"><a href="#time-amp-datetime" class="headerlink" title="time&amp;datetime"></a>time&amp;datetime</h3><p>time是Python内置的时间库，功能简约但实用，通常和同为内置库的datetime、pytz及calendar互相配合解决各类时间表示、计算、输出等需求。<br>time的常用方法有：</p>
<ul>
<li>time.time()：得到当前时间戳Timestamp，是一个浮点数；</li>
<li>time.localtime([secs])：将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准，相当于获取当前时间now()；</li>
<li>time.gmtime(ts)：时间戳转struct_time；struct_time是一个包含了9个元素的元组，对应着改时间对象的年月日、本年第几天等属性；</li>
<li>time.mktime(t)：struct_time转时间戳；</li>
<li>time.strftime(“%Y-%m-%d”,t)：struct_time转格式化字符串；</li>
<li>time.strptime(‘2020-12-7’,”%Y-%m-%d”)：字符串转struct_time；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.time() <span class="comment">#type(time.time())==float</span></span><br><span class="line"><span class="comment">#Out[]:1607319973.764</span></span><br><span class="line">time.localtime()</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=12, tm_mday=7, tm_hour=13, tm_min=46, tm_sec=13, tm_wday=0, tm_yday=342, tm_isdst=0)</span></span><br><span class="line">st=time.gmtime(time.time())</span><br><span class="line">st.tm_year <span class="comment">#获取属性，st是元组，不能修改</span></span><br><span class="line"><span class="comment"># 2020</span></span><br></pre></td></tr></table></figure>

<p>基于time模块生成的时间对象t，如果是时间戳形式表示的，是不能直接得到t是在哪一年等属性的，需要先转struct_time形式，然后就可以写st.tm_year获取所在年。st是元组，不能修改，即不能用st.tm_year=2019来修改的st的实际值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=time.strptime(<span class="string">&#x27;2020-12-7 13:52:15&#x27;</span>,<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=12,...)</span></span><br><span class="line">time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,t)</span><br><span class="line"><span class="comment"># 2020-12-7 13:52:15</span></span><br></pre></td></tr></table></figure>

<p>从文件中读取数据时常需要从字符串形式变成时间对象，就会用到str<strong>p</strong>time，是string parse time的简写，即从字符串数据类型中解析成时间类型。str<strong>f</strong>time是把时间类型格式化为字符串，是str<strong>p</strong>time的逆操作，f是format的缩写。<br>时间类型格式化有一套特定的占位符，下面介绍的符号在其他时间模块里也通用，因此常用的占位符还是需要心里有数才能灵活“组装”出自己需要的字符串效果的。下面表格列出了常用的时间格式化占位符，更全面的表可查阅<a href="https://docs.python.org/3/library/time.html">time模块文档</a>。</p>
<p><img src="/2020/12/14/timeproc-pymodule-using/time-1209-2-strftime-fmt.PNG" alt="常用时间格式化符号"></p>
<p>time模块常和datetime模块组合使用，time侧重在时间，datetime在日期方面方法更丰富，且datetime会和pytz及calendar配合处理时间对象。<br>在datetime里也有strftime和strptime，不过需要注意的是，两个库输入参数顺序的区别，datetime的strftime，格式化字符串在后，代码实例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">dt=datetime.strptime(<span class="string">&#x27;2020-12-7 13:52:15&#x27;</span>,<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">datetime.strftime(dt,<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) <span class="comment">#</span></span><br><span class="line"><span class="comment"># 2020-12-7 13:52:15</span></span><br><span class="line">time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,t)</span><br><span class="line"><span class="comment"># datetime库内部也是调用time的striptime</span></span><br><span class="line"><span class="comment"># datetime.strftime -&gt; _wrap_strftime -&gt;_time.strftime</span></span><br></pre></td></tr></table></figure>

<p>在datetime中新建时间对象可以直接使用<code>datetime(y, m,d,tzinfo)</code>输入参数，用<code>datetime.now()</code>获得当前时间，通过<code>datetime.fromtimestamp(ts)</code>可以将时间戳ts转为时间对象，生成的datetime时间对象在获取属性时用到的语句类似<code>dt.year</code>，有year/month/day/hour/second/tzinfo等可以用。tzinfo是时区属性，datetime在时区相关处理时通常用到pytz。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line">sh=pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>) <span class="comment">#新建一个时区</span></span><br><span class="line">dt=datetime(<span class="number">2020</span>,<span class="number">12</span>,<span class="number">7</span>,hour=<span class="number">8</span>,tzinfo=sh)</span><br><span class="line">datetime.fromtimestamp(time.time())</span><br><span class="line"><span class="comment">#datetime.datetime(2020,12,8,16,59,42,797401)</span></span><br><span class="line">dt.year <span class="comment">#返回给定datetime对象的年份</span></span><br><span class="line"><span class="comment">#Out[]: 2020</span></span><br><span class="line"><span class="comment">#属性有.hour .minute .second .microsecond 等</span></span><br><span class="line">datetime.weekday() <span class="comment">#返回星期几，星期一为 0，星期天为 6</span></span><br><span class="line"><span class="comment">#方法还有 .isoweekday() .toordinal() 等</span></span><br><span class="line">datetime.combine(dt.date(),dt.time()) </span><br><span class="line"><span class="comment">#combine：将一个date对象和一个time对象组合成一个datetime对象</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timezone <span class="comment">#如果不使用pytz库</span></span><br><span class="line">d1=datetime(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">21</span>,tzinfo=timezone(timedelta(hours=<span class="number">8</span>)))</span><br><span class="line">tdt=dt-d1</span><br><span class="line"><span class="comment"># datetime.timedelta(days=16)</span></span><br><span class="line">dt+timedelta(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>两个datetime日期相减得到的是一个时间间隔对象(imedelta)，timedelta可以和数值进行乘法和整除运算，两个timedelta对象之间可以进行加减运算，但不能比较大小，datetime对象可以和timedelta对象进行加减得到新的datetime实现时间偏移。<br>datetime也会和内置的calendar库进行配合，顾名思义，calendar库主要用来处理和输出整年、整月的日历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(calendar.calendar(<span class="number">2020</span>)) <span class="comment">#打印2020年日历</span></span><br><span class="line"><span class="comment">#calendar.prcal(2020) #两个语句效果相同</span></span><br><span class="line">calendar.prmonth(<span class="number">2019</span>,<span class="number">2</span>) <span class="comment">#打印2019年2月的日历</span></span><br><span class="line">calendar.isleap(<span class="number">2020</span>) <span class="comment">#是否闰年</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">calendar.weekday(<span class="number">2020</span>,<span class="number">11</span>,<span class="number">20</span>) <span class="comment">#指定日期为星期几，</span></span><br><span class="line"><span class="comment">#4 代表星期五</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/14/timeproc-pymodule-using/time-1209-4-1-calendar.PNG" alt="日历库calendar使用"></p>
<p>这几个库其他的实用方法有：</p>
<ul>
<li>time.sleep(secs)：线程推迟指定的时间运行，单位为秒；</li>
<li>time.asctime([t]) ：把一个表示时间的元组或者struct_time表示为这种形式：’Sun Jun 20 23:21:05 1993’，如没有参数，将会将time.localtime()作为参数传入；</li>
<li>time.ctime([secs])：把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()为参数。它的作用相当于time.asctime(time.localtime(secs))；</li>
<li>calendar.leapdays(n,m)：年份n到m之间的闰年数量；</li>
</ul>
<h3 id="dateutil"><a href="#dateutil" class="headerlink" title="dateutil"></a>dateutil</h3><p>dateutil模块是基于datetime库的实用拓展，增强了对时间间隔和时间序列的处理，因此dateutil类型直接继承了datetime类型，<a href="https://dateutil.readthedocs.io/en/stable/">dateutil库</a>生成的时间对象就是datetime。Anaconda下该库已经安装，模块里有parser、easter、relativedelta、rrule等实用类进行时间处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dateutil <span class="comment">#anaconda下已经安装，直接import</span></span><br><span class="line">dt=dateutil.parser.parse(<span class="string">&#x27;April 29 2020 14:20&#x27;</span>)</span><br><span class="line"><span class="comment">#可以从字符串解析，不需要手动写匹配的占位符。</span></span><br><span class="line">dt=dateutil.parser.parse(<span class="string">&#x27;April 29&#x27;</span>) <span class="comment">#会取当前年</span></span><br><span class="line"><span class="comment"># datetime.datetime(2020, 4, 29, 0, 0)</span></span><br><span class="line">dt=dateutil.parser.parse(<span class="string">&quot;Today is January 1, 2047 at 8:21:00AM&quot;</span>, fuzzy_with_tokens=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dateutil的parser类用于更方便地从字符串解析为datetime对象，<code>parser.parse(string)</code>可以从各种类型的字符串例如一句自然语言中解析出日期，但输入的参数string必须是字符串，输入时间戳不行（这个和下面提到的Arrow等库不同）。<br>因为解析为datetime类型的对象，所以可以使用datetime的各种方法和属性，例如需要知道是哪一年仍然使用<code>dt.year</code>获取。<br>一些datetime类的方法可以基于dt实例使用，要实现从时间戳转时间对象，就可以使用<code>dt.fromtimestamp(ts)</code>，获取当前时间，就可以使用<code>dt.now()</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt.fromtimestamp(dt.timestamp()) <span class="comment">#时间戳与时间对象互转</span></span><br><span class="line">dt.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="comment">#只能输入一个参数</span></span><br><span class="line"><span class="comment">#时间对象转字符串</span></span><br><span class="line">dateutil.easter.easter(<span class="number">2020</span>,method=<span class="number">3</span>) </span><br><span class="line"><span class="comment">#计算输入年份复活节的日期</span></span><br></pre></td></tr></table></figure>
<p>dateutil计算时间间隔的方法封装在relativedelta里，通过输入参数months等明确间隔的时间距离，tz用于处理时区。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt+dateutil.relativedelta.relativedelta(months=<span class="number">1</span>, weeks=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#时间偏移</span></span><br><span class="line"><span class="comment"># datetime.datetime(2021, 1, 14, 14, 15, 39, 173204)</span></span><br><span class="line">relativedelta(datetime(<span class="number">2003</span>, <span class="number">10</span>, <span class="number">24</span>, <span class="number">10</span>, <span class="number">0</span>),dt) <span class="comment">#得到一个时间间隔</span></span><br><span class="line">relativedelta(NOW, johnbirthday) <span class="comment">#得到一个人的年龄</span></span><br><span class="line"><span class="comment">#下周五对应的时间</span></span><br><span class="line">dt+relativedelta(weekday=FR)</span><br></pre></td></tr></table></figure>

<p>rrule类用于生成和处理一个时间序列。rrule的主要参数有：</p>
<ul>
<li>freq：声明序列重复的周期；</li>
<li>count：生成多少个时间对象；</li>
<li>dtstart：开始的时间点；<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(dateutil.rrule.rrule(freq=dateutil.rrule.MONTHLY, count=<span class="number">4</span>, dtstart=datetime(<span class="number">2020</span>, <span class="number">12</span>,<span class="number">7</span>)))</span><br><span class="line"><span class="comment"># [datetime.datetime(2020, 12, 7, 0, 0),datetime.datetime(2021, 1, 7, 0, 0),...]</span></span><br><span class="line"><span class="built_in">list</span>(dateutil.rrule.rrulestr(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    DTSTART:20201207T090000</span></span><br><span class="line"><span class="string">    RRULE:FREQ=DAILY;INTERVAL=10;COUNT=4</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>))</span><br><span class="line"><span class="comment">#效果同上，rrulestr是根据字符串规则生成时间序列</span></span><br></pre></td></tr></table></figure>
以上例子生成的是一个由4个时间对象组成的序列，开始时间是2020年12月7号，每月重复一条记录。rrule.rrulestr()是把字符串输入当参数。</li>
</ul>
<h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>实际在进行数据分析时，通常都会用到pandas库却不一定会导入datetime等库，而pandas模块也提供了Timestamp、Timedelta等类用于时间类型数据的处理转换。直接使用pd.Timestamp也更容易进行广播运算。</p>
<p>pandas的Timestamp对象用法和datetime库基本一致，各种<code>dt.year</code>属性都有，也有<code>dt.isleapyear</code>用于判断是否是闰年。pd.Timedelta对应datetime的timedelta，表示时间间隔。</p>
<p><img src="/2020/12/14/timeproc-pymodule-using/3-timestramp-03.PNG" alt="Timestamp常用方法"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;时间&#x27;</span>]=pd.to_datetime(df[<span class="string">&#x27;dt&#x27;</span>]) </span><br><span class="line">df[<span class="string">&#x27;years&#x27;</span>]=df[<span class="string">&#x27;时间&#x27;</span>].apply(<span class="keyword">lambda</span> x:x.year)</span><br><span class="line">sdf=df.loc[df[<span class="string">&#x27;years&#x27;</span>]==<span class="number">2018</span>]</span><br><span class="line">ddr=dd/(pd.Timestamp(<span class="string">&#x27;2018-12-31&#x27;</span>)-pd.Timestamp(<span class="string">&#x27;2018-1-1&#x27;</span>)).days </span><br><span class="line">df[<span class="string">&#x27;tfs&#x27;</span>]=df[<span class="string">&#x27;时间&#x27;</span>].apply(<span class="keyword">lambda</span> x:x.hour+x.minute/<span class="number">60</span>+x.second/<span class="number">3600</span>)</span><br></pre></td></tr></table></figure>

<p>前文《<a href="https://lynsdata.cn/2019/09/26/time-format-in-pandas.html">用pandas处理时间格式数据</a>》讲述了一个处理Excel文件中时间数据的案例。</p>
<h3 id="Arrow"><a href="#Arrow" class="headerlink" title="Arrow"></a>Arrow</h3><p>Arrow是一个优秀的Python时间处理库，现在其他有追求的第三方时间处理库都喜欢在文档里对标Arrow，足矣见Arrow的影响力。<a href="https://arrow.readthedocs.io/en/stable/">Arrow</a>通过收束接口增强了其易用性，可以快速上手使用，get统筹各种输入的解析，replace负责各种时间要素的修改，format解决各类格式化输出的需求，range处理时间序列生成问题。<br>Arrow解析字符串或datetime对象得到的是一个自定义时间对象，通过dt.time、dt.datetime、dt.timestamp等将时间数据从Arrow内置对象转为time等库的时间对象，一些例子如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> arrow <span class="comment">#在Anaconda下已经安装</span></span><br><span class="line">arrow.get(<span class="string">&#x27;2020-12-08 17:31:20&#x27;</span>) </span><br><span class="line"><span class="comment">#Out[]: &lt;Arrow [2020-12-08T17:31:20+00:00]&gt;</span></span><br><span class="line">dt=arrow.get(<span class="number">1607334506</span>) <span class="comment">#get可输入Unix时间戳，也可输入datetime对象</span></span><br><span class="line">dt.datetime <span class="comment">#转为dateime类型</span></span><br><span class="line">dt.naive <span class="comment">#转为当地时区的datetime类型</span></span><br><span class="line">dt.floor(<span class="string">&#x27;hour&#x27;</span>) <span class="comment">#从小时处截断，小时之后的数清零</span></span><br><span class="line">d1.replace(hour=<span class="number">3</span>)</span><br><span class="line">d1.shift(weeks=+<span class="number">4</span>) <span class="comment">#当前时间4周后</span></span><br><span class="line">d1.to(<span class="string">&#x27;Asia/Shanghai&#x27;</span>) <span class="comment">#换时区</span></span><br><span class="line">dt.<span class="built_in">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">#输出格式化字符串</span></span><br><span class="line">arrow.Arrow.<span class="built_in">range</span>(<span class="string">&#x27;hour&#x27;</span>,arrow.now(),arrow.now().shift(hours=<span class="number">5</span>))</span><br><span class="line"><span class="comment">#arrow生成时间序列</span></span><br><span class="line">dt.humanize() <span class="comment">#dt的自然语言表示</span></span><br></pre></td></tr></table></figure>

<p>Arrow的具体用法可参考前文《<a href="https://lynsdata.cn/2020/12/09/timeproc-arrow-lynsns.html">Python处理时间数据的另一种选择，在标准库之外|Arrow使用笔记</a>》。</p>
<h3 id="Pendulum"><a href="#Pendulum" class="headerlink" title="Pendulum"></a>Pendulum</h3><p>Pendulum也是一款很优秀的Python时间处理模块，其内置数据类型拓展自datetime，与datetime有着很好的兼容性。Pendulum比dateutil功能更丰富，足矣和Arrow对标。Arrow的易用性体现在接口简洁，Pendulum的易用性表现在很多datetime的方法都兼容，而且<a href="https://pendulum.eustace.io/">Pendulum</a>的文档页面也更美观漂亮。Pendulum[ˈpendʒələm]意为钟摆，是很好的时间意向。Pendulum通过其内置的DateTime对象实现和拓展datetime.datetime的功能，同时封装出Duration、Period及Timezones处理时间偏移、时区、时间序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pendulum</span><br><span class="line">dt=pendulum.now() <span class="comment">#获取本地时区的当前时间</span></span><br><span class="line"><span class="comment">#DateTime(2020,12,8,18,0,8,697484,tzinfo=Timezone(&#x27;Asia/Shanghai&#x27;))</span></span><br><span class="line">pendulum.tomorrow() <span class="comment">#明天的这个时候</span></span><br><span class="line">dt.year <span class="comment"># 2020</span></span><br><span class="line">dt.week_of_year <span class="comment">#dt所在周是本年第几周</span></span><br><span class="line">dt.age <span class="comment">#dt对应日期目前的年龄</span></span><br><span class="line">dt.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">d2=dt.<span class="built_in">set</span>(year=<span class="number">2019</span>) <span class="comment">#把年份变成2019</span></span><br><span class="line">dt.add(years=-<span class="number">1</span>) <span class="comment">#把时间变成1年前，注意是years不是year</span></span><br><span class="line">period = pendulum.period(dt, dt.add(days=<span class="number">8</span>))</span><br><span class="line"><span class="built_in">list</span>(period.<span class="built_in">range</span>(<span class="string">&#x27;days&#x27;</span>,<span class="number">2</span>)) <span class="comment">#时间序列</span></span><br></pre></td></tr></table></figure>

<p>其他的一些实用方法如下：</p>
<ul>
<li>pendulum.datetime(2020,5,7)：输入年月日等生成DateTime，对应着datetime.datetime()的写法;</li>
<li>pendulum.today()：获取当天时间， .tomorrow() .yesterday() 等可以用；</li>
<li>pendulum.local(args)：获取当地时间的对象，可以输入年月日等；</li>
<li>pendulum.parse(text)：从文本中解析出时间对象，有个类似的方法是pendulum.from_format(text,s)；</li>
<li>pendulum.from_timestamp(ts)：把时间戳ts转为时间对象；</li>
<li>dt.int_timestamp：把dt表示为整数的timestamp，对应的还有.float_timestamp；</li>
<li>pendulum.timezone(“Europe/Paris”)：生成一个时区对象；</li>
<li>d2.diff_for_humans(dt)：将时间间隔按自然语言输出；</li>
</ul>
<p>Pendulum的一些函数需要输入DateTime作为参数时，输入datetime对象也兼容，例如Period时期对象的start、end对象输入DateTime对象或datetime对象都可以，更详细的Pendulum特性可阅读《<a href="https://lynsdata.cn/2020/12/10/timeproc-pendulum-lynsns.html">挑战Arrow，需要怎样的实力？Pendulum使用笔记</a>》。</p>
<h3 id="Delorean"><a href="#Delorean" class="headerlink" title="Delorean"></a>Delorean</h3><p>dateutil库在datetime库基础上进行拓展，<a href="https://delorean.readthedocs.io/en/latest/">Delorean</a>站在dateutil的肩膀上进一步增强了时间处理能力，其接口更偏向面向对象的写法，时间戳使用epoch定义，其时间对象和datetime对象兼容性也很高，并且内置时间对象可以直接和datetime.timedelta进行运算。<br>Delorean是《回到未来》中的主角的时间旅行车，作为一个以epoch表示时间的程序库挺契合的。<br>Delorean抽象了多个接口用于解析和转换其他格式数据为时间对象，解析字符串用parse、处理时间戳用epoch、输入的是datetime对象直接用Delorean()。获取对象的年月日等属性，需转datetime再使用datetime的接口。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> delorean <span class="keyword">import</span> Delorean</span><br><span class="line">dt=Delorean() <span class="comment">#获取当前时间，相当于now</span></span><br><span class="line">dt=delorean.parse(<span class="string">&#x27;2020/12/07&#x27;</span>)</span><br><span class="line">dt.datetime.year <span class="comment">#获取年份</span></span><br><span class="line">dt.replace(hour=<span class="number">8</span>) <span class="comment">#改时间</span></span><br><span class="line">dt.shift(<span class="string">&#x27;US/Eastern&#x27;</span>) <span class="comment">#改时区</span></span><br><span class="line">dt - timedelta(hours=<span class="number">2</span>) <span class="comment">#两小时之前</span></span><br><span class="line"><span class="built_in">list</span>(delorean.stops(freq=delorean.DAILY,count=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>Delorean修改时间要素是用replace，而改时区是使用的shift。除了用stops生成时间序列外，还有range_daily()、range_hourly()等快速方法生成每天或每小时的时间序列。Delorean和datetime的协作很方便，但接口不够简洁和成体系，获取属性还需要转为datetime，显得常用的功能却没有优先封装，与Arrow、Pendulum等库还有些差距，是一个值得了解的Python时间库，详细了解其用法可看前文《<a href="https://lynsdata.cn/2020/12/11/timeproc-delorean-lynsns.html">设定基准点去时间旅行|Delorean使用笔记</a>》。</p>
<h3 id="moment"><a href="#moment" class="headerlink" title="moment"></a>moment</h3><p>和Arrow类似，moment也是灵感来自Moment.js库。moment是一个在发展中的库，基本功能不缺，但也不是很完善，其文档<a href="https://github.com/zachwill/moment"></a> 建议优先考虑Arrow及Pendulum库。<br>moment将数据的输入封装在moment.date里，在解析能力上，比Arrow的get更进一步，例如get传入tomorrow或者2 weeks ago是会报错的，这是arrow的get还不支持的写法，但moment.date可以解析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> moment</span><br><span class="line">moment.date(<span class="string">&#x27;2020-12-07 14:20:10&#x27;</span>)</span><br><span class="line"><span class="comment">#&lt;Moment(2020-12-07T14:20:10)&gt;</span></span><br><span class="line">moment.date(<span class="string">&quot;2 weeks ago&quot;</span>)</span><br><span class="line">dt=moment.date(<span class="string">&quot;December 18, 2020&quot;</span>)</span><br><span class="line">moment.unix(<span class="number">1355875153626</span>)</span><br><span class="line">dt.year <span class="comment">#获取dt所在年份</span></span><br></pre></td></tr></table></figure>

<p>moment的时间对象也是自定义的对象，获取其属性使用<code>dt.year</code>的写法，和其他库一致，进行时间偏移用的add和subtract方法，同时也有replace的接口，而且写<code>dt.replace(day=2)</code>或者<code>dt.replace(days=2)</code>都没出问题。输出格式化的字符串使用format。通过<code>dt.datetime</code>转为dateime类型，而输出时间戳是用<code>dt.epoch()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt=moment.now() <span class="comment">#还有utcnow()可以用</span></span><br><span class="line">dt.add(days=<span class="number">2</span>) <span class="comment">#.subtract()</span></span><br><span class="line">dt.replace(day=<span class="number">5</span>)</span><br><span class="line">dt.replace(days=<span class="number">5</span>)</span><br><span class="line">dt.<span class="built_in">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>)</span><br><span class="line">dt.datetime <span class="comment">#转datetime对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>moment目前的接口还是偏少，生成一个时间序列目前还不能实现。<br>使用moment时，一个小问题是用<code>pip install moment</code>可能会安装不上，需要通过<code>pip install moment --user</code> 去安装。</p>
<h3 id="Maya"><a href="#Maya" class="headerlink" title="Maya"></a>Maya</h3><p>Maya站在datetime、pendulum、snaptime等模块的肩膀上发展有一定特色的时间处理能力，<a href="https://github.com/timofurrer/maya">Maya</a>自定义对象MayaDT也是通过epoch定义时间，能很好地避免一些时区问题。<br>Maya的时间创建能力上排名前列，有丰富的接口用于从各种数据中解析出时间对象，when和parse可以从一些自然语言字符串中解析出时间要素，这方面和moment不遑多让，例如写<code>maya.when(&#39;tomorrow&#39;)</code>和<code>.when(&#39;2 weeks ago&#39;)</code>等；当然从time/datetime对象、时间戳转Maya对象也是没有压力。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> maya</span><br><span class="line">maya.when(<span class="string">&#x27;tomorrow&#x27;</span>) <span class="comment">#明天的这个时候,直接从自然语言转MayaDT</span></span><br><span class="line">maya.parse(<span class="string">&#x27;2020-12-08T03:15&#x27;</span>) <span class="comment">#字符串转maya时间对象</span></span><br><span class="line">dt=maya.now() <span class="comment">#获取当前时间</span></span><br><span class="line">maya.MayaDT.from_datetime(datetime.now()) <span class="comment">#datetime对象转MayaDT</span></span><br><span class="line">maya.MayaDT.from_struct(time.gmtime()) </span><br><span class="line">maya.MayaDT(<span class="number">1606533154</span>) <span class="comment">#时间戳转Maya时间对象</span></span><br><span class="line">dt.from_iso8601(text) <span class="comment">#从符合ISO-8601标准的字符串中解析时间</span></span><br></pre></td></tr></table></figure>

<p>在输出和转换方面，有<code>dt.datetime()</code>方法将MayaDT对象转为datetime对象，也能直接通过<code>dt.year</code>获取MayaDT对象的属性，有<code>dt.iso8601()</code>输出满足ISO-8601标准的时间字符串，和from_iso8601相对应。几个优秀库都有的输出为自然语言功能在Maya里封装为<code>dt.slang_time()</code>，并且还有slang_date也能使用，slang是俚语的意思。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dt=maya.when(<span class="string">&#x27;2020, 12, 7&#x27;</span>)</span><br><span class="line">dt.slang_time()</span><br><span class="line"><span class="comment"># &#x27;8 hours ago&#x27;</span></span><br><span class="line">dt.add(days=<span class="number">10</span>).slang_time()</span><br><span class="line"><span class="comment"># &#x27;in 1 week&#x27;</span></span><br><span class="line"><span class="built_in">list</span>(maya.intervals(start=maya.now(),</span><br><span class="line">                    end=maya.now().add(days=<span class="number">1</span>),</span><br><span class="line">					interval=<span class="number">60</span>*<span class="number">60</span>))</span><br><span class="line"><span class="comment">#生成start到end的每小时间隔的时间值序列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Maya的很多方法调用了其他时间库，例如dt.year等属性用了datetime库、snap方法是调用了snaptime库、parse和add用到了Pendulum库，很多需求Maya没有自己去造轮子，同时也显得依赖项有些多，要深入了解Maya的用法可以翻看前文《<a href="https://lynsdata.cn/2020/12/13/timeproc-maya-lynsns.html">博采众长穿梭时空|Maya库使用笔记</a>》。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在数据处理和数据分析过程中，主要需要解决的数据需求有以下几点：</p>
<ul>
<li>生成时间对象，从字符串或者写赋值语句得到一个时间对象；从内置的time/datetime对象转更容易处理的时间对象，如数据列是从Excel读入的，去解析该列为时间对象；</li>
<li>对特定时间对象t，获取年月日、分钟等时间要素；</li>
<li>时间运算；<ul>
<li>时间间隔Timedelta，两个时间对象相减；</li>
<li>一个时间对象+一个差值后得到新的时间对象，例如获取t一周后的时间t2,</li>
</ul>
</li>
<li>时间对象转为特定格式的字符串；</li>
<li>时间序列的整体移动与抽样；</li>
<li>非结构日期处理，从自然语言中解析时间；</li>
</ul>
<p>各个库解决该需求的方式总结如下表。</p>
<p><img src="/2020/12/14/timeproc-pymodule-using/time-1209-14-pv.PNG" alt="各时间库接口对照表"><br><img src="/2020/12/14/timeproc-pymodule-using/time-1209-15-pv.PNG" alt="各时间库接口对照表补充"></p>
<p>这几个库的使用笔记ipynb文件及xmind文件可在公众号后台回复 <strong>time</strong> 获取。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化技能之Matplotlib(下)|可视化系列02</title>
    <url>/2020/03/29/viz-matplotlib-advanced.html</url>
    <content><![CDATA[<blockquote>
<p>Matplotlib tries to make easy things easy and hard things possible.</p>
</blockquote>
<p>在本系列的<a href="http://lynsdata.cn/2020/04/20/viz-matplotlib-in-action">上篇文章</a>里，我们从Matplotlib的基础可视化框架开始，逐步画出折线图、柱状图等基础图表，通过对坐标轴标签、标题文本等的精细调节画出信息更明确丰富的可视图，也实践了双轴图及子图，最后看了下极坐标系下绘图的效果。本篇继续探索Matplotlib的强悍可视化能力。</p>
<h3 id="Matplotlib动态可视化"><a href="#Matplotlib动态可视化" class="headerlink" title="Matplotlib动态可视化"></a>Matplotlib动态可视化</h3><a id="more"></a>

<p>计算机及通信技术的发展极大丰富了多媒体内容的发展，文不如图、图不如动图；BI近些年也逐渐发展，人们已不满足于看静态的图表。短视频的火热也给了动态图更多的发展空间。动态图和交互图表能更生动地表现数据变化及数据联系，传达更多的信息。</p>
<h4 id="插入排序的动态展现"><a href="#插入排序的动态展现" class="headerlink" title="插入排序的动态展现"></a>插入排序的动态展现</h4><p>生动的动画有助于我们理解算法。通过Matplotlib其实我们也可以绘制动态的算法关键过程，下面拿插入排序作为例子看Matplotlib如何绘制动态图。</p>
<p>玩扑克时的抓牌环节很契合插入排序的执行过程。其思路是：保持手中的已有的牌始终有序，当抓到一张新牌时，<a href="%E7%AE%97%E6%B3%95%E6%96%B0%E8%A7%A3">按照牌面的点数，将其插入合适的位置</a>。怎么去判断该插入的位置呢？我们通常的做法就是从左到右或从右到左扫描以找到当前牌的位置，初始化时我们可以新建一个数组作为始终有序的结果集，也可以直接用原来的数组空间进行交换操作，整体时间复杂度是O(n^2)。将这一过程翻译为Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isort</span>(<span class="params">lst</span>):</span></span><br><span class="line">    n=<span class="built_in">len</span>(lst) <span class="comment">#直接用原数组进行排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        x=lst[i] <span class="comment">#当前值</span></span><br><span class="line">        j=i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> x&lt;lst[j]: <span class="comment">#从右往左找插入的位置</span></span><br><span class="line">            lst[j+<span class="number">1</span>]=lst[j] <span class="comment">#将比x大的牌往后移一位</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        lst[j+<span class="number">1</span>]=x <span class="comment">#换牌</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/29/viz-matplotlib-advanced/02-mat-101-%E6%AF%8F%E6%AC%A1%E6%8A%93%E7%89%8C%E6%97%B6%E5%88%A4%E6%96%AD%E6%96%B0%E7%89%8C%E7%9A%84%E5%90%88%E9%80%82%E4%BD%8D%E7%BD%AE.PNG" alt="每次抓牌时判断新牌的合适位置"></p>
<p>为了直观展示插入排序的关键步骤，我们将每做一次插入的结果保存下来然后用Matplotlib画成一系列柱状图。通过<code>matplotlib.animation</code>绘制成动态图。</p>
<p>首先改一下排序函数，增加一个变量保存每次到插入步骤时的数组，因为不是递归的排序代码，在for循环前用一个变量w保存关键结果，基于这些中间结果花一系列的图，再连成动态GIF图，代码如下，关键步骤都有注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isort</span>(<span class="params">lst</span>):</span> <span class="comment">#插入排序代码</span></span><br><span class="line">    n=<span class="built_in">len</span>(lst)</span><br><span class="line">    w=&#123;<span class="number">0</span>:&#123;<span class="string">&#x27;v&#x27;</span>:lst.copy(),<span class="string">&#x27;j&#x27;</span>:-<span class="number">1</span>&#125;&#125; <span class="comment">#保存j以确定到哪里插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        x=lst[i] <span class="comment">#当前值</span></span><br><span class="line">        j=i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> x&lt;lst[j]: <span class="comment">#x比j处值小时，继续向左</span></span><br><span class="line">            lst[j+<span class="number">1</span>]=lst[j] <span class="comment">#将比x大的牌往后移一位</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        lst[j+<span class="number">1</span>]=x <span class="comment">#换牌</span></span><br><span class="line">        w[i]=&#123;<span class="string">&#x27;v&#x27;</span>:lst.copy(),<span class="string">&#x27;j&#x27;</span>:j&#125;</span><br><span class="line">        <span class="comment">#print(xs,i,j,x)</span></span><br><span class="line">    <span class="keyword">return</span> w <span class="comment">#不需要lst</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> anm <span class="comment">#引入接口</span></span><br><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_bar</span>(<span class="params">i</span>):</span> <span class="comment">#每传入一个i画一个柱状图</span></span><br><span class="line">    w=wk[i]</span><br><span class="line">    nw=<span class="built_in">len</span>(w[<span class="string">&#x27;v&#x27;</span>])</span><br><span class="line">    ax.clear() <span class="comment">#清空之前画的元素</span></span><br><span class="line">    c1=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nw): <span class="comment">#调节柱的颜色</span></span><br><span class="line">        <span class="keyword">if</span> j&lt;i:</span><br><span class="line">            c1.append(<span class="string">&#x27;#1EAFAE&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> i==nw-<span class="number">1</span>:</span><br><span class="line">            c1.append(<span class="string">&#x27;#1EAFAE&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> j==i:</span><br><span class="line">            c1.append(<span class="string">&#x27;#BA5C25&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c1.append(<span class="string">&#x27;#69FFFF&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i!=nw-<span class="number">1</span> <span class="keyword">and</span> w[<span class="string">&#x27;j&#x27;</span>]+<span class="number">1</span>!=i: <span class="comment">#所交换的位置</span></span><br><span class="line">        c1[w[<span class="string">&#x27;j&#x27;</span>]+<span class="number">1</span>]=<span class="string">&#x27;#FFA069&#x27;</span></span><br><span class="line">    rs=ax.bar(<span class="built_in">range</span>(nw),w[<span class="string">&#x27;v&#x27;</span>],color=c1)</span><br><span class="line">    ax.set_ylim(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Insert Sorted Animation&#x27;</span>)</span><br><span class="line">    c=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> rs: <span class="comment">#给每个柱加文本标签</span></span><br><span class="line">        ax.annotate(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(w[<span class="string">&#x27;v&#x27;</span>][c]),xy=(r.get_x()+r.get_width()/<span class="number">2</span>,r.get_height()+<span class="number">0.1</span>))</span><br><span class="line">        c+=<span class="number">1</span> </span><br><span class="line"><span class="comment">#绘制动图</span></span><br><span class="line">amt=anm.FuncAnimation(fig,draw_bar,frames=<span class="built_in">range</span>(<span class="number">6</span>),interval=<span class="number">600</span>)</span><br><span class="line">amt.save(<span class="string">&#x27;insert-sorted-animation-1.gif&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>拿一个未排序数组进行测试，效果如下：</p>
<p>【排序过程GIF图 2】</p>
<p>排序过程动图。(青色表示已排序元素，淡蓝色表示未排序，枣红色柱表示当前需排序元素，插入到橙色柱位置)</p>
<p>Matplotlib绘制动态图表的思路是将一系列图按一定时间间隔顺序播放，利用眼睛的视觉暂留形成动态感，每张静态图就是一帧。上面的代码看上去有些长，但大部分语句用来调颜色和标签文本，画图部分仍然是熟悉的<code>fig,ax=plt.subplots()</code>建画布、<code>ax.bar()</code>画柱状图、<code>ax.set_title()</code>设置标题、<code>ax.annotate()</code>在每个柱的合适位置加文本标签。Matplotlib将动图相关的接口封装在<code>matplotlib.animation</code>里，<code>FuncAnimation(fig,func,frames)</code>通过重复调用func里的画图函数在fig上形成动图。FuncAnimation的参数如下：</p>
<ul>
<li><code>fig</code>：用来生成动画的画布；</li>
<li><code>func</code>：通过调用matplotlib绘图方法来出图作为动图的每一帧；</li>
<li><code>frames</code>：一个迭代对象，会将其中每一个元素作为绘制一帧的参数传入func函数；</li>
<li><code>interval</code>：每一帧的展示时间，默认200，单位是毫秒，也就是200毫秒跳到下一张图；</li>
</ul>
<p>要将动图保存到文件通过<code>.save(fname)</code>实现，另外也可以用<code>.to_html5_video()</code>把动画转为HTML5下video标签支持的数据或用<code>.to_jshtml</code>生成HTML表示的动画数据，例如在jupyter notebook环境中，可以用以下语句直接渲染出带播放控制台的动图。</p>
<p>【带控制台的动图播放，3】</p>
<h4 id="动态排序图实践"><a href="#动态排序图实践" class="headerlink" title="动态排序图实践"></a>动态排序图实践</h4><p>学动态图绘制不应该错过一直挺热门的动态排序图（Bar Chart Race）。通过一系列的条形图营造出你追我赶的热闹场面，看尽事件的变迁。特别适合的应用场景是各种排名的变化，如城市排名变化、某些主题搜索指数变化、××沉浮史等。把这类图拆解一下看到的是一系列条形图和条柱之间的交换动态效果。有了上面的插入排序做热身，同样可以通过绘制一系列条形图再调用<code>FuncAnimation(fig,func,frames)</code>得到动态排序图。网上可以找到各种年度季度排名的公开数据集，一些讲动态排序图的教程也给出了数据集。为了再降低数据获取门槛，我们直接随机生成简单的排名数据。</p>
<p>【几种有代表性的排序数据表 null 太难整理的，费时】</p>
<p>【其中的一种数据组织形式df 4】</p>
<p>假设我们有如下的数据表df，表示7位用户A～G各自在3月到12月的消费金额。现在要画出从3月到12月用户消费金额的排名变化。color列用来给各自标识颜色，画条形图和画制作动图所用接口和参数前面都讲过（包括上篇文章），直接用<code>ax.barh(y,width,color)</code>和<code>FuncAnimation(fig,func,frames)</code>来绘制，条形图是从下往上画的，因此正序排序后正好是最高的柱在最上面，不需要额外调转，具体代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">race_bar</span>(<span class="params">i</span>):</span></span><br><span class="line">    idx=<span class="built_in">str</span>(i)</span><br><span class="line">    wdf=df.sort_values(by=idx)</span><br><span class="line">    width=<span class="built_in">list</span>(wdf[idx])</span><br><span class="line">    yw=<span class="built_in">list</span>(wdf[<span class="string">&#x27;tag&#x27;</span>])</span><br><span class="line">    ax.clear()</span><br><span class="line">    rs=ax.barh(yw,width,color=wdf[<span class="string">&#x27;color&#x27;</span>])</span><br><span class="line">    ax.set_xlim(<span class="number">0</span>,wdf[idx].<span class="built_in">max</span>()+<span class="number">200</span>)</span><br><span class="line">    ax.set_title(<span class="string">&#x27;A to G Animation&#x27;</span>)</span><br><span class="line">    ax.text(wdf[idx].<span class="built_in">max</span>()+<span class="number">20</span>,<span class="number">1</span>,<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(i),fontsize=<span class="number">30</span>) <span class="comment">#绘制当前条形图对应时间周期</span></span><br><span class="line">    ax.tick_params(top=<span class="literal">True</span>, bottom=<span class="literal">False</span>,</span><br><span class="line">                   labeltop=<span class="literal">True</span>, labelbottom=<span class="literal">False</span>)</span><br><span class="line">    c=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> rs:</span><br><span class="line">        ax.annotate(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(yw[c]),xy=(r.get_width()-<span class="number">40</span>,r.get_y()+r.get_height()/<span class="number">2</span>-<span class="number">0.16</span>))</span><br><span class="line">        ax.annotate(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(width[c]),xy=(r.get_width()+<span class="number">5</span>,r.get_y()+r.get_height()/<span class="number">2</span>-<span class="number">0.16</span>))</span><br><span class="line">        c+=<span class="number">1</span></span><br><span class="line">amt=anm.FuncAnimation(fig,race_bar,frames=<span class="built_in">range</span>(<span class="number">3</span>,<span class="number">13</span>),interval=<span class="number">600</span>)</span><br><span class="line"><span class="comment">#整体结构和插入排序一脉相承</span></span><br></pre></td></tr></table></figure>

<p>绘制效果如图：</p>
<p>【排序图 6】</p>
<p><em>注</em>：为了更好地获得具有你追我赶、一同向前的效果，且防止数据变化太过跳脱，防止出现前一秒还是第一、突然掉到最后一名的剧烈变动情况，生成df时，不是全部使用随机函数生成随机数，此处使用的方法是第一次随机生成数据，下一帧的数据在当前数据基础上加[-50,100]的值，本处设定是当前数x[i]是偶数时，x[i+1]=x[i]+randint(20,200)，奇数时x[i+1]=x+randint(-30,100)。生成数据集的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df=pd.DataFrame(&#123;<span class="string">&#x27;tag&#x27;</span>:<span class="built_in">list</span>(<span class="string">&#x27;ABCDEFG&#x27;</span>),<span class="string">&#x27;color&#x27;</span>:[<span class="string">&#x27;#1EAFAE&#x27;</span>, <span class="string">&#x27;#A3FFFF&#x27;</span>, <span class="string">&#x27;#69FFFF&#x27;</span>, <span class="string">&#x27;#BA5C25&#x27;</span>, <span class="string">&#x27;#FFA069&#x27;</span>, <span class="string">&#x27;#9E5B3A&#x27;</span>, <span class="string">&#x27;#D7CE88&#x27;</span>]&#125;)</span><br><span class="line">df[<span class="string">&#x27;3&#x27;</span>]=df[<span class="string">&#x27;tag&#x27;</span>].apply(<span class="keyword">lambda</span> x:random.randint(<span class="number">50</span>,<span class="number">600</span>)) <span class="comment">#初始列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,<span class="number">13</span>):</span><br><span class="line">    idx=<span class="built_in">str</span>(i-<span class="number">1</span>) <span class="comment">#偶数增幅，奇数在原来基础上[-30,50+5*i]变动</span></span><br><span class="line">    df[<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(i)]=df[idx].apply(<span class="keyword">lambda</span> x:x+random.randint(<span class="number">20</span>,<span class="number">100</span>+i*<span class="number">6</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> x+random.randint(-<span class="number">30</span>,<span class="number">50</span>+i*<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h4 id="动态折线图"><a href="#动态折线图" class="headerlink" title="动态折线图"></a>动态折线图</h4><p>换一种图表类型也不难。最近动态折线图也很火。因为df也具有时间属性，这次只用A、B、C三行的数据绘制动态折线图，改一下数据处理并将<code>ax.bar()</code>换成<code>ax.plot</code>，成果如图。</p>
<p>【图 7】</p>
<p>绘制代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax=plt.subplots()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">race_line</span>(<span class="params">i</span>):</span></span><br><span class="line">    k=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>] <span class="comment">#只取3个人的数据</span></span><br><span class="line">    x=<span class="built_in">range</span>(<span class="number">3</span>,i+<span class="number">1</span>)</span><br><span class="line">    ax.clear()</span><br><span class="line">    <span class="keyword">for</span> ki <span class="keyword">in</span> k:</span><br><span class="line">        wdf=df.loc[df[<span class="string">&#x27;tag&#x27;</span>]==ki]</span><br><span class="line">        <span class="comment">#筛选出画折线的x，y</span></span><br><span class="line">        y=[<span class="built_in">list</span>(wdf.loc[wdf[<span class="string">&#x27;tag&#x27;</span>]==ki][<span class="built_in">str</span>(j)])[<span class="number">0</span>] <span class="keyword">for</span> j <span class="keyword">in</span> x]</span><br><span class="line">        ax.plot(x,y,color=<span class="built_in">list</span>(wdf[<span class="string">&#x27;color&#x27;</span>])[<span class="number">0</span>])</span><br><span class="line">        ax.text(i+<span class="number">0.2</span>,y[-<span class="number">1</span>]+<span class="number">2</span>,<span class="string">&#x27;&#123;0&#125;:&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(ki,y[-<span class="number">1</span>]))</span><br><span class="line">        ax.set_xlim(<span class="number">3</span>,i+<span class="number">3</span>)</span><br><span class="line">    ax.set_title(<span class="string">&#x27;ABC Lines Animation&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    ax.tick_params(top=<span class="literal">True</span>, bottom=<span class="literal">False</span>,left=<span class="literal">False</span>,right=<span class="literal">True</span>,</span><br><span class="line">                   labelright=<span class="literal">True</span>,labelleft=<span class="literal">False</span>,</span><br><span class="line">                   labeltop=<span class="literal">True</span>, labelbottom=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">amt=anm.FuncAnimation(fig,race_line,frames=<span class="built_in">range</span>(<span class="number">6</span>,<span class="number">13</span>),interval=<span class="number">500</span>)</span><br><span class="line">amt.save(<span class="string">&#x27;lines-animation-1.gif&#x27;</span>) <span class="comment">#把动图保存为gif文件</span></span><br></pre></td></tr></table></figure>

<p>绘制三维动态图也是同样的套路，建画布时加上<code>projection=&quot;3d&quot;</code>参数，绘图时参数从[x,y]变成[x,y,z]，其他按框架来做。</p>
<h3 id="形状绘制深入"><a href="#形状绘制深入" class="headerlink" title="形状绘制深入"></a>形状绘制深入</h3><p>在上篇的<strong>图表元素调校</strong>部分简单提到了在画布上加椭圆、矩形的代码，这里再细化一下Matplotlib可以绘制的形状。整理如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绘制基本形状的框架，以圆形为例</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> mpatches</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> PatchCollection</span><br><span class="line">fig, ax = plt.subplots(subplot_kw=<span class="built_in">dict</span>(aspect=<span class="string">&quot;equal&quot;</span>)) <span class="comment">#设置横纵坐标单位长度一致，也可写 plt.axis(&#x27;equal&#x27;)</span></span><br><span class="line"></span><br><span class="line">patches = [] <span class="comment">#需渲染的形状集合</span></span><br><span class="line"></span><br><span class="line">circle = mpatches.Circle((<span class="number">50</span>,<span class="number">50</span>),<span class="number">20</span>) <span class="comment">#初始化一个圆心在(50,50)，半径为20的圆形</span></span><br><span class="line">patches.append(circle)</span><br><span class="line"></span><br><span class="line">pcc= PatchCollection(patches,color=<span class="string">&quot;#69FFFF&quot;</span>) <span class="comment">#因patches整合到了PatchCollection对象里,在Circle里写颜色参数好像没用，需要把color传到这里</span></span><br><span class="line">ax.add_collection(pcc)</span><br><span class="line">ax.set_ylim(<span class="number">0</span>,<span class="number">100</span>) <span class="comment">#设置x，y的展示范围</span></span><br><span class="line">ax.set_xlim(<span class="number">0</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li><p><code>.Circle(xy,radius,**kwargs)</code>: 绘制一个圆形，第一个参数是圆心坐标，可以传数组或元组，x、y不是单独传的；radius是圆的半径；后续的参数有图形标签(label)、线风格(linestyle)、圆边框宽度(linewidth)、图层顺序(zorder)等；</p>
</li>
<li><p><code>.Ellipse(xy,width,height,angle,**kwargs)</code>: 以xy为圆心绘制一个椭圆。Circle()的第二个参数是半径，椭圆需要长轴长度和短轴长度，也就是width和height，angle控制旋转角度，逆时针，按度计算，例如angle=90时，原来一个扁的椭圆就变成了长的椭圆，转了90度；其他参数和Circle()基本一致，下面也不再重复。</p>
</li>
<li><p><code>.Wedge(center, r, theta1, theta2, width, **kwargs)</code>: 楔形，像劈掉一部分的圆，是饼图的那一块块饼，可以猜测用<code>pie()</code>绘制饼图时调用了Wedge；center对应圆的xy，即圆心坐标；r是半径，只绘制从theta1到theta2之间的圆形，交换t1和t2可以得到饼的另一个部分，width默认是None，当设置了width会从r-width的部分开始画，得到环状图；</p>
</li>
<li><p><code>.Rectangle(xy,width,height,angle=,**kwargs)</code>: 和椭圆的参数写法惊人一致，不同之处在于矩形的xy是左下角坐标而不是中心的坐标；</p>
</li>
<li><p><code>.RegularPolygon(xy,numVertices,radius,orientation,**kwargs)</code>: 绘制正多边形xy是图形的中心点，numVertices是顶点个数，如numVertices=5是正五边形；radius：从图形中心xy到顶点的距离；orientation：旋转的度数，是弧度制；</p>
</li>
<li><p><code>.Arrow(x,y,dx,dy, width, **kwargs)</code>: 绘制一个箭头，x：箭头尾部的x坐标，y：箭头尾部的y坐标；dx：箭头指向位置距离x的长度，dy同理，width是箭头的宽度，默认值是1，当形状用一般设置得大一些。另外还有hatch参数可以设置箭头的底纹效果；</p>
</li>
<li><p><code>.PathPatch(path, **kwargs)</code>: 绘制一系列坐标构成的路径，是非常强大的接口，绘制各种不规则的形状、图标、贝塞尔曲线等一般都直接用Path的接口，和Canvas本身path对象的规则基本一致，东西比较多，不好展开；</p>
</li>
<li><p><code>.FancyBboxPatch(xy,width,boxstyle=&#39;round&#39;,**kwargs)</code>: 边框效果更个性化的图形，前面3个参数就是矩形的参数，boxstyle控制绘制各种效果，boxstyle支持的有circle(圆边)、round(边缘钝化的矩形)、square(方边)、sawtooth(锯齿边)等。下面的整理更形象。</p>
</li>
</ul>
<p>【图，更好地解释代码对应画的图形  常用绘制形状及参数 8】</p>
<p>基于上面的形状，这里复现一下绘制经典的数据科学维恩图。</p>
<p>画维恩图只需要<code>Circle(xy,r)</code>就够了，因patches整合到了PatchCollection对象里，在Circle里写颜色参数似乎没用，就把color从PatchCollection传入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绘制基本形状的框架，以圆形为例</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> mpatches</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> PatchCollection</span><br><span class="line">fig, ax = plt.subplots(subplot_kw=<span class="built_in">dict</span>(aspect=<span class="string">&quot;equal&quot;</span>)) <span class="comment">#设置横纵坐标单位长度一致，也可写 plt.axis(&#x27;equal&#x27;)</span></span><br><span class="line"></span><br><span class="line">patches = [] <span class="comment">#需渲染的形状集合</span></span><br><span class="line"></span><br><span class="line">circle = mpatches.Circle((<span class="number">50</span>,<span class="number">50</span>),<span class="number">20</span>) <span class="comment">#初始化一个圆心在(50,50)，半径为20的圆形</span></span><br><span class="line">patches.append(circle)</span><br><span class="line"></span><br><span class="line">pcc= PatchCollection(patches,color=<span class="string">&quot;#69FFFF&quot;</span>) <span class="comment">#因patches整合到了PatchCollection对象里,在Circle里写颜色参数好像没用，需要把color传到这里</span></span><br><span class="line">ax.add_collection(pcc)</span><br><span class="line">ax.set_ylim(<span class="number">0</span>,<span class="number">100</span>) <span class="comment">#设置x，y的展示范围</span></span><br><span class="line">ax.set_xlim(<span class="number">0</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>



<p>【数据科学经典维恩图 9】</p>
<p>另外一种画多个圆的方法是用<code>ax.add_artist(ada)</code>，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.axes_grid1.anchored_artists <span class="keyword">import</span> AnchoredDrawingArea</span><br><span class="line">p1 = mpatches.Circle((<span class="number">15</span>, <span class="number">85</span>), <span class="number">78</span>,fc=<span class="string">&#x27;#1EAFAE&#x27;</span>,alpha=<span class="number">0.62</span>) <span class="comment">#(x,y),r,fcolor,alpha</span></span><br><span class="line">ada = AnchoredDrawingArea(<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>, <span class="number">0</span>,loc=<span class="number">10</span>, pad=<span class="number">0.</span>, frameon=<span class="literal">False</span>) <span class="comment">#width( in pixels), height, xdescent, ydescent, loc, pad=0.4,</span></span><br><span class="line">ada.drawing_area.add_artist(p1)</span><br><span class="line">ax.add_artist(ada)</span><br></pre></td></tr></table></figure>



<p>在<code>matplotlib.image</code>的接口中有图像的读取接口，<code>ax.imshow(mpimg.imread(&#39;imagename.png&#39;))</code>可以读取图片并显示，因此Matplotlib即能画饼柱折点等图形，也能画更底层的线段、楔形、多边形，还能读取图片进行处理。常用需求有给图片加文本水印、给图形加图片（如画各国动态排序柱图时给对应柱画上国旗）、用形状裁剪图片等；</p>
<h3 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h3><p><code>plt.subplot()</code>其中有一个参数是projection，表示所使用的坐标系统，之前画三维图的时候用到<code>projection=&#39;3d&#39;</code>，画心脏线函数的时候用到了<code>projection=&#39;polar&#39;</code>，再来细化一下极坐标下的绘图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#极坐标系下的可视化和直角坐标没多少改变</span></span><br><span class="line">ax=plt.subplot(<span class="number">111</span>,projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line">x=[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">ax.plot(x)</span><br></pre></td></tr></table></figure>

<p><code>pyplot.subplot</code>支持的坐标系统有’rectilinear’、’polar’、’lambert’、’hammer’、 ‘mollweide’、’aitoff’<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html#matplotlib.pyplot.subplot">等 看有哪些坐标系统</a>，主要在3d绘图、极坐标绘图、地图投影等场景下使用。正如rectilinear直角坐标系下确定一个位置用[x,y]，在极坐标系下定位一个位置通过[theta,r]，theta表示正方向旋转的弧度，r表示距离原点的直线距离(也称r轴为极径)。</p>
<p>【直角坐标与极坐标的对比】</p>
<p>极坐标系可视化有一些基本的属性可以设置。</p>
<ul>
<li><code>ax.set_theta_direction(-1)</code>: 设置极坐标角度的正方向，默认值是1，表示逆时针方向，设置为-1时是顺时针方向；</li>
<li><code>ax.set_theta_zero_location(loc,offset=0)</code>: 设置极坐标洗0°的位置，默认是loc是’E’，表示正东方向，loc有八种选择：(“N”, “NW”, “W”, “SW”, “S”, “SE”, “E”, “NE”)，offset表示在loc的基础上按照正方形偏移多少度数；</li>
<li><code>ax.set_thetagrids(angles,labels,fmt)</code>:设置极坐标角度网格线上标签的显示，labels是要显示的标签，angles是标签所在对应的角度（注意不是弧度），angles值的范围应该取[0,360]， 默认显示0°、45°、90°、135°、180°、225°、270°、315°的网格线。类似于直角坐标系下的<code>ax.set_xticklabels(df[&#39;x&#39;])</code>；</li>
<li><code>ax.set_rgrids(radii,labels)</code>: 设置极径网格线和标签显示，和上面<code>ax.set_thetagrids</code>效果对应；</li>
<li><code>ax.set_rlabel_position(value)</code>: 设置极径标签显示位置，value为标签所要显示在的角度；</li>
<li><code>ax.set_rlim(0,30)</code>: 设置极径显示范围，对应直角坐标下的<code>set_ylim(0,30)</code>；</li>
<li><code>ax.set_rscale()</code>: 设置极径方向所用的比例尺，默认是’linear’表示是线性变化，可以设置为’log’得到对数比例尺；</li>
</ul>
<p>很多我们常见的图将其转到极坐标系下会有惊艳的效果，例如饼图可以认为是极坐标系下的柱状图，将柱的高度映射为楔形的弧度；玫瑰图可以是极坐标系下的堆积柱状图，柱的高度映射为r及弧度theta的占比；雷达图可以是极坐标系下的折线图。</p>
<p>【几种图的变换】</p>
<p>我们用极坐标绘制南丁格尔玫瑰图的时候，可以再次复习柱状图bar的参数，代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y=[<span class="number">42</span>, <span class="number">142</span>, <span class="number">61</span>, <span class="number">119</span>, <span class="number">68</span>]</span><br><span class="line">z=[<span class="number">77</span>, <span class="number">46</span>, <span class="number">65</span>, <span class="number">81</span>, <span class="number">50</span>]</span><br><span class="line">ax=plt.subplot(<span class="number">111</span>, projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line"><span class="comment">#对y和z进行一些运算以适应弧度制</span></span><br><span class="line">yw=[i*<span class="number">2</span>*<span class="number">3.1416</span>/<span class="built_in">sum</span>(y) <span class="keyword">for</span> i <span class="keyword">in</span> y]</span><br><span class="line">xw=[<span class="built_in">sum</span>(y[<span class="number">0</span>:i])*<span class="number">2</span>*<span class="number">3.1416</span>/<span class="built_in">sum</span>(y) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y))]</span><br><span class="line">yzw=[i*<span class="number">2</span>*<span class="number">3.1416</span>/<span class="built_in">sum</span>(z) <span class="keyword">for</span> i <span class="keyword">in</span> z]</span><br><span class="line">zw=[<span class="built_in">sum</span>(z[<span class="number">0</span>:i])*<span class="number">2</span>*<span class="number">3.1416</span>/<span class="built_in">sum</span>(z) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(z))]</span><br><span class="line">ax.bar(xw,y,width=yw,align=<span class="string">&#x27;edge&#x27;</span>,linewidth=<span class="number">1</span>,edgecolor=<span class="string">&#x27;k&#x27;</span>) <span class="comment">#设置x对应柱的边缘开始画而不是中心了</span></span><br><span class="line">ax.bar(xw,y,width=yw,bottom=y,align=<span class="string">&#x27;edge&#x27;</span>,linewidth=<span class="number">1</span>,edgecolor=<span class="string">&#x27;k&#x27;</span>) <span class="comment">#设置柱的边缘颜色以区分各个饼</span></span><br></pre></td></tr></table></figure>





<p>【南丁格尔玫瑰图绘制结果】</p>
<p>转换的过程需要对数据进行换算，这算一个Matplotlib不够智能的设置，不能直接通过换坐标系统的语句实现数据的一个换算，例如将原先的x轴自动换算到[0,2pi]绘制美观的图表，针对这种换坐标系实现堆积的方法，基于属性映射的可视化语法，会将换算细节封装好，能直接使用出图。</p>
<h3 id="Matplotlib简单交互"><a href="#Matplotlib简单交互" class="headerlink" title="Matplotlib简单交互"></a>Matplotlib简单交互</h3><p>Matplotlib画静态图非常专业，同时它也能通过事件监听实现基础的交互功能。Matplotlib通过<code>plt.connect(s, func)</code>实现对鼠标和键盘等事件的监听，s表示plt会关联的事件，如s=’button_press_event’表示按下鼠标时会出发func函数，在func里写入触发事件后的处理逻辑，<a href="*https://matplotlib.org/users/event_handling.html*">相应事件</a>还有：{‘key_press_event’:’按下按键’,’key_release_event’:’松开按键’,’resize_event’:’改变窗体大小’,’close_event’:’关闭窗体’}等。官网给了两个例子分别表示按下按钮时print相应的坐标以及按键时触发保存图片等交互。基于Matplotlib的接口要实现流畅复杂的交互代码会很复杂。</p>
<p>自己简单实现了一下当鼠标点击到柱状图的柱子上时会高亮当前柱并显示当前柱对应的值。效果如下：</p>
<p>【图】</p>
<p>具体代码如下，jupyter notebook环境似乎不支持Matplotlib的交互操作，需依赖GUI环境，因此运行结果是通过脚本运行得到的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.backend_bases <span class="keyword">import</span> MouseButton</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">xw=<span class="built_in">list</span>(<span class="string">&#x27;ABCDE&#x27;</span>)</span><br><span class="line">yw=[<span class="number">42</span>, <span class="number">142</span>, <span class="number">61</span>, <span class="number">119</span>, <span class="number">68</span>]</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">rs=ax.bar(xw,yw,color=<span class="string">&#x27;#1EAFAE&#x27;</span>) <span class="comment">#绘制初始的条形图</span></span><br><span class="line">ax.set_title(<span class="string">&#x27;plt.connect demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_click_bar</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="keyword">if</span> event.button <span class="keyword">is</span> MouseButton.LEFT:</span><br><span class="line">        x, y = event.xdata, event.ydata</span><br><span class="line">        print(<span class="string">&#x27;w&#x27;</span>,x,y)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rs)):</span><br><span class="line">            <span class="keyword">if</span> x&gt;rs[r].get_x() <span class="keyword">and</span> x&lt;rs[r].get_x()+rs[r].get_width() <span class="keyword">and</span> y&lt;rs[r].get_height():</span><br><span class="line">                print(<span class="string">&#x27;q&#x27;</span>,x,y)</span><br><span class="line">                ax.clear()</span><br><span class="line">                c=[<span class="string">&#x27;#BA5C25&#x27;</span> <span class="keyword">if</span> i==r <span class="keyword">else</span> <span class="string">&#x27;#1EAFAE&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rs))]</span><br><span class="line">                ax.bar(xw,yw,color=c)</span><br><span class="line">                ax.text(x,y,<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(rs[r].get_height()))</span><br><span class="line">                ax.set_title(<span class="string">&#x27;plt.connect demo&#x27;</span>)</span><br><span class="line">        fig.canvas.draw_idle() <span class="comment">#刷新当前画布</span></span><br><span class="line"></span><br><span class="line">plt.connect(<span class="string">&#x27;button_press_event&#x27;</span>, on_click_bar) <span class="comment">#监听</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>关于Matplotlib库，还可以深入的有：</p>
<ul>
<li>图形的布尔运算、Path的具体规则等；</li>
<li>渐变的颜色调节；</li>
<li>地图投影及basemap的使用；</li>
<li>根据三维数据绘制等高线<code>ax.contour(X, Y, Z,levels)</code>；</li>
</ul>
<p>Matplotlib的各模块内容细化拆解会有非常多的内容，市面上有挺多专门讲mat可视化的厚书，如果只考虑快速使用和了解几大模块的话，Matplotlib的精要内容是可以15分钟学会的，个人认为在知道了基本可视化框架后，了解折线图。柱状图、饼图、直方图等的绘制方法和基本参数，再学会添加文本、调节坐标轴，会通过双坐标轴和子图画多张图，最后了解下动态图和事件监听做基础交互。其他内容和细节通过需求驱动深入学。</p>
<p><strong>参考资料</strong></p>
<ul>
<li>刘新宇.算法新解[M].人民邮电出版社,2017:19.</li>
</ul>
<p>各种可绘制的形状整理：<a href="https://matplotlib.org/gallery/shapes_and_collections/artist_reference.html#sphx-glr-gallery-shapes-and-collections-artist-reference-py">https://matplotlib.org/gallery/shapes_and_collections/artist_reference.html#sphx-glr-gallery-shapes-and-collections-artist-reference-py</a></p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>viz</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化技能之Matplotlib(上)|可视化系列01</title>
    <url>/2020/03/27/viz-matplotlib-in-action.html</url>
    <content><![CDATA[<p>Matplotlib可以说是Python最声名远扬的可视化库了，也是Python数据分析库的“三驾马车”之一。Matplotlib是基础而非常强大的可视化库，Seaborn等好用的可视化库是在前者的基础上进行的封装。Matplotlib擅长快速出简单的图、有丰富的接口进行精细化绘图、和Numpy结合做科学可视化及三维图配合默契、三维图。但也有些缺点，如不容易基于实用目的绘制有一定难度的图表（如小提琴图等）、标签等元素需指定坐标而不能自适应优化显示、难以实现交互。</p>
<p><a href="https://matplotlib.org/">官网</a>说：</p>
<blockquote>
<p>Matplotlib tries to make easy things easy and hard things possible.</p>
</blockquote>
<a id="more"></a>

<p>越用越认可这句话，Matplotlib非常强大，Hard things是possible但并非easy and fast。</p>
<p>（发知乎或简书这里有viz那张图）</p>
<h3 id="可视化基础框架"><a href="#可视化基础框架" class="headerlink" title="可视化基础框架"></a>可视化基础框架</h3><p>对于一个数据表df(通过pandas读入为DataFrame)来说，用Matplotlib对其进行可视化的基础框架为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;y&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>通过上面几行代码就可以画出df表周一到周五y指标的变化折线。</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-01-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6-%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt="折线图绘制示例"></p>
<p>Matplotlib其实为作图提供了两套可视化接口：</p>
<ul>
<li><p><code>plt.plot()</code>系列</p>
</li>
<li><p><code>fig, ax = plt.subplots()  ax.plot()</code> 系列</p>
</li>
</ul>
<p>根据官网教程，分别对应MATLAB的陈述式语法和面向对象写法，具体可参考<a href="https://matplotlib.org/tutorials/introductory/lifecycle.html#sphx-glr-tutorials-introductory-lifecycle-py">tutorials:lifecycle.html</a> ，</p>
<p>个人理解，plt.plot()适合用于快速出图，读入一个数据表后想快速知道数据分布、指标关系等，通过plt.plot()系列语句直接出图，而ax.plot()更方便用来精细绘图，接口对各种图表元素的编辑很友好。</p>
<p>在Matplotlib官网搜索，通常能看到两套接口，如搜绘制饼图的关键词<code>pie</code>，结果中的axes.Axes.pie对应ax.pie()的用法，pyplot.pie对应plt.pie()的函数接口。</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-02-%E4%B8%A4%E5%A5%97%E6%8E%A5%E5%8F%A3.png" alt="两套接口"></p>
<p>ax.×××()的写法看起来要写的语句多些，但这种面向对象(object-oriented)的写法通过<code>fig, ax = plt.subplots()</code>建立画布(figure)和定义轴域(axes)，能更明确在哪作画和映射规则，给用户更大的自由度和更精细的调参能力。Axes包含了一套坐标轴(axis)，确定了x/y坐标轴之后，数值再确定对应坐标，也就唯一确定了所在位置（这是二维情况下，更高维度就会对应着更多的axis），散点图是去确定点在轴域下的位置，柱状图是确定每个柱柱所在的位置，因此一套Axes就确定了唯一的独立的图，一个画布可以有多套Axes。更具体的辨析可读<a href="https://zhuanlan.zhihu.com/p/93423829">姚太多啊的一篇文章</a>，简单说就是ax.×××()更方便调细节，初学者尽量避免用plt.×××系列来画图。</p>
<h3 id="基础图表绘制"><a href="#基础图表绘制" class="headerlink" title="基础图表绘制"></a>基础图表绘制</h3><p>数据可视化从目的来说，是为了更直观展示数据或数据之间的对比、分布或关联关系。散点图、折线图、柱状图、条形图、饼图、直方图是非常常用而基础的可视化图。个人认为通过画这几种基础图并调细节是很好的学可视化实践。</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-03-%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%88%B0%E5%90%84%E7%A7%8D%E5%8F%AF%E8%A7%86%E5%9B%BE.PNG" alt="将数据映射为可视图表"></p>
<p>为了整体的美观和一致性，本文都用了一套自定义配色，通过<code>mpl.rcParams[&quot;axes.prop_cycle&quot;] = mpl.cycler(&#39;color&#39;,  [&#39;1EAFAE&#39;, &#39;A3FFFF&#39;, &#39;69FFFF&#39;])</code> 语句实现简单改配色，具体关于<code>mpl.rcParams</code>后面再展开。</p>
<p>画散点图可以用两种主要的方法，<code>scatter(x,y)</code>和<code>plot(x,y,&#39;o&#39;)</code> 。<br>通过<code>ax.scatter(x,y)</code>绘制以x为横坐标，y为纵坐标的散点图，scatter的重要参数如下：</p>
<ul>
<li><code>x,y</code>：对应着x轴和y轴的数据，散点画在坐标轴里的[xi,yi]处。</li>
<li><code>s,c,alpha</code>: 对应散点大小(size)、颜色(color)、透明度，都可以传一个和点数量相同长度的数组，如<code>s=df[&#39;z&#39;]</code>可以做气泡图，一般气泡图为了防止遮盖问题，通常设置一定的透明度，alpha的范围为0到1。<code>c=&#39;#BA5C25&#39;</code>设置点颜色，c赋值为一个数组可以做出每个点一个颜色的效果。</li>
<li><code>marker</code>：设置点的形状；</li>
<li><code>cmap</code>:颜色映射；</li>
<li><code>norm</code>:当颜色c为一组浮点数时，把值标准化到[0,1]做颜色映射，<code>vmin</code>和<code>vamx </code>参数是结合 <code>norm</code> 来用的；</li>
</ul>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-04-%E6%95%A3%E7%82%B9%E5%9B%BE%E5%8F%82%E6%95%B0%E7%A4%BA%E4%BE%8B-1.png" alt="02-mat-04-散点图参数示例"></p>
<p><code>ax.plot(x,y,&#39;o&#39;)</code>也可以画散点图，ax.plot()核心是绘制坐标系下的点和点之间的连线的，当突出点的大小而省略线时，就是散点图了，同样突出线就变成了折线图。通过fmt(也就是format_string)参数来控制这些，包括点的形状、颜色、线的风格颜色等。折线图基础绘制效果可回看上一部分<strong>可视化基础框架</strong>。</p>
<p>plot()的常用参数如下：</p>
<ul>
<li><code>x,y</code>: x轴和y轴的数据，当plot()只有一个输入列表或数组时，参数被当做y轴，也就是value，x轴以索引自动生成，也就是<code>ax.plot(y)</code>相当于<code>ax.plot(range(len(y)),y)</code>;</li>
<li><code>fmt</code>: 控制x,y绘制的折线的点形状、颜色、线的风格、颜色；</li>
<li>其他的<em>lines.Line2D</em>支持的属性， 如<code>color</code>控制线颜色，<code>marker</code>控制点形状，<code>linestyle</code>控制线风格类型及<code>linewidth</code>控制线宽等，如果既设置了<code>fmt</code>又指定了<code>color</code>呢？可以实践一下，线的颜色会根据color属性最终显示。</li>
</ul>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-05-%E5%B8%B8%E7%94%A8fmt%E5%AD%97%E7%AC%A6%E6%84%8F%E4%B9%89%E6%95%B4%E7%90%86.png" alt="常用fmt字符意义整理"></p>
<p>plot()除了plot(x,y,[fmt])这种写法之外，还可以传多套x,y以绘制多条折线，写法是<code>plot(x,y,[fmt],x2,y2,[fmt2],…)</code>。</p>
<p>另外plot()还支持<code>plot(&#39;col1&#39;,&#39;col2&#39;,data=df)</code>这种写法，这是对二维表格数据更友好的接口。本文讲到的其他图形如bar、barh等基本也都是支持ax.×××(df[‘x’],df[‘y’]) 和ax.×××(x,y,data)写法的。</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-06-3%E7%A7%8D%E5%86%99%E6%B3%95%E5%8F%8A%E7%BB%93%E6%9E%9C%E5%9B%BE.png" alt="plot 3种写法及结果图"></p>
<p>通过<code>ax.bar(x,height)</code>绘制柱状图，条形图的绘制用<code>ax.barh(y,width)</code>，因bar和barh的用法很类似，参数之间有对应关系，这里结合着看。</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-07-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%98%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0.png" alt="柱状图绘制及参数"></p>
<ul>
<li><code>x,height</code>: x轴的值和各柱的高，相当于折线图的x,y；</li>
<li><code>width</code>: 柱的宽度，默认是0.8，也可以传入一个数组，画不等宽的柱状图；</li>
<li><code>bottom</code>: 每个柱底部开始位置，默认是0，改bottom可以画堆积柱状图、瀑布图等；</li>
<li><code>align</code>: 柱状的x是在柱底部中心还是边缘，{‘center’, ‘edge’}，默认是center；</li>
<li><code>data</code>: 可以传入一个DataFrame，用法和前面说到的<code>ax.plot(&#39;col1&#39;,&#39;col2&#39;,data=df)</code>一致；</li>
<li>其他像<code>color</code>(柱颜色)、<code>edgecolor</code>(柱边框色)、<code>linewidth</code>(边框线宽)等图元属性用法都一致，<code>linewidth</code>也是可以简写为<code>lw</code>的，颜色可以传一个数组，可以画出五彩斑斓的柱，也可借由这个参数美化瀑布图；</li>
<li>条形图barh的参数有<code>barh(y,width,height,left,align)</code>，y是Y轴的值，每个柱的位置，因此barh的y对应bar的x，barh的width对应bar的height，barh的height对应bar的width。每个柱开始的位置是left，对应bar的bottom。align、data、color等一致。</li>
</ul>
<p>注意的是柱状图绘制语句<code>ax.bar(x,height)</code>的返回值是一个容器(BarContainer)，包含了所有画出来的柱。通过这个返回值可以对柱进行一些个性化的处理，另外的应用就是根据返回柱的属性给每个柱标上文本标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给柱状图标上标签</span></span><br><span class="line">fig,ax= plt.subplots()</span><br><span class="line">rects=ax.bar(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">ax.set_ylim(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> rect <span class="keyword">in</span> rects:</span><br><span class="line">    height = rect.get_height()</span><br><span class="line">    ax.annotate(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(height),</span><br><span class="line">            xy=(rect.get_x() + rect.get_width() / <span class="number">2</span>, height),</span><br><span class="line">            xytext=(<span class="number">0</span>,<span class="number">1</span>),  <span class="comment"># 1 points vertical offset</span></span><br><span class="line">            textcoords=<span class="string">&quot;offset points&quot;</span>,</span><br><span class="line">            ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过给x以一定的偏移量，绘制簇状柱形图。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#簇状柱 ClusterBar</span></span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(df)+<span class="number">1</span>)) </span><br><span class="line"></span><br><span class="line">width = <span class="number">0.2</span>  <span class="comment">#每个柱的宽度</span></span><br><span class="line">x1=[i-width <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">x2=[i+width <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>,<span class="number">5</span>))</span><br><span class="line">rects1 = ax.bar(x1,df[<span class="string">&#x27;y&#x27;</span>], width*<span class="number">2</span>, label=<span class="string">&#x27;Men&#x27;</span>,color=<span class="string">&#x27;#1EAFAE&#x27;</span>)</span><br><span class="line">rects2 = ax.bar(x2,df[<span class="string">&#x27;z&#x27;</span>], width*<span class="number">2</span>, label=<span class="string">&#x27;Women&#x27;</span>,color=<span class="string">&#x27;#69FFFF&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xticks(x)</span><br><span class="line">ax.set_xticklabels(df[<span class="string">&#x27;x&#x27;</span>])</span><br><span class="line">ax.legend()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-08-%E7%B0%87%E7%8A%B6%E6%9F%B1%E5%BD%A2%E5%9B%BE.png" alt="簇状柱形图"></p>
<p>通过给bottom参数传一个数组，可以画堆叠柱状图：堆叠柱除了等值堆叠之外，还可以等比堆叠，思路就是将每个x对应的柱都做一下数值变换，把柱的高度约束在[0,1]，且堆叠之和为1，height=h[i]/sum(h)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#堆叠柱状图</span></span><br><span class="line">fig,ax= plt.subplots()</span><br><span class="line">ax.bar(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;y&#x27;</span>],label=<span class="string">&#x27;Men&#x27;</span>)</span><br><span class="line">ax.bar(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;z&#x27;</span>],bottom=df[<span class="string">&#x27;y&#x27;</span>],label=<span class="string">&#x27;Women&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment">#等比例堆叠柱</span></span><br><span class="line">fig,ax= plt.subplots()</span><br><span class="line">df[<span class="string">&#x27;y1&#x27;</span>]=df.apply(<span class="keyword">lambda</span> x:(x[<span class="string">&#x27;y&#x27;</span>])*<span class="number">100</span>/(x[<span class="string">&#x27;y&#x27;</span>]+x[<span class="string">&#x27;z&#x27;</span>]),axis=<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&#x27;z1&#x27;</span>]=df.apply(<span class="keyword">lambda</span> x:(x[<span class="string">&#x27;z&#x27;</span>])*<span class="number">100</span>/(x[<span class="string">&#x27;y&#x27;</span>]+x[<span class="string">&#x27;z&#x27;</span>]),axis=<span class="number">1</span>)</span><br><span class="line">ax.bar(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;y1&#x27;</span>])</span><br><span class="line">ax.bar(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;z1&#x27;</span>],bottom=df[<span class="string">&#x27;y1&#x27;</span>])</span><br><span class="line">ax.set_ylim(<span class="number">0</span>,<span class="number">100</span>) <span class="comment">#标签设置等代码省略</span></span><br></pre></td></tr></table></figure>


<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-09-%E5%A0%86%E5%8F%A0%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%98%E5%88%B6%E6%95%88%E6%9E%9C.png" alt="堆叠柱状图绘制效果"></p>
<p>调节<code>width</code>参数使得柱和柱之间的宽度为0，并对数据进行统计在画图，可以用ax.bar()绘制直方图，但也不需要这么复杂，Matplotlib提供了绘制直方图的接口<code>ax.hist(x,bins,normed)</code>，可以直接对某列数据绘制直方图。x是需要统计分布的数据列，bins控制分箱的个数，默认是10。</p>
<p>箱线图在数据分析中挺常用的，箱线图对于数据分布有很好的展示作用，Matplotlib提供了<code>boxplot(x)</code>用于绘制箱线图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax= plt.subplots()</span><br><span class="line">ax.boxplot(df[<span class="string">&#x27;y&#x27;</span>])  <span class="comment">#箱线图</span></span><br></pre></td></tr></table></figure>


<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-10-%E7%94%A8df%E7%BB%98%E5%88%B6%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%92%8C%E7%AE%B1%E7%BA%BF%E5%9B%BE.png" alt="用同一列绘制的直方图和箱线图"></p>
<p>饼图是可视化中基础而重要的图形，是各种数据报告的常客，Matplotlib绘制饼图时因为xy轴默认比例尺不同，为了得到不扁的饼，需设置xy轴1像素对应的值相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绘制饼图</span></span><br><span class="line">fig,ax=plt.subplots(subplot_kw=<span class="built_in">dict</span>(aspect=<span class="string">&quot;equal&quot;</span>)) </span><br><span class="line">ax.pie(df[<span class="string">&#x27;y&#x27;</span>]) <span class="comment">#为了得到不扁的饼，设置xy轴比例尺相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="comment">#环状图</span></span><br><span class="line">fig, ax = plt.subplots(subplot_kw=<span class="built_in">dict</span>(aspect=<span class="string">&quot;equal&quot;</span>)) </span><br><span class="line">wps=<span class="built_in">dict</span>(width=<span class="number">0.3</span>, edgecolor=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ax.pie(df[<span class="string">&#x27;y&#x27;</span>], radius=<span class="number">1</span>,startangle=<span class="number">90</span>,counterclock=<span class="literal">False</span>,wedgeprops=wps)</span><br><span class="line">ax.pie(df[<span class="string">&#x27;z&#x27;</span>], radius=<span class="number">1</span>-<span class="number">0.3</span>,startangle=<span class="number">90</span>,counterclock=<span class="literal">False</span>,wedgeprops=wps)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-11-%E9%A5%BC%E5%9B%BE%E5%92%8C%E7%8E%AF%E7%8A%B6%E5%9B%BE.png" alt="饼图和环状图"></p>
<h3 id="图表元素调校"><a href="#图表元素调校" class="headerlink" title="图表元素调校"></a>图表元素调校</h3><p>一张可视化图上除了主要的点、线、面之外，文本标签、坐标轴标签等也是很重要的可视媒介，特别是对于信息图表而言。<br>下面这张<a href="https://matplotlib.org/tutorials/introductory/usage.html">图</a>基本囊括了用到的图形元素</p>
<h4 id="图元"><a href="#图元" class="headerlink" title="图元"></a>图元</h4><p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-12-figure%E4%B8%8A%E7%9A%84%E5%9B%BE%E5%85%83.png" alt="figure上的图元"></p>
<p>加文本可以通过<br><code>ax.text(x,y, &quot;Text&quot;)</code> 。添加标题通常写<code>ax.set_title()</code>，另外也可以用<code>ax.title.set_text(&#39;title&#39;) </code>或<code>ax.set(title=&#39;ttl&#39;)</code>设置标题，<br>整理如下：</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-12-%E5%B8%B8%E7%94%A8%E5%9B%BE%E8%A1%A8%E6%A0%87%E7%AD%BE%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%8E%A5%E5%8F%A3.png" alt="常用图表标签添加的接口"></p>
<ul>
<li><code>ax.text(x,y, &quot;Text&quot;)</code>:在坐标[x,y]处添加文本Text，文本支持latex公式，如<code>ax.text(2,6, r&#39;$E=mc^2$&#39;, fontsize=15)</code>；</li>
<li><code>ax.set_title()</code>:添加标题；</li>
<li><code>ax.set_ylim(0,4)</code> 设置y轴值的范围（类似于函数的值域），例如对于y=[],直接ax.plot(y)画出来的折线图y轴范围是<br>，通过<code>ax.set_ylim(0,4)</code> 可以显示0~100范围的效果。同理通过<code>ax.set_ylim(0,4)</code>设置x轴范围（定义域）；</li>
<li><code>ax.set_ylabel(&quot;Y axis label&quot;)</code>:给y轴加上坐标轴标题；</li>
<li><code>ax.tick_params(which=&#39;major&#39;, width=1.0)</code>:细调坐标轴刻度；</li>
<li><code>ax.legend()</code> : 设置图例 ；</li>
</ul>
<h4 id="形状与图片"><a href="#形状与图片" class="headerlink" title="形状与图片"></a>形状与图片</h4><p>图形元素设置除了文本类型之外，也可以往里加形状 。</p>
<ul>
<li>加线：<code>import matplotlib.lines as lines；ax.add_artist(lines.Line2D([15,15], [0, 10],color=&#39;#1EAFAE&#39;)) </code>，其效果可参考矩阵图绘制效果；</li>
<li>加带箭头的线: <code>ax.arrow(0, 0, 0.5, 0.5, head_width=0.05, head_length=0.1, fc=&#39;k&#39;, ec=&#39;k&#39;)</code>；</li>
<li>加一个垂直的平均线: <code>ax.axvline(x, ls=&#39;--&#39;, color=&#39;r&#39;)</code>，那水平平均线呢？<code>axhline(y=0, xmin=0, xmax=1, **kwargs)</code>；</li>
<li>加垂直或水平的强调矩形: <code>ax.axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs)</code> 和 <code>ax.axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs)</code>；</li>
<li>加矩形：<code>patches.append(mpatches.Rectangle([0.5, 0.5], 0.5,0.8))</code>，可用于绘制甘特图；</li>
<li>加圆形(及椭圆): <code>patches.append( mpatches.Ellipse((x,y), width, height))</code>；</li>
<li>加带箭头的形状：<code>ax.annotate(&#39;箭头文本&#39;, xy=(4,5), xytext=(3,2),color, arrowprops=dict( arrowstyle=&#39;-&gt;&#39;, connectionstyle=&quot;arc3&quot;))</code>，加图标型的箭头：<code>patches.append( mpatches.Arrow(x,y, dx,dy,width))</code>；</li>
<li>加图片: <code>mpimg.imread(ipath); ax.axis(&#39;off&#39;); ax.imshow(img)</code>；</li>
</ul>
<p>给散点图加标签并加分隔线绘制矩阵图以实践一下以上方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.lines as lines</span><br><span class="line">fig, ax&#x3D; plt.subplots()</span><br><span class="line">ax.plot(df[&#39;z&#39;],df[&#39;y&#39;],&#39;o&#39;)</span><br><span class="line">ax.add_artist(lines.Line2D([70,70], [30,100],color&#x3D;&#39;#000000&#39;,lw&#x3D;3)) #是[x1,x2],[y1,y2] 不是[x1,y1],[x2,y2]</span><br><span class="line">ax.add_artist(lines.Line2D([30,100], [65,65],color&#x3D;&#39;#000000&#39;,lw&#x3D;3))</span><br><span class="line">ax.set_xlim(30,100)</span><br><span class="line">ax.set_ylim(30,100)</span><br><span class="line">ax.set_xlabel(&quot;z&quot;)</span><br><span class="line">ax.set_ylabel(&quot;y&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-13-%E7%9F%A9%E9%98%B5%E5%9B%BE%E7%BB%98%E5%88%B6%E7%A4%BA%E4%BE%8B.png" alt="矩阵图绘制示例"></p>
<p>绘制瀑布图综合运用ax.bar()的参数和文本标签，并封装为一个函数，以后使用只需要调用就好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#瀑布图</span></span><br><span class="line">x=[<span class="number">17</span>,-<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>] <span class="comment">#原始数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waterfall_chart</span>(<span class="params">x</span>):</span></span><br><span class="line">    j=<span class="number">0</span> <span class="comment">#sum(x) 最终柱的结果</span></span><br><span class="line">    k=<span class="number">0</span> <span class="comment">#k=x[i-1]</span></span><br><span class="line">    x0=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span>:</span><br><span class="line">            x0.append(j+i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x0.append(j)</span><br><span class="line">        j+=i</span><br><span class="line"></span><br><span class="line">    x1=[<span class="built_in">abs</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">    c1=[<span class="string">&#x27;#1EAFAE&#x27;</span> <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;#69FFFF&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">    c1.append(<span class="string">&#x27;#BA5C25&#x27;</span>)</span><br><span class="line">    x0[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    x0.append(<span class="number">0</span>)</span><br><span class="line">    x1.append(j)</span><br><span class="line">    x.append(j)</span><br><span class="line">    w=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(x)+<span class="number">1</span>))</span><br><span class="line">    fig,ax= plt.subplots(figsize=(<span class="number">6</span>,<span class="number">5</span>))</span><br><span class="line">    ax.bar(w,x0,alpha=<span class="number">0</span>) <span class="comment">#都透明度为0了，颜色不重要</span></span><br><span class="line">    rects=ax.bar(w,x1,bottom=x0,color=c1) <span class="comment">#颜色可传一个数组的</span></span><br><span class="line">    ax.set_ylim(<span class="number">0</span>, <span class="number">30</span>)</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> rect <span class="keyword">in</span> rects: <span class="comment">#加上适当的文本标签 </span></span><br><span class="line">        height = rect.get_height()+x0[i]</span><br><span class="line">        ax.annotate(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x[i]),</span><br><span class="line">                xy=(rect.get_x() + rect.get_width() / <span class="number">2</span>, height),</span><br><span class="line">                xytext=(<span class="number">0</span>,<span class="number">1</span>),  <span class="comment"># 1 points vertical offset</span></span><br><span class="line">                textcoords=<span class="string">&quot;offset points&quot;</span>,</span><br><span class="line">                ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    ax.set_xticklabels([<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;Q1&#x27;</span>,<span class="string">&#x27;Q2&#x27;</span>,<span class="string">&#x27;Q3&#x27;</span>,<span class="string">&#x27;Q4&#x27;</span>,<span class="string">&#x27;Ys&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line">waterfall_chart(x)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-14-%E7%80%91%E5%B8%83%E5%9B%BE%E7%BB%98%E5%88%B6%E7%A4%BA%E4%BE%8B.png" alt="瀑布图效果"></p>
<h3 id="组合图"><a href="#组合图" class="headerlink" title="组合图"></a>组合图</h3><p>为了更好地展现数据间的联系或变化，我们有时会需要将多种图表类型用在同一张可视化图里，一种是共用坐标轴的组合图，例如面积图+柱状图的组合、散点+折线图就是很基础的组合图。另一种是双坐标轴，很常见的图是左边的y轴是月活，画柱状图，右边的y轴是增长率，画折线图。</p>
<h4 id="共用坐标轴"><a href="#共用坐标轴" class="headerlink" title="共用坐标轴"></a>共用坐标轴</h4><p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-15-%E5%85%B1%E7%94%A8%E5%9D%90%E6%A0%87%E8%BD%B4%E7%BB%84%E5%90%88%E5%9B%BE%E4%B8%A4%E4%BE%8B%E5%AD%90.png" alt="共用坐标轴组合图两例子"></p>
<p>棒棒糖图(Lollipop)是将条形图的柱变得很细并突出末端的一类图，形似棒棒糖，特别适合于展示分类标签很多的数据。可以通过将柱状图和散点图结合的方法绘制，Matplotlib库绘制起来并不复杂，代码如下。但对于一些散点图的y轴不支持分类标签的库来说，要画棒棒糖图还是挺复杂的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">19</span>]</span><br><span class="line">x=[<span class="string">&#x27;c&#x27;</span>+<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y))]</span><br><span class="line"></span><br><span class="line">fig, ax= plt.subplots(figsize=(<span class="number">6</span>,<span class="number">6</span>)) </span><br><span class="line">ax.barh(x,y,height=<span class="number">0.08</span>,zorder=<span class="number">1</span>) <span class="comment">#图层顺序的解决方案</span></span><br><span class="line">ax.scatter(y,x,zorder=<span class="number">2</span>,color=<span class="string">&#x27;#ba5c25&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>有时为了对比两类数据，除了用簇状柱形图或簇状条形图外，也可以试试哑铃图，理解了上面画棒棒糖图的方法之后，要组合出哑铃图并不难，对数据进行一定运算后用barh加两个scatter就可以画出来。</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-16-%E6%A3%92%E6%A3%92%E7%B3%96%E5%9B%BE%E5%92%8C%E5%93%91%E9%93%83%E5%9B%BE.png" alt="棒棒糖图和哑铃图"></p>
<p>帕累托图是双坐标轴的可视化典例。帕累托图特别适合展示符合长尾效应的数据。matplotlib给我们提供了<code>ax.twinx()</code>用于生成共用x轴的另一个Axes，效果就是左边的y轴比例尺和右边比例尺不一定一样，能更好地将两类图进行效果组合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y=[<span class="number">23</span>,<span class="number">162</span>,<span class="number">51</span>,<span class="number">119</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">8</span>] <span class="comment">#模拟数据</span></span><br><span class="line">x=[<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(y)+<span class="number">2</span>)]</span><br><span class="line">y=<span class="built_in">sorted</span>(y,reverse=<span class="literal">True</span>)</span><br><span class="line">ysum=<span class="built_in">sum</span>(y)</span><br><span class="line">y2=[]</span><br><span class="line">cc=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:</span><br><span class="line">    cc+=i</span><br><span class="line">    y2.append(cc/ysum*<span class="number">100</span>)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">rects=ax1.bar(x,y,color=<span class="string">&#x27;#1EAFAE&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;Month IC&#x27;</span>)</span><br><span class="line">ax1.set_ylim(<span class="number">0</span>, <span class="number">180</span>)</span><br><span class="line">ax2 = ax1.twinx() </span><br><span class="line"><span class="comment">#https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.twinx.html#matplotlib.axes.Axes.twinx</span></span><br><span class="line">ax2.set_ylim(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(x, y2,<span class="string">&#x27;o&#x27;</span>,color=<span class="string">&#x27;#FFA069&#x27;</span>,linewidth=<span class="number">2</span>,ls=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rect <span class="keyword">in</span> rects:</span><br><span class="line">    height = rect.get_height()</span><br><span class="line">    ax1.annotate(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(height),</span><br><span class="line">            xy=(rect.get_x() + rect.get_width() / <span class="number">2</span>, height),</span><br><span class="line">            xytext=(<span class="number">0</span>,<span class="number">1</span>),  <span class="comment"># 1 points vertical offset</span></span><br><span class="line">            textcoords=<span class="string">&quot;offset points&quot;</span>,</span><br><span class="line">            ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Pareto in Matplotlib&quot;</span>) <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-17-%E5%B8%95%E7%B4%AF%E6%89%98%E5%9B%BE.png" alt="帕累托图"></p>
<h4 id="子图与分面"><a href="#子图与分面" class="headerlink" title="子图与分面"></a>子图与分面</h4><p>除了组合图外，有时候我们也需要将多个图并排以展现某种数据关系。前面说过一个画布下可以有多套Axes，正常情况下我们只需要一套Axes用来画图，但是也经常需要在一个画布中画多张图，形成分面或子母图的效果，前面我们基本都是写<code>fig, ax= plt.subplots()</code>，实际上<code>subplots()</code>可以设置nrows、ncols参数生成多套Axes。</p>
<p>plt.subplots()的常用写法有：</p>
<ul>
<li><code>plt.subplot(3,2,4)</code>:在全局绘图区域中建立3行、2列的分区绘图区域，并定位到第4个子图区域，返回一个axes；</li>
<li><code>plt.subplot(324)</code>: 效果和上面subplot(3,2,4)的写法一致；</li>
<li><code>plt.subplots()</code>:  默认1行1列，生成的axes就是一个；</li>
<li><code>plt.subplots(3,2)</code> : 没有指定绘图编号，返回值包括一个figure和多个axes，和<code>ax[0, 0].×××(x, y) </code>搭配着用；</li>
<li><code>fig = plt.figure();  ax= fig.add_subplot(221)</code>:先建立一个画布，在画布上添加2x2个子图，并定位到顺序第一个子图；</li>
</ul>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-18-%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AA%E7%BB%98%E5%9B%BE%E5%8C%BA%E5%9F%9F.png" alt="生成多个绘图区域"></p>
<p>图中代码在全局绘图区域中建立n行、m列的分区绘图区域，并定位到其中一个子图区域。之后ax的用法和前面一致，不赘述。</p>
<p>生成的图片在shell环境中弹出的界面有保存图片的按键，在jupyter环境中可以点击图片然后右键保存。而如果要通过代码保存图片到本地，一般通过<code>plt.savefig(fname,dpi=300)</code>保存图片，参数有文件保存路径(fname)、图片每英寸像素(dpi)、边缘颜色(edgecolor)等。在shell环境中一般通过plt.show()展示图片，而jupyter notebook中通常写<code>%matplotlib inline </code>将图片直接在Out[]里输出展示。</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-19-inline-vs-show.png" alt="matplotlib inline vs plt.show"></p>
<p>Matplotlib的rcParams接口可以设置很多个性化内容，包括刚提到的savefig的edgecolor默认值，可以写<code>mpl.rcParams[&quot;savefig.edgecolor&quot;]=&#39;blue&#39;</code>改变原来的默认值white。直方图的默认分箱数可以通过<code>rcParams[&quot;hist.bins&quot;]=5</code>改变。</p>
<p>而为了在Matplotlib中支持中文，各教程的解决方案基本都有<code>mpl.rcParams[&#39;font.family&#39;]=&#39;SimHei&#39;</code>这句，就是将Matplotlib的字体替换为微软雅黑。前面<strong>基础图表绘制部分</strong>通过更新mpl.rcParams[“axes.prop_cycle”]改变了绘图的主题色，Matplotlib本身是提供了备选的绘图渲染的各种主题，可以通过<code>style.use(&#39;ggplot&#39;)</code>调用ggplot主题（想换回默认主题用<code>style.use(&#39;default&#39;)</code>）。就像给输入法换皮肤一样，rcParams接口给了我们更多的自由度和个性化。</p>
<h3 id="三维及科学可视化"><a href="#三维及科学可视化" class="headerlink" title="三维及科学可视化"></a>三维及科学可视化</h3><p>三维可视化和科学可视化是Matplotlib特别擅长的领域，人类作为三维生物，对三维的图像有一定的偏好，扁平化和三维各有优势，各有不同的应用场合，能画好二维可视化图也该会画三维的图表，且一些场景用好三维有奇效。Matplotlib的三维可视化封装在mpl_toolkits工具套件的<code>mplot3d</code>里，mplot3d下的API主要包括Axes3D(三维坐标轴区域)、art3d.xx3D(三维图元)和proj3d(三维坐标变换)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D  <span class="comment"># noqa: F401 unused import</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.bar(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;y&#x27;</span>], zs=<span class="number">0</span>, zdir=<span class="string">&#x27;y&#x27;</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line">ax.bar(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;z&#x27;</span>], zs=<span class="number">1</span>, zdir=<span class="string">&#x27;y&#x27;</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line">ax.bar(df[<span class="string">&#x27;x&#x27;</span>],df[<span class="string">&#x27;y&#x27;</span>], zs=<span class="number">2</span>, zdir=<span class="string">&#x27;y&#x27;</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_yticks([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-20-%E4%B8%89%E7%BB%B4%E4%B8%8B%E7%9A%843%E5%A5%97%E6%9F%B1%E5%9B%BE.png" alt="绘制三维下的3套柱图"></p>
<p>三维可视化和科学可视化联系很紧密，科研作图中应用广泛，各种漂亮的参数曲面在官网示例里有很多，这里略过、当然二维下也能画出很优美的函数图像，结合numpy生成[0,2]之间的正弦函数曲线只需要4行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = np.arange(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">0.01</span>)</span><br><span class="line">s = <span class="number">1</span> + np.sin(<span class="number">2</span> * np.pi * t)</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(t, s)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-21-%E7%A7%91%E5%AD%A6%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8B%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0.png" alt="科学可视化之正弦函数图像"></p>
<p>绘制指数函数、分形的雪花曲线也是类似的过程，在官网案例集有类似的例子，具体这里不展开。</p>
<p>总结下本文从Matplotlib的可视化基础框架一步步画散点、折线、柱状、箱线等图，通过理解参数拓展画了瀑布图、矩阵图、棒棒糖图等，并且微调坐标轴文本、标题等图形元素，让可视化更完备，通过双y轴绘制帕累托图等组合图，也绘制了包含多张子图的图和三维图。</p>
<p>通过以上实践可以看到的Matplotlib可视化语法的特点是绘图对象和标签标题等元素有一定独立性，且有不同层级的接口可以用来微调元素，例如设置标题就有多种写法 ，Matplotlib不同于ggplot2的管道写法、也不同于Altair等库将数据传到chart对象再调用mark_bar()等确定绘制什么图。可视化是要好看，也不能忘了所展现的数据与数据间的关系是重点。</p>
<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-22-%E6%9C%AC%E6%96%87%E5%86%85%E5%AE%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="本文内容思维导图"></p>
<p>最后用极坐标绘心形线结束本文。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#极坐标绘心形线</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">theta= np.arange(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">0.05</span>)</span><br><span class="line">r=<span class="number">5</span>*(<span class="number">1</span>-np.sin(theta)) <span class="comment">#a取5</span></span><br><span class="line">ax = plt.subplot(<span class="number">111</span>, projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line">ax.plot(theta, r,lw=<span class="number">3</span>)</span><br><span class="line">ax.grid(<span class="literal">True</span>)</span><br><span class="line">ax.text(<span class="number">1.56</span>,<span class="number">6</span>,<span class="string">&#x27;r=a(1-sinθ)&#x27;</span>,ha=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">		fontsize=<span class="number">18</span>,color=<span class="string">&#x27;#1EAFAE&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/27/viz-matplotlib-in-action/02-mat-22-%E6%9E%81%E5%9D%90%E6%A0%87%E7%BB%98%E5%BF%83%E5%BD%A2%E7%BA%BF.png" alt="极坐标绘心形线"></p>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>viz</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>为streamlit的实践笔记————为脚本快速增加交互式页面</title>
    <url>/2022/06/11/streamlit-in-action-notes.html</url>
    <content><![CDATA[<p>基本结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;111&#x27;</span>)</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
</search>
